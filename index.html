<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Altagether NC Dashboard Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/x-icon" href="resources/images/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Alegreya:wght@800&display=swap" rel="stylesheet">
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.0/togeojson.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-kml@1.0.0/dist/leaflet-kml.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <style>
    :root {
      --dark-green: #283618;
      --medium-green: #606C38;
      --light-cream: #FEFAE0;
      --tan: #DDA15E;
      --brown: #BC6C25;
      --light-green: #afcc8e;
      --lighter-green: #cdf4a0;
      
      /* Semantic color mappings */
      --primary: var(--medium-green);
      --primary-dark: var(--dark-green);
      --accent: var(--tan);
      --accent-dark: var(--brown);
      --background: var(--light-cream);
      --background-light: var(--lighter-green);
      --highlight: var(--light-green);
      --text: var(--dark-green);
      --text-light: rgba(40, 54, 24, 0.7);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow-x: hidden;
      overflow-y: auto;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--background) 0%, var(--background-light) 100%);
      color: var(--text);
    }

    /* Typography - Alegreya Extra Bold for headings */
    h1, h2, h3, h4, h5, h6,
    .nav-item,
    .header-left,
    .chart-title,
    .card-header,
    .btn-save,
    .btn-load,
    .nav-load-btn {
      font-family: 'Alegreya', serif;
      font-weight: 800;
    }

    /* Top Header Bar */
    .top-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 56px;
      background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary) 100%);
      color: var(--light-cream);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.3), 0 2px 4px rgba(40, 54, 24, 0.2);
      backdrop-filter: blur(10px);
    }

    .header-left {
      font-size: 1.8rem;
      letter-spacing: 0.5px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      font-weight: 800;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 0.9rem;
      font-weight: 500;
      flex: 1;
      justify-content: flex-end;
    }

    .live-indicator {
      color: var(--lighter-green);
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      padding: 4px 12px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      backdrop-filter: blur(5px);
    }

    #zoneNameDisplay {
      font-weight: 500;
    }

    /* Alert scrolling area inside header */
    .header-alert-container {
      position: relative;
      width: 50%;
      max-width: 600px;
      height: 100%;
      overflow: hidden;
      margin-left: 20px;
      flex: 1;
      min-width: 0;
    }

    .header-alert-content {
      display: inline-block;
      white-space: nowrap;
      padding: 0 20px;
      animation: scroll-alert 30s linear infinite;
      font-weight: 600;
      font-size: 0.85rem;
      letter-spacing: 0.3px;
      line-height: 56px;
      color: var(--light-cream);
    }

    .header-alert-content a {
      color: var(--light-cream);
      text-decoration: underline;
      font-weight: 700;
    }

    .header-alert-content a:hover {
      text-decoration: none;
    }

    @keyframes scroll-alert {
      0% {
        transform: translateX(100%);
      }
      100% {
        transform: translateX(-100%);
      }
    }

    /* App Container */
    .app-container {
      position: fixed;
      top: 56px;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
    }

    /* Left Navigation Bar */
    .left-nav {
      width: 240px;
      background: linear-gradient(180deg, var(--background) 0%, rgba(254, 250, 224, 0.95) 100%);
      border-right: 3px solid var(--primary);
      display: flex;
      flex-direction: column;
      z-index: 100;
      box-shadow: 4px 0 12px rgba(40, 54, 24, 0.15), 2px 0 4px rgba(40, 54, 24, 0.1);
      overflow-y: auto;
      overflow-x: hidden;
      backdrop-filter: blur(10px);
      transition: filter 0.3s ease;
    }

    .left-nav.disabled {
      filter: blur(4px);
      opacity: 0.6;
    }

    .left-nav.disabled .nav-item[data-view]:not([data-view="home"]) {
      pointer-events: none;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .left-nav.disabled .nav-section-bottom {
      pointer-events: auto;
      filter: none;
      opacity: 1;
    }

    .nav-section {
      padding: 20px 0;
      border-bottom: 1px solid rgba(96, 108, 56, 0.2);
    }

    .nav-section-bottom {
      margin-top: auto;
      border-top: 3px solid var(--primary);
      border-bottom: none;
      padding: 20px;
      background: rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(5px);
    }


    .nav-item {
      display: block;
      width: 100%;
      padding: 14px 24px;
      background: none;
      border: none;
      text-align: left;
      font-size: 1.05rem;
      color: var(--text);
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      letter-spacing: 0.3px;
      position: relative;
      overflow: hidden;
    }

    .nav-item:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }

    .nav-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: var(--accent);
      transform: scaleY(0);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .nav-item:hover {
      background: linear-gradient(90deg, rgba(175, 204, 142, 0.2) 0%, rgba(205, 244, 160, 0.1) 100%);
      color: var(--primary-dark);
      transform: translateX(4px);
    }

    .nav-item:hover::before {
      transform: scaleY(1);
    }

    .nav-item.active {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      font-weight: 800;
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .nav-item.active::before {
      background: var(--accent);
      transform: scaleY(1);
      width: 5px;
    }

    .sheet-link-section {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 0;
    }

    .sheet-link-section label,
    .sheet-link-section .sheet-link-label {
      font-size: 0.85rem;
      color: var(--primary-dark);
      margin-bottom: 4px;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .sheet-link-external-icon {
      width: 14px;
      height: 14px;
      opacity: 0.5;
      transition: opacity 0.2s;
      cursor: pointer;
      flex-shrink: 0;
    }

    .sheet-link-external-icon:hover {
      opacity: 0.8;
    }

    .nav-sheet-input {
      width: 100%;
      padding: 8px 10px;
      margin-bottom: 4px;
      border: 2px solid rgba(96, 108, 56, 0.3);
      border-radius: 6px;
      font-size: 0.85rem;
      background: rgba(255, 255, 255, 0.8);
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .nav-sheet-input:focus {
      outline: none;
      border-color: var(--primary);
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.2), 0 0 0 3px rgba(96, 108, 56, 0.1);
    }

    .nav-load-btn {
      padding: 8px 16px;
      margin-top: 12px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: var(--light-cream);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 8px rgba(188, 108, 37, 0.3), 0 2px 4px rgba(188, 108, 37, 0.2);
      letter-spacing: 0.5px;
    }

    .nav-load-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(188, 108, 37, 0.4), 0 4px 6px rgba(188, 108, 37, 0.3);
    }

    .nav-load-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(188, 108, 37, 0.3);
    }

    /* Help Link Button */
    .help-link-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(188, 108, 37, 0.5), 0 4px 6px rgba(188, 108, 37, 0.3);
    }

    .help-link-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(188, 108, 37, 0.3);
    }

    /* Full Screen Map */
    .map-container {
      position: absolute;
      top: 0; /* Will be adjusted dynamically by JavaScript */
      left: 240px;
      right: 420px; /* Leave space for floating panel */
      bottom: 0;
      z-index: 1;
      display: none; /* Hidden by default, shown only in map view */
    }

    #zoneMap {
      width: 100%;
      height: 100%;
    }

    .map-toggle-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 12px 16px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(254, 250, 224, 0.95) 100%);
      border: 2px solid var(--primary);
      border-radius: 10px;
      cursor: pointer;
      font-size: 1.1rem;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.3), 0 2px 4px rgba(40, 54, 24, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
    }

    .map-toggle-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, var(--light-cream) 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(40, 54, 24, 0.4), 0 4px 6px rgba(40, 54, 24, 0.3);
    }

    /* Persistent Filter Bar */
    .filter-bar {
      position: fixed;
      top: 56px; /* Default: below header, will be adjusted to 96px when alert is visible */
      left: 240px;
      right: 420px;
      background: linear-gradient(135deg, rgba(254, 250, 224, 0.98) 0%, rgba(255, 255, 255, 0.98) 100%);
      border-bottom: 2px solid var(--primary);
      z-index: 175;
      padding: 16px 32px;
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
      backdrop-filter: blur(10px);
      transition: top 0.3s ease;
    }

    .filter-bar-content {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    .filter-bar .filters-label {
      font-weight: 800;
      font-size: 1rem;
      color: var(--primary-dark);
      letter-spacing: 0.5px;
      margin-right: 4px;
    }

    .filter-bar select {
      padding: 10px 14px;
      border: 2px solid rgba(96, 108, 56, 0.3);
      border-radius: 8px;
      font-size: 0.9rem;
      background: rgba(255, 255, 255, 0.9);
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .filter-bar select:focus {
      outline: none;
      border-color: var(--primary);
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.2), 0 0 0 3px rgba(96, 108, 56, 0.1);
    }

    .filter-bar select.filter-active {
      border-color: var(--accent);
      background: rgba(221, 161, 94, 0.15);
      box-shadow: 0 2px 6px rgba(188, 108, 37, 0.2);
    }

    .filter-bar .contact-filter-group {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-left: 8px;
    }

    .filter-bar .contact-filter-checkbox {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      color: var(--primary-dark);
      user-select: none;
    }

    .filter-bar .contact-filter-checkbox input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: var(--primary);
    }

    .filter-bar .contact-filter-checkbox span {
      font-weight: 500;
    }

    .details-header {
      font-weight: 800;
      font-size: 1.1rem;
      color: var(--primary-dark);
      letter-spacing: 0.5px;
      padding: 12px 16px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* Floating Right Panel */
    .floating-panel {
      position: fixed;
      top: 56px;
      right: 0;
      width: 420px;
      bottom: 0;
      background: linear-gradient(180deg, var(--background) 0%, rgba(254, 250, 224, 0.98) 100%);
      box-shadow: -4px 0 16px rgba(40, 54, 24, 0.2), -2px 0 8px rgba(40, 54, 24, 0.15);
      z-index: 200;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      backdrop-filter: blur(10px);
      border-left: 3px solid var(--primary);
    }

    /* Content Views */
    .content-view {
      position: absolute;
      top: 0; /* Will be adjusted dynamically by JavaScript */
      left: 240px;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(254, 250, 224, 0.98) 0%, rgba(255, 255, 255, 0.98) 100%);
      z-index: 150;
      overflow-y: auto;
      padding: 32px;
      backdrop-filter: blur(10px);
    }

    .content-view.active {
      display: block;
    }

    /* Home Dashboard View */
    .home-dashboard {
      max-width: 1400px;
      margin: 0 auto;
    }

    .home-panels-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      margin-bottom: 16px;
    }

    .home-panel-wide {
      grid-column: 1 / -1;
    }

    .home-panel {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.15), 0 2px 4px rgba(40, 54, 24, 0.1);
      overflow: hidden;
      backdrop-filter: blur(10px);
      min-height: 300px;
    }

    .home-panel-header {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      padding: 16px 20px;
      border-bottom: 2px solid rgba(255, 255, 255, 0.2);
    }

    .home-panel-header h2 {
      margin: 0;
      font-size: 1.5rem;
      font-family: 'Alegreya', serif;
      font-weight: 800;
      letter-spacing: 0.5px;
    }

    .home-panel-content {
      padding: 20px 16px;
      color: var(--text);
    }

    /* Specific padding for Zone Overview panel */
    #zoneSnapshotContent {
      padding: 24px 20px 16px 20px;
    }
    
    /* Tighter spacing for From Altagether panel */
    #altagetherContent {
      padding: 8px !important;
    }

    /* From Altagether Panel - Brown/Tan Color Scheme */
    .altagether-panel .home-panel-header {
      background: linear-gradient(135deg, #BC6C25 0%, #8B4E1A 100%);
    }

    .altagether-panel .announcement-item {
      background: rgba(188, 108, 37, 0.08);
      border-left: 3px solid #BC6C25;
    }

    .altagether-panel .announcement-link {
      color: #A65A20;
    }

    .altagether-panel .announcement-link:hover {
      color: #8B4E1A;
    }

    .altagether-panel .announcement-title {
      color: #6B3D15;
    }

    .home-panel-map {
      min-height: 300px;
      display: flex;
      flex-direction: column;
    }

    .home-panel-map .home-panel-content {
      flex: 1;
      padding: 0;
      display: flex;
      flex-direction: column;
    }

    .home-map-container {
      padding: 0;
      flex: 1;
      min-height: 300px;
      position: relative;
      overflow: hidden;
    }

    .home-map-container #homeMap {
      width: 100%;
      height: 100%;
      border-radius: 0 0 12px 12px;
    }

    .stat-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      margin: 0 -4px;
      border-bottom: 1px solid rgba(96, 108, 56, 0.12);
      transition: background-color 0.2s ease;
      border-radius: 6px;
    }

    .stat-item:hover {
      background-color: rgba(254, 250, 224, 0.3);
    }

    .stat-item:last-child {
      border-bottom: none;
    }

    .stat-label {
      font-size: 1.05rem;
      color: var(--text);
      font-weight: 500;
      letter-spacing: 0.3px;
      line-height: 1.4;
    }

    .stat-value {
      font-size: 1.75rem;
      font-weight: 800;
      color: var(--primary-dark);
      font-family: 'Alegreya', serif;
      letter-spacing: -0.5px;
    }

    .stat-group {
      margin-bottom: 8px;
    }

    .stat-group-title {
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--primary-dark);
      margin-bottom: 12px;
      font-family: 'Alegreya', serif;
    }

    .damage-stat-item, .rebuild-stat-item {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid rgba(96, 108, 56, 0.1);
    }

    .damage-stat-item:last-child, .rebuild-stat-item:last-child {
      border-bottom: none;
    }

    .damage-stat-label, .rebuild-stat-label {
      color: var(--text);
    }

    .damage-stat-count, .rebuild-stat-count {
      font-weight: 700;
      color: var(--primary);
    }

    .announcement-item {
      padding: 10px 12px;
      margin-bottom: 6px;
      background: rgba(175, 204, 142, 0.1);
      border-radius: 4px;
      border-left: 3px solid var(--primary);
    }

    .announcement-title {
      font-weight: 800;
      font-size: 1rem;
      color: var(--primary-dark);
      margin-bottom: 4px;
      font-family: 'Alegreya', serif;
    }

    .announcement-description {
      color: var(--text);
      line-height: 1.4;
      margin-bottom: 4px;
      font-size: 0.9rem;
    }

    .announcement-link {
      color: var(--primary);
      text-decoration: none;
      font-weight: 600;
    }

    .announcement-link:hover {
      text-decoration: underline;
    }

    /* Quick Actions Panel Styles */
    .quick-action-item {
      padding: 14px 16px;
      margin-bottom: 10px;
      background: rgba(221, 161, 94, 0.1);
      border-radius: 6px;
      border-left: 4px solid var(--accent);
    }

    .quick-action-text {
      color: var(--text);
      line-height: 1.5;
      margin-bottom: 8px;
      font-size: 0.95rem;
    }

    .quick-action-links {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .quick-action-link {
      color: var(--primary);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.9rem;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .quick-action-link:hover {
      background: rgba(96, 108, 56, 0.1);
      text-decoration: underline;
    }

    /* Actions Page Styles */
    .actions-page-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 24px;
      margin-top: 24px;
    }

    .action-card {
      padding: 20px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      border-left: 4px solid var(--accent);
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
      transition: all 0.3s ease;
    }

    .action-card:hover {
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.15);
      transform: translateY(-2px);
    }

    .action-card-title {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--primary-dark);
      margin-bottom: 12px;
      font-family: 'Alegreya', serif;
    }

    .action-card-content {
      color: var(--text);
      line-height: 1.6;
      margin-bottom: 16px;
      font-size: 0.95rem;
    }

    .action-card-links {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    .action-card-link {
      color: var(--primary);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.9rem;
      padding: 6px 12px;
      border-radius: 4px;
      transition: all 0.2s ease;
      border: 2px solid transparent;
    }

    .action-card-link:hover {
      background: rgba(96, 108, 56, 0.1);
      border-color: var(--primary);
      text-decoration: underline;
    }

    .action-card-people-list {
      margin-top: 12px;
      font-size: 0.9rem;
      line-height: 1.8;
    }

    /* Newsletter Email Modal */
    .newsletter-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .newsletter-modal {
      background: white;
      border-radius: 12px;
      padding: 32px;
      max-width: 700px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    .newsletter-modal-header {
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 2px solid var(--primary);
    }

    .newsletter-modal-title {
      font-size: 1.8rem;
      font-weight: 800;
      color: var(--primary-dark);
      font-family: 'Alegreya', serif;
      margin: 0 0 8px 0;
    }

    .newsletter-modal-subtitle {
      font-size: 1rem;
      color: var(--text-light);
      margin: 0;
    }

    .newsletter-modal-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-light);
      padding: 8px;
      line-height: 1;
      transition: color 0.2s;
    }

    .newsletter-modal-close:hover {
      color: var(--primary-dark);
    }

    .newsletter-modal-content {
      margin-bottom: 24px;
    }

    .newsletter-modal-section {
      margin-bottom: 24px;
    }

    .newsletter-modal-section-title {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--primary-dark);
      margin: 0 0 12px 0;
      font-family: 'Alegreya', serif;
    }

    .newsletter-modal-instructions {
      background: rgba(96, 108, 56, 0.05);
      border-left: 4px solid var(--primary);
      padding: 16px;
      border-radius: 6px;
      margin-bottom: 16px;
    }

    .newsletter-modal-instructions ol {
      margin: 0;
      padding-left: 20px;
    }

    .newsletter-modal-instructions li {
      margin-bottom: 8px;
      line-height: 1.6;
    }

    .newsletter-email-list {
      background: #f9f9f9;
      border: 1px solid var(--border-soft);
      border-radius: 6px;
      padding: 16px;
      max-height: 300px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.9rem;
      line-height: 1.8;
      word-break: break-all;
    }

    .newsletter-email-count {
      font-weight: 600;
      color: var(--primary-dark);
      margin-bottom: 12px;
    }

    .newsletter-modal-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 24px;
      padding-top: 24px;
      border-top: 1px solid var(--border-soft);
    }

    .btn-copy-emails {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-copy-emails:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(96, 108, 56, 0.3);
    }

    .btn-newsletter-link {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      display: inline-block;
      transition: all 0.2s;
    }

    .btn-newsletter-link:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(188, 108, 37, 0.3);
    }

    /* Addresses & People view - leave space for floating panel */
    .content-view#peopleView {
      right: 420px; /* Leave space for the floating panel */
      top: 0; /* Will be adjusted dynamically by JavaScript */
    }

    /* People View Header */
    .people-view-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 2px solid var(--primary);
      flex-wrap: wrap;
      gap: 16px;
    }

    .people-view-actions {
      display: flex;
      gap: 12px;
    }

    .btn-print-export {
      padding: 10px 20px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(188, 108, 37, 0.3);
      font-family: 'Alegreya', serif;
    }

    .btn-print-export:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(188, 108, 37, 0.4);
    }

    /* Address Table View */
    .address-table-container {
      width: 100%;
      max-height: calc(100vh - 260px); /* Leave space for header, filters, and padding */
      overflow-x: auto;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .address-table {
      width: auto;
      min-width: 100%;
      border-collapse: collapse;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.15), 0 2px 4px rgba(40, 54, 24, 0.1);
      border-radius: 12px;
      overflow: visible;
      backdrop-filter: blur(10px);
    }

    .address-table thead {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .address-table th {
      padding: 16px;
      text-align: left;
      font-weight: 800;
      font-size: 0.95rem;
      letter-spacing: 0.5px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .address-table th:nth-child(1),
    .address-table td:nth-child(1) {
      width: auto;
      min-width: 120px; /* Minimum width to prevent it from getting too narrow */
      white-space: nowrap; /* Keep addresses on one line */
    }

    .address-table th:nth-child(2),
    .address-table td:nth-child(2) {
      width: 25%;
      max-width: 300px;
    }

    .address-table td:nth-child(2) {
      overflow: hidden;
      white-space: nowrap;
    }

    .address-table td {
      padding: 14px 16px;
      border-bottom: 1px solid rgba(96, 108, 56, 0.15);
      transition: all 0.2s ease;
    }

    .address-table tbody tr {
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .address-table tbody tr:hover {
      background: linear-gradient(90deg, rgba(175, 204, 142, 0.2) 0%, rgba(205, 244, 160, 0.15) 100%);
      box-shadow: inset 4px 0 0 var(--accent);
    }

    .address-table tbody tr.selected {
      background: linear-gradient(90deg, rgba(175, 204, 142, 0.3) 0%, rgba(205, 244, 160, 0.2) 100%);
      box-shadow: inset 4px 0 0 var(--primary);
    }

    .table-filters {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    .filters-label {
      font-weight: 800;
      font-size: 1rem;
      color: var(--primary-dark);
      letter-spacing: 0.5px;
      margin-right: 4px;
    }

    .contact-filter-group {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-left: 8px;
    }

    .contact-filter-checkbox {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      color: var(--primary-dark);
      user-select: none;
    }

    .contact-filter-checkbox input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: var(--primary);
    }

    .contact-filter-checkbox span {
      font-weight: 500;
    }

    .table-filters select {
      padding: 10px 14px;
      border: 2px solid rgba(96, 108, 56, 0.3);
      border-radius: 8px;
      font-size: 0.9rem;
      background: rgba(255, 255, 255, 0.9);
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .table-filters select:focus {
      outline: none;
      border-color: var(--primary);
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.2), 0 0 0 3px rgba(96, 108, 56, 0.1);
    }

    .map-kml-input {
      margin: 0 8px 8px 8px;
      padding: 6px 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.85rem;
      width: calc(100% - 32px);
    }

    .map-toggle-btn {
      margin-left: auto;
      padding: 4px 8px;
      background: rgba(255,255,255,0.8);
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s;
    }

    .map-toggle-btn:hover {
      background: rgba(255,255,255,1);
    }


    /* Zone Overview panel */
    .zone-progress-panel {
      width: 100%;
      margin-top: 16px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }

    .zone-progress-panel h3 {
      margin: 0 0 24px 0;
      color: var(--primary-dark);
      font-size: 1.4rem;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 12px;
      letter-spacing: 0.5px;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }

    .chart-container {
      position: relative;
      height: 300px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(254, 250, 224, 0.9) 100%);
      border-radius: 8px;
      padding: 16px;
      padding-bottom: 40px;
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.15), 0 2px 4px rgba(40, 54, 24, 0.1);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(96, 108, 56, 0.2);
      transition: all 0.3s ease;
    }

    .chart-container:hover {
      transform: translateY(-4px);
      box-shadow: 0 6px 16px rgba(40, 54, 24, 0.2), 0 4px 6px rgba(40, 54, 24, 0.15);
    }

    .chart-title {
      font-size: 1rem;
      font-weight: 800;
      color: var(--primary-dark);
      margin-bottom: 16px;
      text-align: center;
      letter-spacing: 0.5px;
    }

    .zone-overview-charts {
      display: flex;
      gap: 20px;
      padding: 24px 20px;
      border-top: 2px solid rgba(96, 108, 56, 0.15);
      margin-top: 8px;
      background: linear-gradient(to bottom, rgba(254, 250, 224, 0.2), rgba(254, 250, 224, 0.05));
    }

    /* Chart Carousel Styles */
    .chart-carousel-wrapper {
      flex: 1;
      min-width: 0;
      position: relative;
    }

    .chart-carousel-container {
      position: relative;
      width: 100%;
    }

    .chart-carousel-track {
      position: relative;
      width: 100%;
      overflow: hidden;
      border-radius: 10px;
    }

    .chart-container-small {
      position: relative;
      width: 100%;
      height: 240px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(254, 250, 224, 0.95) 100%);
      border-radius: 10px;
      padding: 18px 16px;
      padding-bottom: 50px;
      box-shadow: 0 3px 12px rgba(40, 54, 24, 0.12), 0 1px 3px rgba(40, 54, 24, 0.08);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(96, 108, 56, 0.2);
      transition: all 0.3s ease;
    }

    .chart-carousel-slide {
      display: none;
      opacity: 0;
      transition: opacity 0.4s ease-in-out;
    }

    .chart-carousel-slide.active {
      display: block;
      opacity: 1;
    }

    .chart-carousel-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      width: auto;
      height: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      transition: all 0.2s ease;
      padding: 8px;
    }

    .chart-carousel-arrow-symbol {
      font-size: 2rem;
      font-weight: 900;
      color: var(--primary-dark);
      line-height: 1;
      user-select: none;
      transition: all 0.2s ease;
    }

    .chart-carousel-arrow:hover .chart-carousel-arrow-symbol {
      color: var(--primary);
      transform: scale(1.2);
    }

    .chart-carousel-arrow-left {
      left: 8px;
    }

    .chart-carousel-arrow-right {
      right: 8px;
    }

    .chart-carousel-dots {
      display: flex;
      justify-content: center;
      gap: 6px;
      margin-top: 12px;
      padding: 0 8px;
    }

    .chart-carousel-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(96, 108, 56, 0.3);
      cursor: pointer;
      transition: all 0.2s ease;
      border: none;
      padding: 0;
    }

    .chart-carousel-dot:hover {
      background: rgba(96, 108, 56, 0.5);
      transform: scale(1.2);
    }

    .chart-carousel-dot.active {
      background: var(--primary);
      width: 20px;
      border-radius: 3px;
    }


    .chart-container-small .chart-title {
      font-size: 0.95rem;
      margin-bottom: 12px;
      font-weight: 700;
      letter-spacing: 0.3px;
      color: var(--primary-dark);
    }
    
    .chart-container-small canvas {
      max-height: 150px !important;
    }

    .zone-overview-footer {
      padding: 16px 20px;
      border-top: 2px solid rgba(96, 108, 56, 0.12);
      margin-top: 0;
      background: rgba(254, 250, 224, 0.15);
    }

    .zone-overview-footer .stat-item {
      padding: 8px 0;
      margin: 0;
      border-bottom: none;
    }

    .zone-overview-footer .stat-item:hover {
      background-color: transparent;
    }

    .zone-overview-footer .stat-label {
      font-size: 0.9rem;
      color: rgba(40, 54, 24, 0.7);
      font-weight: 500;
    }

    .zone-overview-footer .stat-value {
      font-size: 0.95rem;
      font-weight: 600;
      color: rgba(40, 54, 24, 0.8);
      font-family: inherit;
    }

    .zone-notes-card {
      background: #ffffff;
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.06);
      margin-bottom: 16px;
    }

    .zone-notes-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
    }

    .zone-notes-text {
      width: 100%;
      flex: 1;
      min-height: 300px;
      padding: 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.9rem;
      font-family: inherit;
      resize: vertical;
      box-sizing: border-box;
    }

    .btn-save-small {
      padding: 8px 16px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: var(--light-cream);
      border: 0;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 800;
      margin-left: auto;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 6px rgba(188, 108, 37, 0.3);
      letter-spacing: 0.3px;
    }

    .btn-save-small:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(188, 108, 37, 0.4);
    }

    .save-status-small {
      margin-top: 4px;
      font-size: 0.8rem;
      min-height: 16px;
    }

    .save-status-small.saved {
      color: #214025;
    }

    .save-status-small.error {
      color: var(--brown);
      font-weight: 600;
    }

    /* Floating Address Panel */
    .address-panel {
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .address-panel .card-header {
      padding: 0;
      margin: 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .address-panel-tabs {
      display: flex;
      gap: 0;
      margin: 0;
      padding: 0;
      position: relative;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      align-items: stretch;
      border-bottom: 3px solid var(--primary);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.8) 0%, rgba(254, 250, 224, 0.6) 100%);
      flex-shrink: 0;
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
      overflow: hidden;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }

    .tab-btn {
      padding: 14px 20px;
      background: transparent;
      border: none;
      border-bottom: 4px solid transparent;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 800;
      color: var(--text-light);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      white-space: nowrap;
      flex-shrink: 1;
      flex-grow: 0;
      letter-spacing: 0.3px;
      min-width: 0;
    }

    .tab-btn:hover {
      color: var(--primary-dark);
      background: linear-gradient(180deg, rgba(175, 204, 142, 0.2) 0%, rgba(205, 244, 160, 0.1) 100%);
    }

    .tab-btn.active {
      color: var(--primary-dark);
      border-bottom-color: var(--accent);
      background: transparent;
      font-weight: 800;
    }

    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -3px;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent) 0%, var(--accent-dark) 100%);
      box-shadow: 0 2px 4px rgba(188, 108, 37, 0.3);
    }

    .btn-contact-mode {
      padding: 8px 12px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(254, 250, 224, 0.95) 100%);
      border: 2px solid var(--primary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 800;
      color: var(--primary-dark);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 4px rgba(96, 108, 56, 0.2);
      letter-spacing: 0.3px;
      white-space: nowrap;
      flex-shrink: 0;
      margin: 0;
      box-sizing: border-box;
    }

    .btn-contact-mode:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, var(--light-cream) 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.3);
    }

    .btn-contact-mode.active {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      border-color: var(--primary-dark);
      box-shadow: 0 4px 12px rgba(96, 108, 56, 0.4);
    }

    .contact-mode-indicator {
      display: inline-block;
      padding: 2px 8px;
      background: rgba(255, 200, 0, 0.2);
      border: 1px solid rgba(255, 200, 0, 0.5);
      border-radius: 4px;
      font-size: 0.75rem;
      color: #856404;
      margin-left: 8px;
    }

    .contact-button {
      padding: 6px 12px;
      background: var(--primary);
      border: 1px solid var(--primary-dark);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--light-cream);
      transition: all 0.2s;
      margin-top: 8px;
    }

    .contact-button:hover {
      background: var(--primary-dark);
    }

    .contact-button.contacted {
      background: var(--accent);
      color: var(--light-cream);
      border-color: var(--accent-dark);
    }

    .contact-button.contacted:hover {
      background: var(--accent-dark);
    }

    .contact-date {
      font-size: 0.8rem;
      color: #666;
      margin-top: 4px;
      font-style: italic;
    }

    .contact-notes-quick {
      width: 100%;
      margin-top: 8px;
      padding: 6px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 4px;
      font-size: 0.85rem;
      font-family: inherit;
      resize: vertical;
      min-height: 60px;
    }

    .person-entry.no-contact {
      border-left-color: #ff9800;
      background: rgba(255, 152, 0, 0.05);
    }

    .person-entry.recent-contact {
      border-left-color: #4caf50;
    }

    .zone-notes-content {
      padding: 12px;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .zone-notes-text {
      width: 100%;
      flex: 1;
      min-height: 300px;
      padding: 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.9rem;
      font-family: inherit;
      resize: vertical;
      box-sizing: border-box;
    }

    .address-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      padding-right: 16px;
    }

    .address-filters {
      margin-bottom: 12px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .address-filters select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      font-size: 0.9rem;
      background: white;
      cursor: pointer;
    }

    .address-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .address-item {
      padding: 8px 10px;
      margin-bottom: 6px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
    }

    .address-item:hover {
      background: rgba(255, 255, 255, 0.9);
      border-color: var(--river);
      transform: translateX(2px);
    }

    .address-item.active {
      background: var(--river);
      color: white;
      border-color: var(--river);
    }

    .address-details {
      display: none;
    }

    .address-details.active {
      display: block;
    }

    .address-details h3 {
      margin: 0 0 12px 0;
      font-size: 1.1rem;
      color: var(--river);
      border-bottom: 2px solid var(--river);
      padding-bottom: 6px;
    }

    .person-entry {
      background: rgba(255, 255, 255, 0.7);
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 6px;
      border-left: 3px solid var(--mint);
    }

    .person-name {
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--plum);
    }

    .person-info {
      font-size: 0.9rem;
      color: #143039;
      margin: 4px 0;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .person-info strong {
      color: var(--river);
    }
    
    .copy-email-btn {
      color: var(--primary);
      margin-left: 4px;
    }
    
    .copy-email-btn:hover {
      opacity: 1 !important;
      color: var(--accent);
    }
    
    .copy-email-btn svg {
      display: block;
    }

    .person-info-inline {
      display: flex;
      gap: 24px;
      margin: 4px 0;
      flex-wrap: wrap;
    }

    .person-info-inline .person-info-item {
      font-size: 0.9rem;
      color: #143039;
      flex: 1;
      min-width: 150px;
    }

    .person-info-inline .person-info-item strong {
      color: var(--river);
    }

    .loading, .error, .empty {
      padding: 20px;
      text-align: center;
      color: rgba(0, 0, 0, 0.6);
    }

    .error {
      color: var(--brown);
      font-weight: 600;
    }

    .btn-refresh {
      padding: 8px 10px;
      background: linear-gradient(135deg, var(--light-green) 0%, var(--lighter-green) 100%);
      color: var(--primary-dark);
      border: 2px solid var(--primary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.1rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 4px rgba(96, 108, 56, 0.2);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      flex-shrink: 0;
      margin: 0;
    }

    .btn-refresh:hover {
      transform: rotate(90deg) translateY(-2px);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.3);
    }

    .btn-refresh.active {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: var(--light-cream);
      border-color: var(--accent-dark);
    }

    .btn-back {
      padding: 10px 20px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      border: 0;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 800;
      margin: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 8px rgba(40, 54, 24, 0.3);
      letter-spacing: 0.3px;
      align-self: center;
    }

    .btn-back:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(40, 54, 24, 0.4);
    }

    .btn-signin {
      padding: 12px 24px;
      background: linear-gradient(135deg, #4285f4 0%, #357ae8 100%);
      color: white;
      border: 0;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 800;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      margin: 12px 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 12px rgba(66, 133, 244, 0.4);
      letter-spacing: 0.3px;
    }

    .btn-signin:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(66, 133, 244, 0.5);
    }

    /* Contact List Creator Styles */
    /* Tools Grid Layout */
    .tools-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 24px;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .tool-module {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 4px 16px rgba(40, 54, 24, 0.1);
      border: 2px solid var(--primary);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      position: relative;
      overflow: hidden;
      order: 0; /* Default order */
    }

    .tool-module:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(40, 54, 24, 0.15);
      border-color: var(--primary-dark);
    }

    .tool-module.expanded {
      grid-column: 1 / -1;
      padding: 32px;
      cursor: default;
      order: -1; /* Move to top of grid */
    }

    .tool-module-header {
      transition: all 0.2s ease;
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .tool-module:not(.expanded) .tool-module-header {
      margin-bottom: 0;
      padding-bottom: 0;
    }

    .tool-module.expanded .tool-module-header {
      margin-bottom: 32px;
      padding-bottom: 24px;
      border-bottom: 2px solid var(--primary);
      cursor: pointer;
    }

    .tool-module-header h3 {
      color: var(--primary-dark);
      font-size: 1.5rem;
      margin: 0 0 8px 0;
      font-family: 'Alegreya', serif;
      font-weight: 800;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .tool-module.expanded .tool-module-header h3 {
      font-size: 1.8rem;
    }

    .tool-module-header p {
      color: var(--text-light);
      font-size: 0.95rem;
      margin: 0;
      line-height: 1.5;
    }

    .tool-module-toggle {
      font-size: 0.9rem;
      color: var(--primary);
      transition: transform 0.3s ease;
      user-select: none;
      margin-left: 12px;
    }

    .tool-module:not(.expanded) .tool-module-toggle {
      display: none;
    }

    .tool-module.collapsed .tool-module-toggle {
      transform: rotate(-90deg);
    }

    .tool-module-content {
      transition: all 0.3s ease;
      overflow: hidden;
      max-height: 0;
      opacity: 0;
    }

    .tool-module.expanded .tool-module-content {
      max-height: 10000px;
      opacity: 1;
    }

    .tool-module.collapsed .tool-module-content {
      max-height: 0;
      opacity: 0;
    }

    .tool-module:not(.expanded) .tool-module-content {
      display: none;
    }

    .tool-module-header p {
      color: var(--text-light);
      font-size: 1rem;
      margin: 0;
      line-height: 1.5;
    }

    .list-creator-step {
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .list-creator-step h4 {
      color: var(--primary-dark);
      font-size: 1.4rem;
      margin: 0 0 24px 0;
      font-family: 'Alegreya', serif;
      font-weight: 800;
    }

    .list-type-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }

    .list-type-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 3px solid var(--primary);
      border-radius: 12px;
      padding: 24px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
    }

    .list-type-btn:hover {
      transform: translateY(-4px);
      box-shadow: 0 6px 20px rgba(40, 54, 24, 0.2);
      border-color: var(--primary-dark);
      background: rgba(255, 255, 255, 1);
    }

    .list-type-icon {
      font-size: 3rem;
      margin-bottom: 12px;
    }

    .list-type-label {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--primary-dark);
      margin-bottom: 8px;
      font-family: 'Alegreya', serif;
    }

    .list-type-desc {
      font-size: 0.9rem;
      color: var(--text-light);
      line-height: 1.4;
    }

    .list-source-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }

    .list-source-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 3px solid var(--accent);
      border-radius: 12px;
      padding: 24px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
    }

    .list-source-btn:hover {
      transform: translateY(-4px);
      box-shadow: 0 6px 20px rgba(40, 54, 24, 0.2);
      border-color: var(--accent-dark);
      background: rgba(255, 255, 255, 1);
    }

    .list-source-icon, .canned-list-icon {
      font-size: 2.5rem;
      margin-bottom: 12px;
    }

    .list-source-label, .canned-list-label {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--primary-dark);
      margin-bottom: 8px;
      font-family: 'Alegreya', serif;
    }

    .list-source-desc, .canned-list-desc {
      font-size: 0.9rem;
      color: var(--text-light);
      line-height: 1.4;
    }

    .canned-list-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }

    .canned-list-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 3px solid var(--highlight);
      border-radius: 12px;
      padding: 24px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
    }

    .canned-list-btn:hover {
      transform: translateY(-4px);
      box-shadow: 0 6px 20px rgba(40, 54, 24, 0.2);
      border-color: var(--primary);
      background: rgba(255, 255, 255, 1);
    }

    .custom-builder-content {
      background: rgba(255, 255, 255, 0.6);
      border-radius: 8px;
      padding: 24px;
      margin-bottom: 24px;
    }

    .builder-filters {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }

    .builder-filter-group {
      display: flex;
      flex-direction: column;
    }

    .builder-filter-group label {
      font-weight: 600;
      color: var(--primary-dark);
      margin-bottom: 8px;
      font-size: 0.95rem;
    }

    .builder-filter-group select {
      padding: 10px 12px;
      border: 2px solid var(--primary);
      border-radius: 6px;
      font-size: 0.95rem;
      background: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .builder-filter-group select:focus {
      outline: none;
      border-color: var(--primary-dark);
      box-shadow: 0 0 0 3px rgba(96, 108, 56, 0.1);
    }

    .builder-filter-group select[multiple] {
      min-height: 120px;
      padding: 8px;
    }

    .builder-filter-group small {
      margin-top: 4px;
      color: var(--text-light);
      font-size: 0.8rem;
    }

    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.8);
      border: 2px solid var(--primary);
      border-radius: 6px;
      max-height: 200px;
      overflow-y: auto;
    }

    .checkbox-option {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 4px 6px;
      border-radius: 4px;
      transition: background 0.2s ease;
      font-size: 0.95rem;
    }

    .checkbox-option.all-option {
      font-weight: 600;
      color: var(--primary-dark);
      border-bottom: 1px solid rgba(40, 54, 24, 0.2);
      padding-bottom: 6px;
      margin-bottom: 4px;
    }

    .checkbox-option:hover {
      background: rgba(96, 108, 56, 0.1);
    }

    .checkbox-option input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: var(--primary);
      flex-shrink: 0;
    }

    .checkbox-option span {
      flex: 1;
      user-select: none;
    }

    .builder-actions {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .btn-generate {
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'Alegreya', serif;
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.2);
    }

    .btn-generate:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.3);
    }

    .list-results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 16px;
    }

    .list-results-header h4 {
      margin: 0;
      color: var(--primary-dark);
      font-size: 1.6rem;
      font-family: 'Alegreya', serif;
    }

    .list-results-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .btn-export, .btn-print {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.2);
    }

    .btn-export:hover, .btn-print:hover {
      background: var(--accent-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.3);
    }

    .list-results-info {
      margin-bottom: 16px;
      padding: 12px;
      background: rgba(96, 108, 56, 0.1);
      border-radius: 6px;
      font-weight: 600;
      color: var(--primary-dark);
    }

    .list-results-content {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      padding: 24px;
      max-height: 600px;
      overflow-y: auto;
      border: 2px solid var(--primary);
    }

    .contact-list-item {
      padding: 16px;
      margin-bottom: 12px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      border-left: 4px solid var(--primary);
      box-shadow: 0 2px 4px rgba(40, 54, 24, 0.1);
      transition: all 0.2s ease;
    }

    .contact-list-item:hover {
      box-shadow: 0 4px 8px rgba(40, 54, 24, 0.15);
      transform: translateX(4px);
    }

    /* Grouped by address styles */
    .contact-list-address-group {
      margin-bottom: 24px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 12px;
      border: 2px solid var(--primary);
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
      overflow: hidden;
      transition: all 0.2s ease;
    }

    .contact-list-address-group:hover {
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.15);
    }

    .contact-list-address-header {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      padding: 16px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
    }

    .contact-list-address-title {
      font-size: 1.3rem;
      font-weight: 700;
      font-family: 'Alegreya', serif;
      letter-spacing: 0.3px;
      flex: 1;
      min-width: 200px;
    }

    .contact-list-address-count {
      font-size: 0.9rem;
      font-weight: 600;
      background: rgba(255, 255, 255, 0.2);
      padding: 6px 12px;
      border-radius: 20px;
      backdrop-filter: blur(5px);
    }

    .contact-list-people {
      padding: 16px 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .contact-list-person {
      padding: 16px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 8px;
      border-left: 3px solid var(--accent);
      transition: all 0.2s ease;
    }

    .contact-list-person:hover {
      background: rgba(255, 255, 255, 0.9);
      transform: translateX(4px);
      box-shadow: 0 2px 6px rgba(40, 54, 24, 0.1);
    }

    .contact-list-person-name {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--primary-dark);
      font-family: 'Alegreya', serif;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(40, 54, 24, 0.1);
    }

    .contact-list-item-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
      flex-wrap: wrap;
      gap: 12px;
    }

    .contact-list-item-name {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--primary-dark);
      font-family: 'Alegreya', serif;
    }

    .contact-list-item-address {
      font-size: 1rem;
      color: var(--text);
      font-weight: 500;
    }

    .contact-list-item-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    .contact-list-detail-item {
      display: flex;
      flex-direction: column;
    }

    .contact-list-detail-label {
      font-size: 0.85rem;
      color: var(--text-light);
      font-weight: 600;
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .contact-list-detail-value {
      font-size: 0.95rem;
      color: var(--text);
      word-break: break-word;
    }

    .contact-list-item-notes {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(40, 54, 24, 0.1);
    }

    .contact-list-notes-label {
      font-size: 0.85rem;
      color: var(--text-light);
      font-weight: 600;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .contact-list-notes-value {
      font-size: 0.95rem;
      color: var(--text);
      line-height: 1.5;
      font-style: italic;
    }

    .contact-list-empty {
      text-align: center;
      padding: 48px;
      color: var(--text-light);
      font-size: 1.1rem;
    }

    /* Wizard Interface Styles */
    .list-creator-wizard {
      animation: fadeIn 0.3s ease;
    }

    .wizard-section {
      margin-bottom: 32px;
      padding-bottom: 32px;
      border-bottom: 2px solid rgba(96, 108, 56, 0.2);
    }

    .wizard-section:last-of-type {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }

    .wizard-section-title {
      color: var(--primary-dark);
      font-size: 1.5rem;
      margin: 0 0 8px 0;
      font-family: 'Alegreya', serif;
      font-weight: 800;
    }

    .wizard-section-desc {
      color: var(--text-light);
      font-size: 0.95rem;
      margin: 0 0 24px 0;
      line-height: 1.5;
    }

    /* Quick Start Options */
    .quick-start-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }

    .quick-start-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 3px solid var(--accent);
      border-radius: 12px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
    }

    .quick-start-btn:hover {
      transform: translateY(-4px);
      box-shadow: 0 6px 20px rgba(40, 54, 24, 0.2);
      border-color: var(--accent-dark);
      background: rgba(255, 255, 255, 1);
    }

    .quick-start-icon {
      font-size: 2.5rem;
      margin-bottom: 12px;
    }

    .quick-start-label {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--primary-dark);
      margin-bottom: 6px;
      font-family: 'Alegreya', serif;
    }

    .quick-start-desc {
      font-size: 0.9rem;
      color: var(--text-light);
      line-height: 1.4;
    }

    /* Wizard Questions */
    .wizard-question {
      margin-bottom: 32px;
    }

    .wizard-question-label {
      display: block;
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--primary-dark);
      margin-bottom: 8px;
      font-family: 'Alegreya', serif;
    }

    .wizard-question-help {
      color: var(--text-light);
      font-size: 0.9rem;
      margin: 0 0 16px 0;
      font-style: italic;
    }

    .wizard-radio-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }

    .wizard-radio-option {
      position: relative;
      cursor: pointer;
    }

    .wizard-radio-option input[type="radio"] {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }

    .radio-content {
      background: rgba(255, 255, 255, 0.9);
      border: 3px solid var(--primary);
      border-radius: 12px;
      padding: 20px;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
    }

    .wizard-radio-option:hover .radio-content {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.15);
      border-color: var(--primary-dark);
    }

    .wizard-radio-option input[type="radio"]:checked + .radio-content {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      border-color: var(--primary-dark);
      box-shadow: 0 4px 16px rgba(40, 54, 24, 0.3);
    }

    .wizard-radio-option input[type="radio"]:checked + .radio-content .radio-icon,
    .wizard-radio-option input[type="radio"]:checked + .radio-content .radio-label,
    .wizard-radio-option input[type="radio"]:checked + .radio-content .radio-desc {
      color: var(--light-cream);
    }

    .radio-icon {
      font-size: 2.5rem;
      margin-bottom: 12px;
    }

    .radio-label {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--primary-dark);
      margin-bottom: 6px;
      font-family: 'Alegreya', serif;
    }

    .radio-desc {
      font-size: 0.9rem;
      color: var(--text-light);
      line-height: 1.4;
    }

    /* Custom Filters Section */
    .wizard-custom-filters {
      margin-top: 24px;
      padding: 24px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 8px;
      border: 2px solid var(--primary);
    }

    .custom-filters-header {
      margin-bottom: 20px;
    }

    .custom-filters-header h5 {
      color: var(--primary-dark);
      font-size: 1.2rem;
      margin: 0 0 8px 0;
      font-family: 'Alegreya', serif;
      font-weight: 800;
    }

    .custom-filters-header p {
      color: var(--text-light);
      font-size: 0.9rem;
      margin: 0;
    }

    /* Summary Section */
    .wizard-summary {
      margin-top: 24px;
      padding: 20px;
      background: linear-gradient(135deg, rgba(96, 108, 56, 0.1) 0%, rgba(175, 204, 142, 0.1) 100%);
      border-radius: 8px;
      border: 2px solid var(--primary);
    }

    .summary-content h5 {
      color: var(--primary-dark);
      font-size: 1.2rem;
      margin: 0 0 16px 0;
      font-family: 'Alegreya', serif;
      font-weight: 800;
    }

    .summary-details {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .summary-item {
      display: flex;
      gap: 8px;
      font-size: 0.95rem;
      color: var(--text);
    }

    .summary-item strong {
      color: var(--primary-dark);
      font-weight: 700;
      min-width: 80px;
    }

    /* Wizard Actions */
    .wizard-actions {
      margin-top: 32px;
      text-align: center;
    }

    .btn-generate-large {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 16px 32px;
      font-size: 1.2rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Alegreya', serif;
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.3);
      display: inline-flex;
      align-items: center;
      gap: 12px;
    }

    .btn-generate-large:hover:not(:disabled) {
      transform: translateY(-3px);
      box-shadow: 0 6px 16px rgba(40, 54, 24, 0.4);
    }

    .btn-generate-large:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn-icon {
      font-size: 1.3rem;
    }

    .wizard-help-text {
      margin-top: 12px;
      color: var(--text-light);
      font-size: 0.9rem;
      font-style: italic;
    }

    /* Zone Report Generator Styles */
    .zone-report-controls {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }

    .btn-generate-report {
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 14px 28px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'Alegreya', serif;
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.2);
    }

    .btn-generate-report:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.3);
    }

    .zone-report-status {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .zone-report-status.loading {
      background: rgba(96, 108, 56, 0.1);
      color: var(--primary-dark);
    }

    .zone-report-status.error {
      background: rgba(211, 47, 47, 0.1);
      color: #d32f2f;
    }

    .zone-report-container {
      margin-top: 32px;
    }

    .zone-report-content {
      background: white;
      border-radius: 8px;
      padding: 40px;
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
      max-width: 100%;
      overflow-x: auto;
      overflow-y: visible;
      max-height: none;
    }

    /* Print-friendly styles */
    @media print {
      .zone-report-content {
        box-shadow: none;
        padding: 20px;
      }
      
      .zone-report-actions {
        display: none;
      }
      
      .zone-report-section {
        page-break-inside: avoid;
        margin-bottom: 24px;
      }
      
      .zone-report-section:not(:first-child) {
        page-break-before: always;
      }
      
      .zone-report-section-title {
        page-break-after: avoid;
        page-break-before: always;
      }
      
      .zone-report-table {
        page-break-inside: avoid;
      }
      
      /* Reduce chart sizes in PDF */
      .zone-report-content canvas {
        max-height: 200px !important;
        max-width: 100% !important;
      }
      
      .zone-report-content [style*="max-height: 300px"] {
        max-height: 200px !important;
      }
      
      .zone-report-content [style*="max-height: 400px"] {
        max-height: 250px !important;
      }
    }

    .zone-report-actions {
      display: flex;
      gap: 12px;
      margin-top: 24px;
      flex-wrap: wrap;
    }

    .zone-report-header {
      text-align: center;
      margin-bottom: 40px;
      padding-bottom: 24px;
      border-bottom: 3px solid var(--primary-dark);
    }

    .zone-report-title {
      font-size: 2.5rem;
      color: var(--primary-dark);
      font-family: 'Alegreya', serif;
      font-weight: 800;
      margin: 0 0 12px 0;
    }

    .zone-report-subtitle {
      font-size: 1.2rem;
      color: var(--text-light);
      margin: 0;
    }

    .zone-report-meta {
      margin-top: 16px;
      font-size: 0.9rem;
      color: var(--text-light);
    }

    .zone-report-section {
      margin-bottom: 40px;
      page-break-inside: avoid;
    }

    .zone-report-section-title {
      font-size: 1.8rem;
      color: var(--primary-dark);
      font-family: 'Alegreya', serif;
      font-weight: 800;
      margin: 0 0 20px 0;
      padding-bottom: 12px;
      border-bottom: 2px solid var(--primary);
    }

    .zone-report-subsection {
      margin-bottom: 28px;
    }

    .zone-report-subsection-title {
      font-size: 1.4rem;
      color: var(--primary);
      font-family: 'Alegreya', serif;
      font-weight: 700;
      margin: 0 0 16px 0;
    }

    .zone-report-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .zone-report-stat-card {
      background: rgba(96, 108, 56, 0.05);
      border: 2px solid var(--primary);
      border-radius: 8px;
      padding: 20px;
      text-align: center;
    }

    .zone-report-stat-value {
      font-size: 2.5rem;
      font-weight: 800;
      color: var(--primary-dark);
      font-family: 'Alegreya', serif;
      margin-bottom: 8px;
    }

    .zone-report-stat-label {
      font-size: 0.95rem;
      color: var(--text);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .zone-report-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 24px;
      font-size: 0.9rem;
    }

    .zone-report-table th {
      background: var(--primary-dark);
      color: white;
      padding: 12px;
      text-align: left;
      font-weight: 700;
      font-family: 'Alegreya', serif;
    }

    .zone-report-table td {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(40, 54, 24, 0.1);
    }

    .zone-report-table tr:hover {
      background: rgba(96, 108, 56, 0.05);
    }

    .zone-report-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .zone-report-list-item {
      padding: 12px;
      margin-bottom: 8px;
      background: rgba(96, 108, 56, 0.05);
      border-left: 4px solid var(--primary);
      border-radius: 4px;
    }

    .zone-report-insight {
      background: rgba(221, 161, 94, 0.1);
      border-left: 4px solid var(--accent);
      padding: 16px;
      margin-bottom: 16px;
      border-radius: 4px;
    }

    .zone-report-insight-title {
      font-weight: 700;
      color: var(--accent-dark);
      margin-bottom: 8px;
      font-family: 'Alegreya', serif;
    }

    .zone-report-insight-text {
      color: var(--text);
      line-height: 1.6;
    }

    .zone-report-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.85rem;
      font-weight: 600;
      margin-right: 8px;
      margin-bottom: 4px;
    }

    .zone-report-badge.standing {
      background: rgba(76, 175, 80, 0.2);
      color: #2e7d32;
    }

    .zone-report-badge.partial {
      background: rgba(255, 152, 0, 0.2);
      color: #e65100;
    }

    .zone-report-badge.total {
      background: rgba(244, 67, 54, 0.2);
      color: #b71c1c;
    }

    .zone-report-badge.staying {
      background: rgba(76, 175, 80, 0.2);
      color: #2e7d32;
    }

    .zone-report-badge.rebuilding {
      background: rgba(33, 150, 243, 0.2);
      color: #0d47a1;
    }

    .zone-report-badge.selling {
      background: rgba(156, 39, 176, 0.2);
      color: #4a148c;
    }

    .zone-report-badge.moved {
      background: rgba(158, 158, 158, 0.2);
      color: #424242;
    }

    @media (max-width: 768px) {
      .list-type-buttons,
      .list-source-options,
      .canned-list-options {
        grid-template-columns: 1fr;
      }

      .builder-filters {
        grid-template-columns: 1fr;
      }

      .list-results-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .contact-list-item-details {
        grid-template-columns: 1fr;
      }
    }

    .btn-save {
      padding: 12px 24px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: var(--light-cream);
      border: 0;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 800;
      margin-top: 12px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 12px rgba(188, 108, 37, 0.4);
      letter-spacing: 0.3px;
    }

    .btn-save-small {
      padding: 8px 16px;
      font-size: 0.9rem;
      font-weight: 800;
      letter-spacing: 0.3px;
      margin-top: 0;
    }

    .btn-refresh-small {
      padding: 8px 10px;
      background: linear-gradient(135deg, var(--light-green) 0%, var(--lighter-green) 100%);
      color: var(--primary-dark);
      border: 2px solid var(--primary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 4px rgba(96, 108, 56, 0.2);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      flex-shrink: 0;
    }

    .btn-refresh-small:hover {
      transform: rotate(90deg) translateY(-2px);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.3);
    }

    .btn-save:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(188, 108, 37, 0.5);
    }

    .btn-save:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .signin-prompt {
      background: rgba(255, 255, 255, 0.8);
      padding: 16px;
      border-radius: 8px;
      text-align: center;
      margin: 10px 0;
      border: 2px dashed var(--river);
    }

    .signin-prompt p {
      margin: 0 0 12px 0;
      color: #143039;
      font-size: 0.9rem;
    }

    .home-signin-prompt {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10000;
      background: var(--light-cream);
      border-radius: 16px;
      padding: 40px;
      max-width: 500px;
      box-shadow: 0 8px 32px rgba(40, 54, 24, 0.3), 0 4px 16px rgba(40, 54, 24, 0.2);
      border: 3px solid var(--primary);
      text-align: center;
    }

    .home-signin-content p {
      margin: 0 0 20px 0;
      color: var(--text);
      font-size: 1rem;
      line-height: 1.6;
    }

    .editable-field {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid var(--mint);
      border-radius: 4px;
      padding: 6px 8px;
      min-height: 20px;
      cursor: text;
      transition: all 0.2s;
    }

    .editable-field:focus {
      outline: none;
      border-color: var(--river);
      background: white;
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.2);
    }

    .editable-field:empty:before {
      content: "Click to add notes...";
      color: rgba(0, 0, 0, 0.4);
    }

    /* Expandable notes textarea */
    .editable-notes {
      width: 100%;
      background: #ffffff;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      padding: 8px;
      min-height: 60px;
      font-family: inherit;
      font-size: 0.9rem;
      resize: vertical;
      cursor: text;
      transition: all 0.2s;
      box-sizing: border-box;
    }

    .editable-notes:focus {
      outline: none;
      border-color: var(--river);
      box-shadow: 0 0 0 2px rgba(33, 64, 37, 0.1);
    }

    .editable-notes::placeholder {
      color: rgba(0, 0, 0, 0.4);
    }

    /* Subtle editable field for non-notes */
    .editable-inline {
      display: inline-block;
      background: rgba(255, 255, 255, 0.4);
      border: 1px dashed rgba(0, 0, 0, 0.2);
      border-radius: 3px;
      padding: 2px 6px;
      min-width: 60px;
      cursor: text;
      transition: all 0.2s;
    }

    .editable-inline:hover {
      background: rgba(255, 255, 255, 0.7);
      border-color: var(--mint);
    }

    .editable-inline:focus {
      outline: none;
      background: white;
      border: 1px solid var(--river);
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.15);
    }

    .editable-inline:empty:before {
      content: "...";
      color: rgba(0, 0, 0, 0.3);
    }

    /* Custom marker styling */
    .custom-marker {
      background: transparent !important;
      border: none !important;
    }
    
    .custom-colored-marker {
      background: transparent !important;
      border: none !important;
    }
    
    /* Color filter control styling */
    .color-filter-control {
      margin-top: 10px;
    }
    
    .color-legend-control {
      margin-top: 10px;
      margin-left: 10px;
    }

    /* Dropdown for Damage and Household Status */
    .editable-dropdown {
      display: inline-block;
      background: rgba(255, 255, 255, 0.4);
      border: 1px dashed rgba(0, 0, 0, 0.2);
      border-radius: 3px;
      padding: 2px 6px;
      min-width: 100px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: inherit;
      font-family: inherit;
      color: inherit;
    }

    .editable-dropdown:hover {
      background: rgba(255, 255, 255, 0.7);
      border-color: var(--mint);
    }

    .editable-dropdown:focus {
      outline: none;
      background: white;
      border: 1px solid var(--river);
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.15);
    }

    .save-status {
      font-size: 0.8rem;
      margin-top: 6px;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
    }

    .save-status.saving {
      background: var(--sunbeam);
      color: #143039;
    }

    .save-status.saved {
      background: var(--mint);
      color: #214025;
    }

    .save-status.error {
      background: var(--clementine);
      color: white;
    }

    .save-status-top {
      font-size: 0.65rem;
      margin-top: 0;
      padding: 2px 6px;
      height: 18px;
      line-height: 1.2;
      text-align: right;
      display: block;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .bottom-row {
      display: flex;
      gap: 16px;
    }

    .bottom-card { flex: 1; }
    .bottom-card:nth-child(1) { background: var(--honey); }
    .bottom-card:nth-child(2) { background: var(--sunbeam); }
    .bottom-card:nth-child(3) { background: var(--mint); }

    .link-list {
      margin: 6px 0 0;
      padding-left: 0;
      list-style: none;
      font-size: 0.9rem;
    }

    .link-list li { margin-bottom: 4px; }
    .link-list a { color: var(--river); text-decoration: none; }

    @media (max-width: 900px) {
      .main { flex-direction: column; }
      .bottom-row { flex-direction: column; }
    }

    /* Welcome Message Overlay */
    .welcome-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      backdrop-filter: blur(4px);
      pointer-events: auto;
    }

    .welcome-message {
      background: var(--light-cream);
      border-radius: 16px;
      padding: 40px;
      max-width: 600px;
      box-shadow: 0 8px 32px rgba(40, 54, 24, 0.3), 0 4px 16px rgba(40, 54, 24, 0.2);
      border: 3px solid var(--primary);
      text-align: center;
    }

    .welcome-message h2 {
      color: var(--primary-dark);
      font-size: 2rem;
      margin: 0 0 16px 0;
      font-family: 'Alegreya', serif;
      font-weight: 800;
    }

    .welcome-message > p {
      color: var(--text);
      font-size: 1.1rem;
      line-height: 1.6;
      margin: 0 0 24px 0;
      text-align: center;
    }

    .welcome-input-group {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
    }

    .welcome-sheet-input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid rgba(96, 108, 56, 0.3);
      border-radius: 8px;
      font-size: 0.95rem;
      background: rgba(255, 255, 255, 0.9);
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .welcome-sheet-input:focus {
      outline: none;
      border-color: var(--primary);
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.2), 0 0 0 3px rgba(96, 108, 56, 0.1);
    }

    .welcome-load-btn {
      padding: 12px 24px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: var(--light-cream);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 8px rgba(188, 108, 37, 0.3), 0 2px 4px rgba(188, 108, 37, 0.2);
      letter-spacing: 0.5px;
      white-space: nowrap;
    }

    .welcome-load-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(188, 108, 37, 0.4), 0 4px 6px rgba(188, 108, 37, 0.3);
    }

    .welcome-load-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(188, 108, 37, 0.3);
    }

    .welcome-help-link {
      text-align: center;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid rgba(96, 108, 56, 0.2);
    }

    .welcome-help-link a {
      color: var(--primary);
      text-decoration: none;
      font-size: 0.9rem;
      transition: color 0.2s ease;
    }

    .welcome-help-link a:hover {
      color: var(--primary-dark);
      text-decoration: underline;
    }

    .welcome-step {
      text-align: left;
      margin-bottom: 32px;
      padding: 24px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 12px;
      border: 2px solid rgba(96, 108, 56, 0.2);
    }

    .welcome-step-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .welcome-step-number {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      border-radius: 50%;
      font-weight: 700;
      font-size: 1.1rem;
      flex-shrink: 0;
    }

    .welcome-step h3 {
      margin: 0;
      font-size: 1.3rem;
      color: var(--primary-dark);
      font-family: 'Alegreya', serif;
      font-weight: 800;
    }

    .welcome-step-description {
      color: var(--text-light);
      font-size: 0.95rem;
      margin: 0 0 16px 0;
      line-height: 1.5;
    }

    .welcome-signin-btn {
      width: 100%;
      justify-content: center;
    }

    .welcome-step-status {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--primary);
      font-weight: 600;
      margin-top: 12px;
      padding: 8px 12px;
      background: rgba(96, 108, 56, 0.1);
      border-radius: 6px;
    }

    .welcome-checkmark {
      color: var(--primary);
      font-size: 1.2rem;
      font-weight: bold;
    }

  </style>
</head>

<body>
  <!-- Top Header Bar -->
  <div class="top-header">
    <div class="header-left" id="headerLeft">Zone XX  Altagether Dashboard</div>
    <div class="header-right">
      <!-- Alert scrolling area inside header -->
      <div class="header-alert-container" id="alertBar" style="display: none;">
        <div class="header-alert-content" id="alertBarContent"></div>
      </div>
      <span class="live-indicator">Live updates</span>
    </div>
    </div>

    <!-- Persistent Filter Bar -->
    <div class="filter-bar" id="filterBar" style="display: none;">
      <div class="filter-bar-content" id="filterBarContent">
        <!-- Filters will be inserted here -->
      </div>
    </div>

    <!-- App Container -->
    <div class="app-container">
    <!-- Left Navigation Bar -->
    <nav class="left-nav">
      <div class="nav-section">
        <button class="nav-item active" data-view="home" id="navHome">Home</button>
        <button class="nav-item" data-view="map" id="navMap">Map</button>
        <button class="nav-item" data-view="people" id="navPeople">Addresses & People</button>
        <button class="nav-item" data-view="meetups" id="navMeetups">Actions</button>
        <button class="nav-item" data-view="tools" id="navTools">Tools</button>
        <button class="nav-item" data-view="help" id="navHelp">Help</button>
      </div>
      <div class="nav-section nav-section-bottom">
        <div class="sheet-link-section">
          <label class="sheet-link-label" id="sheetLinkLabel">Link your zone spreadsheet</label>
          <input id="sheetUrlInput" class="nav-sheet-input" placeholder="Paste Google Sheet URL" />
          <button class="nav-load-btn" id="loadSheetBtn">Load</button>
        </div>
      </div>
    </nav>

    <!-- Full Screen Map -->
    <div class="map-container">
      <div id="zoneMap"></div>
    </div>

    <!-- Floating Right Panel (Addresses/Zone Notes/Contact Mode) -->
    <div class="floating-panel" id="floatingPanel">
      <div class="address-panel">
        <div class="address-panel-tabs">
          <div class="details-header">Details</div>
          <button class="tab-btn" id="zoneNotesTab" data-tab="notes" style="display: none;">Zone Notes</button>
          <div style="margin-left: auto; padding: 8px 8px; display: flex; gap: 0; align-items: center; flex-shrink: 0; min-width: 0;">
            <button class="btn-contact-mode" id="contactModeBtn" title="Toggle contact tracking mode"> Contact Mode</button>
          </div>
        </div>
        <div class="address-panel-content" id="addressPanelContent">
          <div class="empty">Load a spreadsheet to see addresses</div>
        </div>
        <div class="zone-notes-content" id="zoneNotesContent" style="display: none;">
          <textarea id="zoneNotesText" class="zone-notes-text" placeholder="Zone-level notes appear here..."></textarea>
          <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center;">
            <div class="save-status-small" id="zoneNotesStatus"></div>
            <button class="btn-save-small" id="saveZoneNotesBtn" title="Save notes"> Save</button>
          </div>
        </div>
        <div id="signinPrompt" style="display: none;" class="signin-prompt">
          <p><strong>Sign in to edit</strong><br>Click below to sign in with Google and enable editing</p>
          <button class="btn-signin" id="signInBtn">
            <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#fff" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z" fill-rule="evenodd"/><path fill="#fff" d="M9 18c2.43 0 4.467-.806 5.96-2.184l-2.908-2.258c-.806.54-1.837.86-3.052.86-2.347 0-4.33-1.584-5.04-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z" fill-rule="evenodd"/><path fill="#fff" d="M3.96 10.707c-.18-.54-.282-1.117-.282-1.707s.102-1.167.282-1.707V4.961H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.039l3.003-2.332z" fill-rule="evenodd"/><path fill="#fff" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.961L3.96 7.293C4.67 5.163 6.653 3.58 9 3.58z" fill-rule="evenodd"/></svg>
            Sign in with Google
          </button>
        </div>
      </div>
    </div>

    <!-- Content Views -->
    <!-- Home Dashboard View -->
    <div class="content-view" id="homeView" style="display: none;">
      <!-- Welcome Message Overlay (shown when spreadsheet not linked) -->
      <div class="welcome-overlay" id="welcomeOverlay" style="display: none;">
        <div class="welcome-message">
          <h2>Welcome to the Altagether Zone Dashboard</h2>
          <p>Get started in two simple steps:</p>
          
          <!-- Step 1: Sign In -->
          <div class="welcome-step" id="welcomeStep1">
            <div class="welcome-step-header">
              <span class="welcome-step-number">1</span>
              <h3>Sign in with Google</h3>
            </div>
            <p class="welcome-step-description">Sign in to access and edit your zone spreadsheet data.</p>
            <button class="btn-signin welcome-signin-btn" id="welcomeSignInBtn">
              <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#fff" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z" fill-rule="evenodd"/><path fill="#fff" d="M9 18c2.43 0 4.467-.806 5.96-2.184l-2.908-2.258c-.806.54-1.837.86-3.052.86-2.347 0-4.33-1.584-5.04-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z" fill-rule="evenodd"/><path fill="#fff" d="M3.96 10.707c-.18-.54-.282-1.117-.282-1.707s.102-1.167.282-1.707V4.961H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.039l3.003-2.332z" fill-rule="evenodd"/><path fill="#fff" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.961L3.96 7.293C4.67 5.163 6.653 3.58 9 3.58z" fill-rule="evenodd"/></svg>
              Sign in with Google
            </button>
            <div class="welcome-step-status" id="welcomeStep1Status" style="display: none;">
              <span class="welcome-checkmark"></span> Signed in
            </div>
          </div>

          <!-- Step 2: Link Spreadsheet -->
          <div class="welcome-step" id="welcomeStep2" style="display: none;">
            <div class="welcome-step-header">
              <span class="welcome-step-number">2</span>
              <h3>Link your zone spreadsheet</h3>
            </div>
            <p class="welcome-step-description">Paste the web address to your Google Sheets spreadsheet below.</p>
            <div class="welcome-input-group">
              <input id="welcomeSheetUrlInput" class="welcome-sheet-input" placeholder="Paste Google Sheet URL" />
              <button class="welcome-load-btn" id="welcomeLoadBtn">Load</button>
            </div>
          </div>
          
          <div class="welcome-help-link">
            <a href="#" id="getHelpBtn">Get Help</a>
          </div>
        </div>
      </div>
      
      <!-- Sign-in prompt for Home view (shown when spreadsheet linked but not signed in) -->
      <div id="homeSigninPrompt" style="display: none;" class="home-signin-prompt">
        <div class="home-signin-content">
          <p><strong>Sign in to view data</strong><br>Click below to sign in with Google and enable viewing and editing</p>
          <button class="btn-signin" id="homeSignInBtn">
            <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#fff" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z" fill-rule="evenodd"/><path fill="#fff" d="M9 18c2.43 0 4.467-.806 5.96-2.184l-2.908-2.258c-.806.54-1.837.86-3.052.86-2.347 0-4.33-1.584-5.04-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z" fill-rule="evenodd"/><path fill="#fff" d="M3.96 10.707c-.18-.54-.282-1.117-.282-1.707s.102-1.167.282-1.707V4.961H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.039l3.003-2.332z" fill-rule="evenodd"/><path fill="#fff" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.961L3.96 7.293C4.67 5.163 6.653 3.58 9 3.58z" fill-rule="evenodd"/></svg>
            Sign in with Google
          </button>
        </div>
      </div>
      
      <div class="home-dashboard">
        <div class="home-panels-grid">
          <!-- Panel A: Zone Overview -->
          <div class="home-panel">
            <div class="home-panel-header">
              <h2>Zone Overview</h2>
            </div>
            <div class="home-panel-content" id="zoneSnapshotContent">
              <div class="loading">Loading zone data...</div>
            </div>
            <div class="zone-overview-charts" id="zoneOverviewCharts" style="display: none;">
              <!-- Left Chart Carousel -->
              <div class="chart-carousel-wrapper">
                <div class="chart-carousel-container">
                  <button class="chart-carousel-arrow chart-carousel-arrow-left" aria-label="Previous chart">
                    <span class="chart-carousel-arrow-symbol"></span>
                  </button>
                  <div class="chart-carousel-track">
                    <div class="chart-container-small chart-carousel-slide active" data-chart-index="0">
                      <div class="chart-title">Addresses Contacted</div>
                      <canvas id="zoneOverviewLeftAddressesChart"></canvas>
                    </div>
                    <div class="chart-container-small chart-carousel-slide" data-chart-index="1">
                      <div class="chart-title">Streets Distribution</div>
                      <canvas id="zoneOverviewLeftStreetsChart"></canvas>
                    </div>
                    <div class="chart-container-small chart-carousel-slide" data-chart-index="2">
                      <div class="chart-title">People per Address</div>
                      <canvas id="zoneOverviewLeftPeopleChart"></canvas>
                    </div>
                  </div>
                  <button class="chart-carousel-arrow chart-carousel-arrow-right" aria-label="Next chart">
                    <span class="chart-carousel-arrow-symbol"></span>
                  </button>
                  <div class="chart-carousel-dots" data-carousel="left"></div>
                </div>
              </div>
              
              <!-- Right Chart Carousel -->
              <div class="chart-carousel-wrapper">
                <div class="chart-carousel-container">
                  <button class="chart-carousel-arrow chart-carousel-arrow-left" aria-label="Previous chart">
                    <span class="chart-carousel-arrow-symbol"></span>
                  </button>
                  <div class="chart-carousel-track">
                    <div class="chart-container-small chart-carousel-slide active" data-chart-index="0">
                      <div class="chart-title">Damage Status</div>
                      <canvas id="zoneOverviewRightDamageChart"></canvas>
                    </div>
                    <div class="chart-container-small chart-carousel-slide" data-chart-index="1">
                      <div class="chart-title">Rebuild Status</div>
                      <canvas id="zoneOverviewRightRebuildChart"></canvas>
                    </div>
                    <div class="chart-container-small chart-carousel-slide" data-chart-index="2">
                      <div class="chart-title">Household Status</div>
                      <canvas id="zoneOverviewRightHouseholdChart"></canvas>
                    </div>
                  </div>
                  <button class="chart-carousel-arrow chart-carousel-arrow-right" aria-label="Next chart">
                    <span class="chart-carousel-arrow-symbol"></span>
                  </button>
                  <div class="chart-carousel-dots" data-carousel="right"></div>
                </div>
              </div>
            </div>
            <div class="zone-overview-footer" id="zoneOverviewFooter" style="display: none;">
              <div class="stat-item">
                <span class="stat-label">Last updated</span>
                <span class="stat-value">-</span>
              </div>
            </div>
          </div>
          
          <!-- Panel B: From Altagether -->
          <div class="home-panel altagether-panel">
            <div class="home-panel-header">
              <h2>From Altagether</h2>
            </div>
            <div class="home-panel-content" id="altagetherContent">
              <div class="loading">Loading announcements...</div>
            </div>
          </div>
          
          <!-- Panel B2: Quick Actions -->
          <div class="home-panel">
            <div class="home-panel-header">
              <h2>Quick Actions</h2>
            </div>
            <div class="home-panel-content" id="quickActionsContent">
              <div class="loading">Loading quick actions...</div>
            </div>
          </div>
          
          <!-- Panel C: Zone Map -->
          <div class="home-panel home-panel-map">
            <div class="home-panel-header">
              <h2>Zone Map</h2>
            </div>
            <div class="home-panel-content home-map-container" id="homeMapContainer">
              <div id="homeMap" style="width: 100%; height: 100%;"></div>
            </div>
          </div>
          
          <!-- Panel D: Rebuild Progress Charts -->
          <div class="home-panel home-panel-wide">
            <div class="home-panel-header">
              <h2>Rebuild Progress</h2>
            </div>
            <div class="home-panel-content">
              <div class="charts-grid" id="homeChartsGrid">
                <div class="chart-container">
                  <div class="chart-title">Household Status</div>
                  <canvas id="householdStatusChart"></canvas>
                </div>
                <div class="chart-container">
                  <div class="chart-title">Rebuild Status</div>
                  <canvas id="rebuildStatusChart"></canvas>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Panel E: Zone Leadership -->
          <div class="home-panel">
            <div class="home-panel-header">
              <h2>Zone Leadership</h2>
            </div>
            <div class="home-panel-content" id="zoneLeadershipContent">
              <div class="loading">Loading zone leadership...</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Map View (just shows map, no overlay) -->
    <div class="content-view" id="mapView" style="display: none;">
      <!-- Map view doesn't need content - map is always visible in background -->
    </div>

    <!-- Addresses & People View (Table) -->
    <div class="content-view" id="peopleView" style="display: none;">
      <div class="people-view-header">
        <h2 style="margin: 0; color: var(--primary-dark); font-size: 1.8rem; letter-spacing: 0.5px; font-family: 'Alegreya', serif;">Addresses & People</h2>
        <div class="people-view-actions">
          <button class="btn-print-export" id="btnPrintAddresses"> Print</button>
          <button class="btn-print-export" id="btnExportAddresses"> Export CSV</button>
        </div>
      </div>
      <div id="peopleTableView"></div>
    </div>

    <!-- Tools View -->
    <div class="content-view" id="toolsView" style="display: none;">
      <h2 style="margin-top: 0; color: var(--primary-dark); font-size: 2rem; letter-spacing: 0.5px; text-shadow: 0 2px 4px rgba(40, 54, 24, 0.1);">Tools</h2>
      
      <div class="tools-grid">
      <!-- Contact List Creator Module removed - functionality integrated into Addresses & People view -->

      <!-- Zone Analysis Generator Module -->
      <div class="tool-module" id="zoneReportGenerator">
        <div class="tool-module-header" style="cursor: pointer;">
          <h3>Zone Analysis <span class="tool-module-toggle"></span></h3>
          <p>Create a comprehensive PDF report with all zone data, statistics, analysis, and insights. Perfect for printing, sharing, or archiving.</p>
        </div>
        
        <div class="tool-module-content">
        <div class="zone-report-controls">
          <button class="btn-generate-report" id="btnGenerateReport"> Generate Zone Analysis</button>
          <div class="zone-report-status" id="zoneReportStatus"></div>
        </div>
        
        <div class="zone-report-container" id="zoneReportContainer" style="display: none;">
          <div class="zone-report-actions" style="margin-bottom: 24px; padding: 16px; background: rgba(96, 108, 56, 0.05); border-radius: 8px; border: 2px solid var(--primary);">
            <button class="btn-export" id="btnExportReportPDF" style="font-size: 1.1rem; padding: 14px 28px;"> Export to PDF</button>
          </div>
          <div class="zone-report-content" id="zoneReportContent">
            <!-- Report will be generated here -->
          </div>
        </div>
        </div>
      </div>

      <!-- Flyer Creator Link Module -->
      <div class="tool-module" id="flyerCreatorLink" data-no-expand="true">
        <div class="tool-module-header">
          <h3>Flyer Creator</h3>
          <p>Create professional event flyers with customizable designs. Perfect for community meetings, resource distribution, and neighborhood events.</p>
        </div>
        <div style="margin-top: 16px;">
          <a href="flyer_tool.html" target="_blank" rel="noopener noreferrer" class="help-link-btn" style="display: inline-block; padding: 12px 24px; background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%); color: var(--light-cream); text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 1rem; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 4px 8px rgba(188, 108, 37, 0.3), 0 2px 4px rgba(188, 108, 37, 0.2); letter-spacing: 0.5px; cursor: pointer;">
             Open Flyer Creator
          </a>
        </div>
      </div>

      <!-- Neighborhood Captain Directory Link Module -->
      <div class="tool-module" id="captainDirectoryLink" data-no-expand="true">
        <div class="tool-module-header">
          <h3>Neighborhood Captain Directory</h3>
          <p>Find and connect with volunteer neighborhood captains</p>
        </div>
        <div style="margin-top: 16px;">
          <a href="https://johntmayo.github.io/captain-directory/" target="_blank" rel="noopener noreferrer" class="help-link-btn" style="display: inline-block; padding: 12px 24px; background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%); color: var(--light-cream); text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 1rem; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 4px 8px rgba(188, 108, 37, 0.3), 0 2px 4px rgba(188, 108, 37, 0.2); letter-spacing: 0.5px; cursor: pointer;">
             Open Captain Directory
          </a>
        </div>
      </div>
      </div>
    </div>

    <!-- Actions View -->
    <div class="content-view" id="meetupsView" style="display: none;">
      <h2 style="margin-top: 0; color: var(--primary-dark); font-size: 2rem; letter-spacing: 0.5px; text-shadow: 0 2px 4px rgba(40, 54, 24, 0.1);">Actions</h2>
      <div id="actionsPageContent" style="margin-top: 24px;">
        <div class="loading">Loading actions...</div>
      </div>
    </div>

    <!-- Help View -->
    <div class="content-view" id="helpView" style="display: none;">
      <h2 style="margin-top: 0; color: var(--primary-dark); font-size: 2rem; letter-spacing: 0.5px; text-shadow: 0 2px 4px rgba(40, 54, 24, 0.1);">Help</h2>
      
      <div style="display: flex; flex-direction: column; gap: 24px; margin-top: 24px; max-width: 800px;">
        <!-- Documentation Widget -->
        <div style="padding: 24px; background: linear-gradient(135deg, rgba(254, 250, 224, 0.6) 0%, rgba(255, 255, 255, 0.6) 100%); border-radius: 12px; border: 2px solid var(--primary); box-shadow: 0 4px 12px rgba(40, 54, 24, 0.1);">
          <h3 style="margin-top: 0; margin-bottom: 12px; color: var(--primary-dark); font-size: 1.3rem;">Documentation</h3>
          <p style="margin-bottom: 20px; color: var(--text); line-height: 1.6;">View the complete help documentation with detailed instructions and guides.</p>
          <a href="help.html" target="_blank" rel="noopener noreferrer" class="help-link-btn" style="display: inline-block; padding: 12px 24px; background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%); color: var(--light-cream); text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 1rem; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 4px 8px rgba(188, 108, 37, 0.3), 0 2px 4px rgba(188, 108, 37, 0.2); letter-spacing: 0.5px; cursor: pointer;">
             Open Help Documentation
          </a>
        </div>

        <!-- Discord Widget -->
        <div style="padding: 24px; background: linear-gradient(135deg, rgba(254, 250, 224, 0.6) 0%, rgba(255, 255, 255, 0.6) 100%); border-radius: 12px; border: 2px solid var(--primary); box-shadow: 0 4px 12px rgba(40, 54, 24, 0.1);">
          <h3 style="margin-top: 0; margin-bottom: 12px; color: var(--primary-dark); font-size: 1.3rem;">Discord</h3>
          <p style="margin-bottom: 20px; color: var(--text); line-height: 1.6;">Join our Discord community for support, updates, and discussions.</p>
          <div style="display: inline-block; padding: 12px 24px; background: linear-gradient(135deg, rgba(88, 101, 242, 0.8) 0%, rgba(88, 101, 242, 1) 100%); color: white; border-radius: 8px; font-weight: 600; font-size: 1rem; opacity: 0.6; cursor: not-allowed;">
             Join Discord (Coming Soon)
          </div>
        </div>

        <!-- Altagether Calendar Widget -->
        <div style="padding: 24px; background: linear-gradient(135deg, rgba(254, 250, 224, 0.6) 0%, rgba(255, 255, 255, 0.6) 100%); border-radius: 12px; border: 2px solid var(--primary); box-shadow: 0 4px 12px rgba(40, 54, 24, 0.1);">
          <h3 style="margin-top: 0; margin-bottom: 12px; color: var(--primary-dark); font-size: 1.3rem;">Altagether Calendar</h3>
          <p style="margin-bottom: 20px; color: var(--text); line-height: 1.6;">View upcoming events, meetings, and important dates for the Altagether community.</p>
          <div style="display: inline-block; padding: 12px 24px; background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); color: var(--light-cream); border-radius: 8px; font-weight: 600; font-size: 1rem; opacity: 0.6; cursor: not-allowed;">
             View Calendar (Coming Soon)
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const input = document.getElementById("sheetUrlInput");
    const btn = document.getElementById("loadSheetBtn");
    // Refresh button removed - data auto-loads after sign-in
    const addressPanelContent = document.getElementById("addressPanelContent");
    const signInBtn = document.getElementById("signInBtn");
    const signinPrompt = document.getElementById("signinPrompt");

    // Navigation state
    let currentView = 'home'; // Default view
    let currentSheetUrl = '';
    let sheetData = [];
    let selectedAddress = null; // Track currently selected address
    let savedScrollPosition = 0; // Track scroll position for refresh
    let accessToken = null; // OAuth2 access token
    let currentSheetId = null; // Current sheet ID for writing
    let currentStreetFilter = 'all'; // Current street filter
    let currentDamageFilter = 'all'; // Current damage filter
    let currentStatusFilter = 'all'; // Current household status filter
    let currentRebuildFilter = 'all'; // Current rebuild status filter
    let currentCaptainFilter = 'all'; // Current captain assigned filter
    let showContactedAddresses = true; // Show addresses with contacted people
    let showUncontactedAddresses = true; // Show addresses with uncontacted people
    
    // Sequential rebuild stages (in order)
    const REBUILD_STAGES_SEQUENTIAL = [
      'Debris Removal & Site Clearance',
      'Professional Selection (Architect/Engineer & Builder)',
      'Plan Preparation & Design Stage',
      'Permit Application & Submittal',
      'Plan Check & Agency Review',
      'Plan Revision & Recheck',
      'Permit Issuance',
      'Construction',
      'Mandatory Inspections',
      'Final Inspection & Sign-Off',
      'Certificate of Occupancy'
    ];
    let tableSortColumn = null; // Current sort column
    let tableSortDirection = 'asc'; // Sort direction: 'asc' or 'desc'
    let zoneMap = null; // Leaflet map instance
    let homeMap = null; // Homepage map instance
    let addressMarkers = []; // Array of address markers
    let homeMapMarkers = []; // Array of markers for homepage map
    let kmlLayer = null; // KML boundary layer
    let homeKmlLayer = null; // KML boundary layer for homepage
    let currentTileLayer = null; // Current map tile layer
    let homeTileLayer = null; // Tile layer for homepage
    let isSatelliteMode = false; // Track satellite mode state
    let currentColorMode = null; // Current color mode: 'contact', 'damage', 'status', 'rebuild', or null
    // Load saved color mode from localStorage
    const savedColorMode = localStorage.getItem('currentColorMode');
    if (savedColorMode && savedColorMode !== '') {
      currentColorMode = savedColorMode;
    }
    let homeColorMode = null; // Color mode for home map
    let colorLegendControl = null; // Color legend control instance
    let colorFilterControl = null; // Color filter control instance
    let homeColorFilterControl = null; // Color filter control instance for home map
    let homeColorLegendControl = null; // Color legend control instance for home map
    let colorFilterWatchdog = null; // Interval ID for watching control
    let isHomeSatelliteMode = false; // Track satellite mode for homepage
    let zoneNotes = ''; // Zone-level notes
    let zoneKmlUrl = ''; // Zone KML URL from metadata
    let metadataSheetId = null; // Sheet ID for metadata sheet
    let autoSaveTimer = null; // Timer for debounced auto-save
    let currentZoneName = ''; // Current zone name from spreadsheet

    // Load OAuth token from localStorage
    const savedToken = localStorage.getItem('googleOAuthToken');
    const savedTokenExpiry = localStorage.getItem('googleOAuthTokenExpiry');
    if (savedToken && savedTokenExpiry && Date.now() < parseInt(savedTokenExpiry)) {
      accessToken = savedToken;
      updateSignInUI();
    }

    // Load saved sheet URL from localStorage
    const savedSheetUrl = localStorage.getItem('savedSheetUrl');
    if (savedSheetUrl && input) {
      input.value = savedSheetUrl;
      currentSheetUrl = savedSheetUrl;
      // Auto-load the sheet if user is signed in (wait a bit for OAuth to initialize)
      if (accessToken) {
        setTimeout(() => {
          if (currentSheetUrl) {
            loadAddressData(currentSheetUrl);
          }
        }, 1000);
      }
    }

    // Initialize sheet link label, welcome message, header title, and navigation state
    updateSheetLinkLabel();
    updateWelcomeMessage();
    updateHeaderTitle();
    updateNavigationState();

    // Get Help link handler
    const getHelpBtn = document.getElementById('getHelpBtn');
    if (getHelpBtn) {
      getHelpBtn.addEventListener('click', (e) => {
        e.preventDefault();
        // Open help page in new window
        window.open('help.html', '_blank', 'noopener,noreferrer');
      });
    }

    // Welcome popup load button handler
    const welcomeLoadBtn = document.getElementById('welcomeLoadBtn');
    const welcomeSheetUrlInput = document.getElementById('welcomeSheetUrlInput');
    if (welcomeLoadBtn && welcomeSheetUrlInput) {
      welcomeLoadBtn.addEventListener('click', () => {
        // Validate sign-in first
        if (!accessToken) {
          alert('Please sign in with Google first before loading your spreadsheet.');
          // Show step 1 if hidden
          const welcomeStep1 = document.getElementById('welcomeStep1');
          if (welcomeStep1) {
            welcomeStep1.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
          return;
        }

        let url = welcomeSheetUrlInput.value.trim();
        if (!url) {
          alert('Please enter a Google Sheets URL.');
          return;
        }

        if (url.includes("/view")) {
          url = url.replace("/view", "/edit");
        }

        // Update main input field
        if (input) {
          input.value = url;
        }

        currentSheetUrl = url;
        // Save to localStorage
        localStorage.setItem('savedSheetUrl', url);
        
        // Update UI
        updateSheetLinkLabel();
        updateWelcomeMessage();
        updateNavigationState();
        
        // Load the address data
        loadAddressData(url);
      });

      // Also allow Enter key to trigger load
      welcomeSheetUrlInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          welcomeLoadBtn.click();
        }
      });
    }

    // Initialize Google API
    function initGoogleAPI() {
      gapi.load('client', () => {
        gapi.client.init({
          discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
        }).then(() => {
          console.log('Google API initialized');
        });
      });
    }

    // Initialize on page load
    if (typeof gapi !== 'undefined') {
      initGoogleAPI();
    } else {
      window.addEventListener('load', () => {
        if (typeof gapi !== 'undefined') {
          initGoogleAPI();
        }
      });
    }

    // ============================================
    // CONFIGURATION: OAuth Client ID
    // ============================================
    // To enable editing, you need a Google OAuth Client ID:
    // 1. Go to https://console.cloud.google.com/apis/credentials
    // 2. Create OAuth 2.0 Client ID (Web application)
    // 3. Add your domain to authorized JavaScript origins
    // 4. Replace 'YOUR_CLIENT_ID' below with your actual Client ID
    // ============================================
    const OAUTH_CLIENT_ID = '633926045450-3214il5eg7emu5e0fp8am1g26jdfnoh7.apps.googleusercontent.com'; // Replace with your OAuth Client ID

    // OAuth2 Sign In
    async function signIn() {
      if (OAUTH_CLIENT_ID === 'YOUR_CLIENT_ID') {
        alert('OAuth Client ID not configured. Please set OAUTH_CLIENT_ID in the code.');
        return;
      }
      
      try {
        const tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: OAUTH_CLIENT_ID,
          scope: 'https://www.googleapis.com/auth/spreadsheets',
          callback: (response) => {
            if (response.error) {
              console.error('Sign in error:', response.error);
              alert('Sign in failed. Please try again.');
              return;
            }
            accessToken = response.access_token;
            // Store token with expiry (tokens last 1 hour, store for 50 minutes)
            const expiry = Date.now() + (50 * 60 * 1000);
            localStorage.setItem('googleOAuthToken', accessToken);
            localStorage.setItem('googleOAuthTokenExpiry', expiry.toString());
            updateSignInUI();
            
            // Auto-load data after sign-in if we have a sheet URL
            const savedSheetUrl = localStorage.getItem('savedSheetUrl');
            const sheetUrlToLoad = currentSheetUrl || savedSheetUrl;
            
            if (sheetUrlToLoad) {
              currentSheetUrl = sheetUrlToLoad;
              // Small delay to ensure UI updates
              setTimeout(() => {
                loadAddressData(sheetUrlToLoad);
              }, 500);
            } else if (selectedAddress && currentSheetUrl) {
              // Fallback: refresh current address if one is selected
              loadAddressData(currentSheetUrl);
            }
            
          },
        });
        tokenClient.requestAccessToken({ prompt: 'consent' });
      } catch (error) {
        console.error('Sign in error:', error);
        alert('Error signing in. Please try again.');
      }
    }

    // Sign Out
    function signOut() {
      accessToken = null;
      localStorage.removeItem('googleOAuthToken');
      localStorage.removeItem('googleOAuthTokenExpiry');
      updateSignInUI();
      if (selectedAddress && currentSheetUrl) {
        loadAddressData(currentSheetUrl);
      }
    }

    // Update sign-in UI
    function updateSignInUI() {
      const homeSigninPrompt = document.getElementById('homeSigninPrompt');
      
      if (accessToken) {
        signinPrompt.style.display = 'none';
        if (homeSigninPrompt) homeSigninPrompt.style.display = 'none';
        // Could add a sign-out button here if needed
      } else {
        // Always show sign-in prompt when not signed in
        signinPrompt.style.display = 'block';
        // Show home sign-in prompt if on home view and spreadsheet is linked
        if (homeSigninPrompt && currentView === 'home' && currentSheetUrl) {
          homeSigninPrompt.style.display = 'block';
        } else if (homeSigninPrompt) {
          homeSigninPrompt.style.display = 'none';
        }
      }
      
      // Update welcome message to reflect sign-in state
      updateWelcomeMessage();
    }

    // Update sheet link label based on link status
    function updateSheetLinkLabel() {
      const label = document.getElementById('sheetLinkLabel');
      if (!label) return;
      
      if (currentSheetUrl) {
        // Spreadsheet is linked - show "Link spreadsheet" with subtle external link icon
        label.innerHTML = `Link spreadsheet <svg class="sheet-link-external-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" title="Open spreadsheet"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>`;
        // Add click handler to the icon
        const icon = label.querySelector('.sheet-link-external-icon');
        if (icon) {
          icon.style.cursor = 'pointer';
          icon.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            window.open(currentSheetUrl, '_blank', 'noopener,noreferrer');
          });
        }
      } else {
        // No spreadsheet linked
        label.textContent = 'Link your zone spreadsheet';
      }
    }

    // Update welcome message visibility and step progression
    function updateWelcomeMessage() {
      const welcomeOverlay = document.getElementById('welcomeOverlay');
      const welcomeStep1 = document.getElementById('welcomeStep1');
      const welcomeStep2 = document.getElementById('welcomeStep2');
      const welcomeStep1Status = document.getElementById('welcomeStep1Status');
      const welcomeSignInBtn = document.getElementById('welcomeSignInBtn');
      
      if (!welcomeOverlay) return;
      
      // Show welcome message only on home page when no spreadsheet is linked
      if (currentView === 'home' && !currentSheetUrl) {
        welcomeOverlay.style.display = 'flex';
        
        // Update step visibility based on sign-in state
        if (accessToken) {
          // User is signed in - show step 2, hide step 1 button
          if (welcomeStep1) {
            const btnContainer = welcomeSignInBtn?.parentElement;
            if (btnContainer && welcomeSignInBtn) {
              welcomeSignInBtn.style.display = 'none';
            }
            if (welcomeStep1Status) {
              welcomeStep1Status.style.display = 'flex';
            }
          }
          if (welcomeStep2) {
            welcomeStep2.style.display = 'block';
          }
        } else {
          // User not signed in - show step 1, hide step 2
          if (welcomeStep1) {
            const btnContainer = welcomeSignInBtn?.parentElement;
            if (btnContainer && welcomeSignInBtn) {
              welcomeSignInBtn.style.display = 'flex';
            }
            if (welcomeStep1Status) {
              welcomeStep1Status.style.display = 'none';
            }
          }
          if (welcomeStep2) {
            welcomeStep2.style.display = 'none';
          }
        }
      } else {
        welcomeOverlay.style.display = 'none';
      }
    }

    // Update header title based on zone name and spreadsheet link status
    function updateHeaderTitle() {
      const headerLeft = document.getElementById('headerLeft');
      if (!headerLeft) return;
      
      if (currentSheetUrl && currentZoneName) {
        // Strip "Zone" from the beginning if it's already there
        let zoneName = currentZoneName.trim();
        if (zoneName.toLowerCase().startsWith('zone ')) {
          zoneName = zoneName.substring(5).trim();
        }
        headerLeft.textContent = `Zone ${zoneName}  Altagether Dashboard`;
      } else {
        headerLeft.textContent = 'Altagether Dashboard';
      }
    }

    // Update navigation disabled state
    function updateNavigationState() {
      const leftNav = document.querySelector('.left-nav');
      const navItems = document.querySelectorAll('.nav-item[data-view]');
      const sheetLinkSection = document.querySelector('.sheet-link-section');
      
      if (!currentSheetUrl) {
        // No spreadsheet linked - disable all navigation except Home
        if (leftNav) {
          leftNav.classList.add('disabled');
        }
        // Hide the sheet link section in left nav when welcome overlay is shown
        if (sheetLinkSection) {
          sheetLinkSection.style.display = 'none';
        }
        navItems.forEach(item => {
          const viewName = item.getAttribute('data-view');
          if (viewName !== 'home') {
            item.disabled = true;
            item.style.pointerEvents = 'none';
          } else {
            item.disabled = false;
            item.style.pointerEvents = 'auto';
          }
        });
      } else {
        // Spreadsheet linked - enable all navigation
        if (leftNav) {
          leftNav.classList.remove('disabled');
        }
        // Show the sheet link section for changing spreadsheet
        if (sheetLinkSection) {
          sheetLinkSection.style.display = 'block';
        }
        navItems.forEach(item => {
          item.disabled = false;
          item.style.pointerEvents = 'auto';
        });
      }
    }

    // Sign in button handler
    signInBtn.addEventListener('click', signIn);

    // Home sign-in button handler (uses same signIn function)
    const homeSignInBtn = document.getElementById('homeSignInBtn');
    if (homeSignInBtn) {
      homeSignInBtn.addEventListener('click', signIn);
    }

    // Welcome sign-in button handler (uses same signIn function)
    const welcomeSignInBtn = document.getElementById('welcomeSignInBtn');
    if (welcomeSignInBtn) {
      welcomeSignInBtn.addEventListener('click', signIn);
    }

    // Extract sheet ID from any Google Sheets URL format
    function extractSheetId(sheetUrl) {
      // Handle published format: /spreadsheets/d/e/...
      const publishedMatch = sheetUrl.match(/\/spreadsheets\/d\/e\/([a-zA-Z0-9-_]+)/);
      if (publishedMatch) {
        return { sheetId: publishedMatch[1], isPublished: true };
      }
      
      // Handle standard format: /spreadsheets/d/...
      const standardMatch = sheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
      if (!standardMatch) {
        return null;
      }
      
      return { sheetId: standardMatch[1], isPublished: false };
    }

    // Convert Google Sheets URL to CSV export URL
    function getCsvUrl(sheetUrl) {
      const sheetInfo = extractSheetId(sheetUrl);
      if (!sheetInfo) {
        console.error('Could not parse Google Sheets URL:', sheetUrl);
        return null;
      }
      
      if (sheetInfo.isPublished) {
        // For published sheets, use /pub?output=csv
        const csvUrl = `https://docs.google.com/spreadsheets/d/e/${sheetInfo.sheetId}/pub?output=csv`;
        console.log('Converted published URL to CSV:', csvUrl);
        return csvUrl;
      }
      
      // For standard format, extract GID if present
      const gidMatch = sheetUrl.match(/[#&]gid=(\d+)/);
      const gid = gidMatch ? gidMatch[1] : '0';
      
      // Build CSV export URL
      const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetInfo.sheetId}/export?format=csv&gid=${gid}`;
      console.log('Converted standard URL to CSV:', csvUrl);
      return csvUrl;
    }

    // Fetch data using Google Sheets API v4 with OAuth token
    async function fetchViaOAuth(sheetId, range = 'A1:ZZ1000', sheetName = null) {
      // Check if token is expired and refresh if needed
      const storedExpiry = localStorage.getItem('googleOAuthTokenExpiry');
      if (storedExpiry && Date.now() > parseInt(storedExpiry)) {
        console.log('Token expired, clearing...');
        accessToken = null;
        localStorage.removeItem('googleOAuthToken');
        localStorage.removeItem('googleOAuthTokenExpiry');
        throw new Error('Your session has expired. Please sign in again.');
      }
      
      if (!accessToken) {
        throw new Error('Not signed in. Please sign in to view data.');
      }
      
      // If sheetName is provided, use it; otherwise use default range
      const rangeParam = sheetName ? `${sheetName}!${range}` : range;
      const apiUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${rangeParam}`;
      
      const response = await fetch(apiUrl, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      });
      
      if (!response.ok) {
        const error = await response.json();
        // If 401, token is invalid - clear it
        if (response.status === 401) {
          accessToken = null;
          localStorage.removeItem('googleOAuthToken');
          localStorage.removeItem('googleOAuthTokenExpiry');
          throw new Error('Your session has expired. Please sign in again.');
        }
        throw new Error(error.error?.message || `API Error: ${response.status}`);
      }
      
      const data = await response.json();
      return data.values || [];
    }

    // Fetch Zone Notes sheet (Zone Notes and KML URL)
    async function fetchMetadata(sheetId) {
      if (!accessToken) {
        console.log('No access token for metadata fetch');
        return null;
      }
      
      try {
        // Try to fetch from "Zone Notes" sheet
        console.log('Attempting to fetch Zone Notes sheet...');
        const metadataValues = await fetchViaOAuth(sheetId, 'A1:B10', 'Zone Notes');
        console.log('Metadata values received:', metadataValues);
        
        if (!metadataValues || metadataValues.length === 0) {
          console.log('Zone Notes sheet is empty or not found');
          return null;
        }
        
        let notes = '';
        let kmlUrl = '';
        
        // Parse metadata - look for "Zone Notes" and "KML URL" rows
        for (let i = 0; i < metadataValues.length; i++) {
          const row = metadataValues[i];
          if (row && row.length >= 2) {
            const key = (row[0] || '').toString().trim().toLowerCase();
            const value = (row[1] || '').toString().trim();
            
            console.log(`Metadata row ${i}: key="${key}", value="${value}"`);
            
            if (key.includes('zone note') || key === 'notes') {
              notes = value;
              console.log('Found Zone Notes:', notes);
            } else if (key.includes('kml') || key.includes('boundary')) {
              // Clean the URL - remove quotes, trim whitespace
              kmlUrl = value.replace(/^["']|["']$/g, '').trim();
              console.log('Found KML URL:', kmlUrl);
            }
          }
        }
        
        return { notes, kmlUrl };
      } catch (error) {
        console.error('Error fetching Zone Notes sheet:', error);
        console.log('Zone Notes sheet not found or error reading it:', error.message);
        return null;
      }
    }

    // Parse CSV text to array of objects
    function parseCSV(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) return [];

      // Parse header
      const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      
      // Parse data rows
      const data = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim().replace(/^"|"$/g, ''));
        if (values.length === 0 || values.every(v => !v)) continue;
        
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] || '';
        });
        data.push(row);
      }
      
      return { headers, data };
    }

    // Convert API response (array of arrays) to object format
    function parseApiData(apiValues) {
      if (!apiValues || apiValues.length === 0) return { headers: [], data: [] };
      
      const headers = apiValues[0].map(h => h.trim());
      const data = [];
      
      for (let i = 1; i < apiValues.length; i++) {
        const row = {};
        headers.forEach((header, index) => {
          row[header] = apiValues[i][index] || '';
        });
        // Only add row if it has at least one non-empty value
        if (Object.values(row).some(v => v.trim())) {
          data.push(row);
        }
      }
      
      return { headers, data };
    }

    // Fetch and process spreadsheet data
    async function loadAddressData(sheetUrl) {
      // Save current scroll position before refreshing (if we're refreshing, not initial load)
      if (sheetData.addressMap) {
        savedScrollPosition = addressPanelContent.scrollTop;
      }

      if (!addressPanelContent) {
        console.error('addressPanelContent element not found');
        return;
      }

      addressPanelContent.innerHTML = '<div class="loading">Loading addresses...</div>';

      // Require OAuth sign-in to read data
      if (!accessToken) {
        addressPanelContent.innerHTML = '<div class="error">Please sign in with Google to view data.</div>';
        // Show sign-in prompt
        if (signinPrompt) signinPrompt.style.display = 'block';
        return;
      }

      const sheetInfo = extractSheetId(sheetUrl);
      if (!sheetInfo) {
        addressPanelContent.innerHTML = '<div class="error">Invalid Google Sheets URL</div>';
        return;
      }
      
      try {
        let headers, data;
        
        // Use OAuth to fetch data
        console.log('Fetching data via OAuth...');
        try {
          const apiValues = await fetchViaOAuth(sheetInfo.sheetId);
          const parsed = parseApiData(apiValues);
          headers = parsed.headers;
          data = parsed.data;
          console.log('Successfully loaded via OAuth');
          
          // Also fetch Zone Notes sheet
          metadataSheetId = sheetInfo.sheetId;
          console.log('Fetching Zone Notes sheet...');
          const metadata = await fetchMetadata(sheetInfo.sheetId);
          if (metadata) {
            console.log('Metadata found:', metadata);
            zoneNotes = metadata.notes || '';
            zoneKmlUrl = metadata.kmlUrl || '';
            updateZoneNotesUI();
            // Auto-load KML if URL is provided (wait for map to initialize if needed)
            if (zoneKmlUrl) {
              console.log('Auto-loading KML from Zone Notes sheet:', zoneKmlUrl);
              if (zoneMap) {
                loadKMLBoundary(zoneKmlUrl);
              } else {
                // Wait a bit for map to initialize, then load KML
                setTimeout(() => {
                  if (zoneMap && zoneKmlUrl) {
                    console.log('Loading KML after map initialization:', zoneKmlUrl);
                    loadKMLBoundary(zoneKmlUrl);
                  }
                }, 1000);
              }
              // Also load KML for home map
              if (homeMap) {
                loadHomeKMLBoundary(zoneKmlUrl);
              } else {
                // Wait a bit for home map to initialize, then load KML
                setTimeout(() => {
                  if (homeMap && zoneKmlUrl) {
                    console.log('Loading KML for home map after initialization:', zoneKmlUrl);
                    loadHomeKMLBoundary(zoneKmlUrl);
                  }
                }, 1000);
              }
            } else {
              console.log('No KML URL found in Zone Notes sheet');
            }
          } else {
            console.log('No metadata found or Zone Notes sheet does not exist');
          }
        } catch (oauthError) {
          console.error('OAuth fetch failed:', oauthError);
          throw new Error(`Error loading data: ${oauthError.message}. Make sure you're signed in and have access to this sheet.`);
        }
        
        // No fallback - OAuth is required
        if (!headers || !data) {
          // Fall back to CSV export (requires published sheet)
          const csvUrl = getCsvUrl(sheetUrl);
          if (!csvUrl) {
            throw new Error('Could not generate CSV URL');
          }

          // Try direct fetch first, then CORS proxy if needed
          let csvText;
          try {
            const response = await fetch(csvUrl);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            csvText = await response.text();
          } catch (error) {
            // If direct fetch fails, try CORS proxy
            console.log('Direct fetch failed, trying CORS proxy...', error);
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(csvUrl)}`;
            const proxyResponse = await fetch(proxyUrl);
            if (!proxyResponse.ok) {
              throw new Error(`Proxy fetch failed: ${proxyResponse.status}. Please sign in with Google.`);
            }
            csvText = await proxyResponse.text();
          }
          
          if (!csvText || csvText.trim().length === 0) {
            throw new Error('Spreadsheet appears to be empty or could not be accessed.');
          }
          
          const parsed = parseCSV(csvText);
          headers = parsed.headers;
          data = parsed.data;
        }
        
        if (data.length === 0) {
          addressPanelContent.innerHTML = '<div class="empty">No data found in spreadsheet</div>';
          return;
        }

        // Find address columns - prefer separate House # and Street, fallback to Address
        const houseNumCol = headers.find(h => {
          const lower = h.toLowerCase();
          // Match "House #" exactly (case-insensitive) or variations
          return h === 'House #' || 
                 lower === 'house #' ||
                 lower.includes('house #') || 
                 lower.includes('house#') ||
                 lower === 'house number' ||
                 lower === 'house num' ||
                 (lower === 'house' && !lower.includes('hold')); // "house" but not "household"
        });
        const streetCol = headers.find(h => {
          const lower = h.toLowerCase();
          // Match "Street" exactly (case-insensitive) or variations
          return h === 'Street' ||
                 lower === 'street' ||
                 (lower.includes('street') && !lower.includes('address'));
        });
        const addressCol = headers.find(h => {
          const lower = h.toLowerCase();
          return (lower.includes('address') || lower.includes('location')) &&
                 !lower.includes('email') && !lower.includes('phone');
        });

        // Helper function to get address string
        const getAddressString = (row) => {
          if (houseNumCol && streetCol) {
            const houseNum = (row[houseNumCol] || '').trim();
            const street = (row[streetCol] || '').trim();
            if (houseNum && street) {
              return `${houseNum} ${street}`;
            } else if (street) {
              return street;
            } else if (houseNum) {
              return houseNum;
            }
          }
          // Fallback to Address column if it exists
          if (addressCol) {
            return (row[addressCol] || '').trim();
          }
          return null;
        };

        // Check if we have at least one way to identify addresses
        if (!houseNumCol && !streetCol && !addressCol) {
          const availableCols = headers.slice(0, 10).join(', ');
          addressPanelContent.innerHTML = `<div class="error">No address columns found. Need either "House #" and "Street" columns, or an "Address" column. Available columns: ${availableCols || 'none'}</div>`;
          return;
        }

        // Group data by address, storing original row index with each row
        const addressMap = new Map();
        data.forEach((row, rowIndex) => {
          const address = getAddressString(row);
          if (!address) return;
          
          if (!addressMap.has(address)) {
            addressMap.set(address, []);
          }
          // Store row with its original index
          addressMap.get(address).push({ ...row, __originalIndex: rowIndex });
        });

        // Store data globally
        sheetData = { headers, data, addressMap, addressCol, houseNumCol, streetCol, getAddressString };
        
        // Re-initialize Contact List Creator if user is on Tools view and data just loaded
        if (currentView === 'tools') {
          setTimeout(() => {
            initializeContactListCreator();
          }, 100);
        }
        
        // Update header with Zone information
        const zoneCol = headers.find(h => h.toLowerCase().includes('zone'));
        // Store sheet ID for writing (sheetInfo already defined above)
        if (sheetInfo) {
          currentSheetId = sheetInfo.sheetId;
        }
        
        // Update sheet link label after successful load
        updateSheetLinkLabel();
        updateHeaderTitle();
        updateNavigationState();
        
        // Update sign-in UI
        updateSignInUI();
        
        // Reset filters when loading new data
        currentStreetFilter = 'all';
        currentDamageFilter = 'all';
        currentStatusFilter = 'all';
        currentCaptainFilter = 'all';
        
        // Extract zone name from ZoneName column if available
        const zoneNameCol = headers.find(h => h.toLowerCase() === 'zonename' || h.toLowerCase() === 'zone name');
        if (zoneNameCol && data.length > 0 && data[0][zoneNameCol]) {
          currentZoneName = data[0][zoneNameCol].trim();
        } else {
          currentZoneName = '';
        }
        updateHeaderTitle();
        
        // If an address was selected, restore that view; otherwise show list
        if (selectedAddress && addressMap.has(selectedAddress)) {
          displayAddressDetails(selectedAddress, true); // true = preserve scroll
        } else {
          displayAddressList(Array.from(addressMap.keys()).sort());
          // Restore scroll position for list view
          setTimeout(() => {
            addressPanelContent.scrollTop = savedScrollPosition;
          }, 0);
        }
        
        // Populate persistent filter bar
        populateFilterBar();
        
        // Update table view if in people view
        if (currentView === 'people') {
          displayAddressTable();
        }
        
        // Update zone progress charts
        updateZoneProgressCharts();
        
        // Initialize or update map with addresses
        // Initialize map but don't update markers yet if map view isn't active
        initializeMap();
        
        // Only update map markers if we're currently on the map view
        if (currentView === 'map') {
          // Wait for map to be properly sized
          setTimeout(() => {
            if (zoneMap) {
              const mapDiv = document.getElementById('zoneMap');
              if (mapDiv && mapDiv.offsetParent !== null) {
                zoneMap.invalidateSize();
                setTimeout(() => {
                  updateMapMarkers();
                }, 100);
              }
            }
          }, 200);
        }
        
        // Only switch to home view if no view is set (initial load without saved view)
        // Don't override saved view - let the user stay on their chosen view
        if (!currentView) {
          switchView('home');
        }
        updateHomeDashboard();
        
        // If we're on map view, ensure color filter control exists and is restored
        if (currentView === 'map') {
          // Ensure watchdog is running
          startColorFilterWatchdog();
          
          setTimeout(() => {
            if (zoneMap) {
              // Always ensure color filter control exists after data loads
              ensureColorFilterControl();
              
              zoneMap.invalidateSize();
              setTimeout(() => {
                updateMapMarkers();
                // Restore color mode after control is ensured to exist
                restoreColorMode();
                
                // Final check after everything settles - ensure control is still there
                setTimeout(() => {
                  if (currentView === 'map' && zoneMap) {
                    ensureColorFilterControl();
                  }
                }, 500);
              }, 150);
            }
          }, 500); // Increased delay to ensure map container is fully visible
        }
        
      } catch (error) {
        console.error('Error loading spreadsheet:', error);
        const errorMsg = error.message || 'Unknown error';
        
        // Hide zone progress panel on error
        const panel = document.getElementById('zoneProgressPanel');
        if (panel) panel.style.display = 'none';
        
        let helpText = '';
        if (errorMsg.includes('permission') || errorMsg.includes('does not have permission') || errorMsg.includes('sign in')) {
          helpText = `<br><br><strong>Solution:</strong><br>
            1. Click "Sign in with Google" above<br>
            2. Grant permission to access Google Sheets<br>
            3. Make sure you have access to the sheet (it should be shared with you or set to "Anyone with the link can edit")<br>
            4. Refresh and try again`;
        } else {
          helpText = `<br><br>Tips:<br> Sign in with Google to view and edit data<br> Make sure the sheet is shared with you or set to "Anyone with the link can edit"<br> Make sure the sheet has an "Address" column`;
        }
        
        addressPanelContent.innerHTML = `<div class="error">Error loading spreadsheet: ${errorMsg}${helpText}</div>`;
      }
    }

    // Normalize street name by removing unit numbers, suffixes, and other variations
    function normalizeStreet(street) {
      if (!street) return '';
      
      let normalized = street.trim();
      
      // Remove common unit indicators and everything after them
      // Patterns like: "Madison Ave Unit", "Madison Ave Apt B", "Madison Ave #2", etc.
      const unitPatterns = [
        /\s+(Unit|Apt|Apartment|Suite|Ste|#|No\.|Number)\s+.*$/i,
        /\s+(Unit|Apt|Apartment|Suite|Ste)\s*$/i,
        /\s+#\s*\d+.*$/i,
        /\s+\d+[A-Z]?\s*$/, // Trailing numbers/letters like "123" or "B"
      ];
      
      for (const pattern of unitPatterns) {
        normalized = normalized.replace(pattern, '');
      }
      
      // Remove common directional/location suffixes
      // Patterns like: "Madison Ave Rear", "Maple Street Front", etc.
      const suffixPatterns = [
        /\s+(Rear|Front|Back|Side|North|South|East|West|N|S|E|W)\s*$/i,
        /\s+[A-Z]\s*$/, // Single letter suffix like "B" or "A"
      ];
      
      for (const pattern of suffixPatterns) {
        normalized = normalized.replace(pattern, '');
      }
      
      // Clean up extra whitespace
      normalized = normalized.trim();
      
      return normalized;
    }

    // Extract street name from full address
    function extractStreet(address) {
      let street = '';
      
      // Use Street column if available (preferred method)
      if (sheetData && sheetData.streetCol && sheetData.addressMap && sheetData.addressMap.has(address)) {
        const rows = sheetData.addressMap.get(address);
        if (rows && rows.length > 0 && rows[0][sheetData.streetCol]) {
          street = rows[0][sheetData.streetCol].trim();
        }
      }
      
      // Fallback: try to extract from address string (e.g., "2054 MADISON AVE" -> "MADISON AVE")
      if (!street) {
        const parts = address.split(/\s+/);
        if (parts.length > 1) {
          street = parts.slice(1).join(' '); // Everything after the first part (house number)
        } else {
          street = address;
        }
      }
      
      // Normalize the street name to handle units, suffixes, etc.
      return normalizeStreet(street);
    }

    // Sort rebuild statuses in sequential order (known stages first, then custom values alphabetically)
    function sortRebuildStatusesSequential(statuses) {
      const sequential = [];
      const custom = [];
      
      // First, add known sequential stages that exist in the data
      REBUILD_STAGES_SEQUENTIAL.forEach(stage => {
        if (statuses.some(s => s.toLowerCase().trim() === stage.toLowerCase().trim())) {
          // Find the exact match (preserving original case from data)
          const match = statuses.find(s => s.toLowerCase().trim() === stage.toLowerCase().trim());
          if (match) sequential.push(match);
        }
      });
      
      // Then add any custom statuses that aren't in the sequential list, sorted alphabetically
      statuses.forEach(status => {
        const statusLower = status.toLowerCase().trim();
        const isInSequential = REBUILD_STAGES_SEQUENTIAL.some(stage => 
          stage.toLowerCase().trim() === statusLower
        );
        if (!isInSequential) {
          custom.push(status);
        }
      });
      custom.sort();
      
      return [...sequential, ...custom];
    }
    
    // Get unique streets from all addresses
    function getUniqueStreets(addresses) {
      const streets = new Set();
      addresses.forEach(addr => {
        const street = extractStreet(addr);
        if (street) streets.add(street);
      });
      return Array.from(streets).sort();
    }

    // Get unique damage values from all addresses
    function getUniqueDamage(addresses) {
      const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
      if (!damageCol) return [];
      
      const damages = new Set();
      // Check all data, not just filtered addresses
      sheetData.data.forEach(row => {
        if (row[damageCol] !== undefined && row[damageCol] !== null) {
          const damage = String(row[damageCol]).trim();
          if (damage) damages.add(damage);
        }
      });
      
      // Always include default values (even if not in data yet)
      const defaultDamageValues = ['Total Loss', 'Partial Loss', 'Standing'];
      defaultDamageValues.forEach(val => {
        // Check if this value exists (case-insensitive)
        const existing = Array.from(damages).find(d => d.toLowerCase() === val.toLowerCase());
        if (existing && existing !== val) {
          // Replace with exact case from defaults
          damages.delete(existing);
        }
        damages.add(val);
      });
      
      return Array.from(damages).sort();
    }

    // Get unique household status values from all addresses
    function getUniqueStatus(addresses) {
      const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
      if (!statusCol) return [];
      
      const statuses = new Set();
      // Check all data, not just filtered addresses
      sheetData.data.forEach(row => {
        if (row[statusCol] !== undefined && row[statusCol] !== null) {
          const status = String(row[statusCol]).trim();
          if (status) statuses.add(status);
        }
      });
      
      // Always include default values (even if not in data yet)
      const defaultStatusValues = ['Rebuilding', 'Selling', 'Renter/Moved', 'Staying'];
      defaultStatusValues.forEach(val => {
        // Check if this value exists (case-insensitive)
        const existing = Array.from(statuses).find(s => s.toLowerCase() === val.toLowerCase());
        if (existing && existing !== val) {
          // Replace with exact case from defaults
          statuses.delete(existing);
        }
        statuses.add(val);
      });
      
      return Array.from(statuses).sort();
    }

    // Parse multiple captains from semicolon-separated values in NC Name, NC Phone, NC Email columns
    function parseCaptains(ncName, ncPhone, ncEmail) {
      if (!ncName || !ncName.trim()) {
        return [];
      }
      
      // Split each field by semicolon and trim whitespace
      const names = (ncName || '').split(';').map(s => s.trim()).filter(s => s);
      const phones = (ncPhone || '').split(';').map(s => s.trim()).filter(s => s);
      const emails = (ncEmail || '').split(';').map(s => s.trim()).filter(s => s);
      
      // Find the maximum count to handle mismatched counts gracefully
      const maxCount = Math.max(names.length, phones.length, emails.length);
      
      // Match up by position: name[0] with phone[0] and email[0], etc.
      const captains = [];
      for (let i = 0; i < maxCount; i++) {
        captains.push({
          name: names[i] || 'N/A',
          phone: phones[i] || 'N/A',
          email: emails[i] || 'N/A'
        });
      }
      
      return captains;
    }

    // Check if an address has any contacted people
    function isAddressContacted(address) {
      const contactDateCol = sheetData.headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));
      if (!contactDateCol) return false;
      
      const rows = sheetData.addressMap.get(address);
      if (!rows || rows.length === 0) return false;
      
      // Check if any person at this address has a contact date
      return rows.some(row => {
        const contactDate = row[contactDateCol];
        return contactDate !== undefined && contactDate !== null && String(contactDate).trim() !== '';
      });
    }

    // Check if an address needs follow-up
    function isAddressNeedsFollowup(address) {
      const rows = sheetData.addressMap.get(address);
      if (!rows || rows.length === 0) return false;
      
      // Check for columns that might indicate needs follow-up
      return rows.some(row => {
        return Object.keys(row).some(col => {
          const lowerCol = col.toLowerCase();
          const lowerValue = String(row[col] || '').toLowerCase().trim();
          
          // Check if column name or value contains "needs follow-up", "follow-up", "follow up", etc.
          if (lowerCol.includes('follow') || lowerCol.includes('followup') || lowerCol.includes('follow-up')) {
            // If column name indicates follow-up, check if value is positive
            return lowerValue === 'yes' || lowerValue === 'true' || lowerValue === '1' || 
                   (lowerValue !== '' && lowerValue !== 'no' && lowerValue !== 'false' && lowerValue !== '0');
          }
          // Check if value itself indicates needs follow-up
          if (lowerValue.includes('needs follow-up') || lowerValue.includes('follow-up needed') || 
              lowerValue.includes('needs followup') || lowerValue === 'follow-up') {
            return true;
          }
          return false;
        });
      });
    }

    // Check if an address is a renter
    function isAddressRenter(address) {
      const rows = sheetData.addressMap.get(address);
      if (!rows || rows.length === 0) return false;
      
      // First, check Household Status column specifically (most reliable)
      const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
      if (statusCol) {
        const hasRenterStatus = rows.some(row => {
          const statusValue = String(row[statusCol] || '').toLowerCase().trim();
          // Check for common renter status values
          return statusValue.includes('renter') || statusValue.includes('rent') || 
                 statusValue === 'r' || statusValue.includes('rental') || 
                 statusValue.includes('tenant');
        });
        if (hasRenterStatus) return true;
      }
      
      // Also check other columns that might indicate renter status
      return rows.some(row => {
        return Object.keys(row).some(col => {
          const lowerCol = col.toLowerCase();
          const lowerValue = String(row[col] || '').toLowerCase().trim();
          
          // Skip household status column (already checked above)
          if (lowerCol.includes('household status')) return false;
          
          // Check if column name or value contains "renter", "rent", "tenant", "own/rent", etc.
          if (lowerCol.includes('renter') || lowerCol.includes('rent') || lowerCol.includes('tenant') || 
              lowerCol.includes('own/rent') || lowerCol.includes('ownership')) {
            // If column name indicates renter/rent, check if value is positive
            if (lowerValue && lowerValue !== 'no' && lowerValue !== 'false' && lowerValue !== '0') {
              return lowerValue.includes('rent') || lowerValue.includes('renter') || 
                     lowerValue.includes('tenant') || lowerValue === 'r' || lowerValue === 'rental' ||
                     lowerValue === 'yes' || lowerValue === 'true' || lowerValue === '1';
            }
          }
          // Check if value itself indicates renter (anywhere in the data)
          if (lowerValue && (lowerValue.includes('renter') || lowerValue.includes('rent') || 
                             lowerValue === 'rental' || lowerValue.includes('tenant') || lowerValue === 'r')) {
            return true;
          }
          return false;
        });
      });
    }

    // Get damage value for an address
    function getAddressDamage(address) {
      const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
      if (!damageCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        return rows[0][damageCol]?.trim() || null;
      }
      return null;
    }

    // Get household status value for an address
    function getAddressStatus(address) {
      const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
      if (!statusCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        return rows[0][statusCol]?.trim() || null;
      }
      return null;
    }

    // Calculate quick actions based on spreadsheet data
    function calculateQuickActions() {
      if (!sheetData || !sheetData.addressMap) {
        return {
          uncontactedCount: 0,
          noDamageStatusCount: 0,
          followupPeople: []
        };
      }

      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      
      // Find contact columns (same logic as Zone Overview)
      const contactStatusCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('contact status');
      });
      const contactDateCol = headers.find(h => {
        const lower = h.toLowerCase();
        return (lower.includes('contact') && lower.includes('date')) ||
               lower.includes('last contact');
      });
      
      // Find follow-up column
      const followupCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('follow') && (lower.includes('up') || lower.includes('-up'));
      });
      
      // Find resident name column (same pattern as displayAddressDetails)
      const nameCol = headers.find(h => 
        h.toLowerCase().includes('resident name') || 
        (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name') && 
         !h.toLowerCase().includes('first') && !h.toLowerCase().includes('last') && 
         !h.toLowerCase().includes('middle'))
      );
      
      let uncontactedCount = 0;
      let noDamageStatusCount = 0;
      const followupPeople = [];

      addressMap.forEach((rows, address) => {
        // Count uncontacted addresses using exact same logic as Zone Overview
        const row = rows[0];
        let isContacted = false;
        
        if (contactStatusCol && row[contactStatusCol]) {
          const status = String(row[contactStatusCol]).toLowerCase().trim();
          isContacted = status && !status.includes('uncontacted') && status !== 'no';
        } else if (contactDateCol && row[contactDateCol]) {
          const date = String(row[contactDateCol]).trim();
          isContacted = date.length > 0;
        }
        
        if (!isContacted) {
          uncontactedCount++;
        }

        // Count addresses with no damage status
        const damage = getAddressDamage(address);
        if (!damage || damage.trim() === '' || damage === '(not set)') {
          noDamageStatusCount++;
        }
        
        // Find people who need follow-up
        if (followupCol) {
          rows.forEach((personRow) => {
            const followupValue = (personRow[followupCol] || '').toString().trim();
            const followupValueLower = followupValue.toLowerCase();
            const isFollowupChecked = followupValueLower === 'true' || followupValue === 'TRUE' || 
                                     followupValueLower === 'yes' || 
                                     (followupValue !== '' && followupValueLower !== 'false' && 
                                      followupValue !== 'FALSE' && followupValueLower !== 'no');
            
            if (isFollowupChecked) {
              const personName = nameCol ? (personRow[nameCol] || '').trim() : '';
              if (personName) {
                followupPeople.push({
                  name: personName,
                  address: address
                });
              }
            }
          });
        }
      });

      return {
        uncontactedCount,
        noDamageStatusCount,
        followupPeople
      };
    }

    // Navigate to uncontacted addresses view
    function navigateToUncontactedAddresses() {
      // Reset all filters first
      currentStreetFilter = 'all';
      currentDamageFilter = 'all';
      currentStatusFilter = 'all';
      currentRebuildFilter = 'all';
      currentCaptainFilter = 'all';
      // Set contact filters
      showUncontactedAddresses = true;
      showContactedAddresses = false;
      switchView('people');
      populateFilterBar();
      displayAddressTable();
    }

    // Navigate to addresses without damage status view
    function navigateToAddressesWithoutDamageStatus() {
      // Reset all filters first
      currentStreetFilter = 'all';
      currentDamageFilter = ''; // Empty string for "(not set)"
      currentStatusFilter = 'all';
      currentRebuildFilter = 'all';
      currentCaptainFilter = 'all';
      // Reset contact filters to show all
      showUncontactedAddresses = true;
      showContactedAddresses = true;
      switchView('people');
      populateFilterBar();
      displayAddressTable();
    }

    // Navigate to a specific address and select it
    function navigateToAddress(address) {
      // Reset all filters
      currentStreetFilter = 'all';
      currentDamageFilter = 'all';
      currentStatusFilter = 'all';
      currentRebuildFilter = 'all';
      currentCaptainFilter = 'all';
      showUncontactedAddresses = true;
      showContactedAddresses = true;
      switchView('people');
      populateFilterBar();
      displayAddressTable();
      // Select the address after a short delay to ensure the table is rendered
      setTimeout(() => {
        displayAddressDetails(address);
      }, 100);
    }

    // Display quick actions panel
    function displayQuickActions() {
      const content = document.getElementById('quickActionsContent');
      if (!content) return;

      if (!sheetData || !sheetData.addressMap) {
        content.innerHTML = '<div class="loading">Loading quick actions...</div>';
        return;
      }

      const actions = calculateQuickActions();
      let html = '';
      let hasActions = false;

      // Uncontacted addresses action
      if (actions.uncontactedCount > 0) {
        hasActions = true;
        html += `
          <div class="quick-action-item">
            <div class="quick-action-text">
              There are <strong>${actions.uncontactedCount}</strong> address${actions.uncontactedCount !== 1 ? 'es' : ''} you haven't contacted. Contact 3 of them right now.
            </div>
            <div class="quick-action-links">
              <a href="#" class="quick-action-link" id="showUncontactedLink">see uncontacted addresses</a>
              <a href="https://docs.google.com/document/d/1hP1N5eXjddsZfFj9GQHjIokVfAvf_Ir4gcb7bVSOFRI/view" target="_blank" rel="noopener noreferrer" class="quick-action-link">sample script</a>
            </div>
          </div>
        `;
      }

      // Missing damage status action
      if (actions.noDamageStatusCount > 0) {
        hasActions = true;
        html += `
          <div class="quick-action-item">
            <div class="quick-action-text">
              There are <strong>${actions.noDamageStatusCount}</strong> address${actions.noDamageStatusCount !== 1 ? 'es' : ''} with no Damage Status assigned. Update 5 addresses now.
            </div>
            <div class="quick-action-links">
              <a href="#" class="quick-action-link" id="showNoDamageStatusLink">see addresses without damage status</a>
            </div>
          </div>
        `;
      }

      // Follow-up people action
      if (actions.followupPeople && actions.followupPeople.length > 0) {
        hasActions = true;
        const peopleNames = actions.followupPeople.map((person, index) => {
          return `<a href="#" class="quick-action-link person-link" data-address="${person.address.replace(/"/g, '&quot;')}">${person.name}</a>`;
        }).join(', ');
        
        html += `
          <div class="quick-action-item">
            <div class="quick-action-text">
              You have <strong>${actions.followupPeople.length}</strong> ${actions.followupPeople.length !== 1 ? 'people' : 'person'} who ${actions.followupPeople.length !== 1 ? 'need' : 'needs'} a follow-up. Follow up with 1 of them now.
            </div>
            <div class="quick-action-text" style="margin-top: 8px; font-size: 0.9rem;">
              ${peopleNames}
            </div>
          </div>
        `;
      }

      if (!hasActions) {
        html = '<div class="empty">No quick actions at this time.</div>';
      }

      // Add "More Actions" link at the bottom
      html += `
        <div class="quick-action-more" style="margin-top: 16px; padding-top: 16px; border-top: 2px solid rgba(96, 108, 56, 0.2); text-align: center;">
          <a href="#" class="quick-action-link" id="moreActionsLink" style="font-size: 1rem;">More Actions </a>
        </div>
      `;

      content.innerHTML = html;

      // Add event listeners for navigation links
      const uncontactedLink = document.getElementById('showUncontactedLink');
      if (uncontactedLink) {
        uncontactedLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToUncontactedAddresses();
        });
      }

      const noDamageStatusLink = document.getElementById('showNoDamageStatusLink');
      if (noDamageStatusLink) {
        noDamageStatusLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToAddressesWithoutDamageStatus();
        });
      }

      // Add event listeners for person name links
      document.querySelectorAll('.person-link').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const address = link.getAttribute('data-address');
          if (address) {
            navigateToAddress(address);
          }
        });
      });

      // Add event listener for "More Actions" link
      const moreActionsLink = document.getElementById('moreActionsLink');
      if (moreActionsLink) {
        moreActionsLink.addEventListener('click', (e) => {
          e.preventDefault();
          switchView('meetups');
        });
      }
    }

    // Display quick actions on Actions page
    function displayActionsPage() {
      const content = document.getElementById('actionsPageContent');
      if (!content) return;

      if (!sheetData || !sheetData.addressMap) {
        content.innerHTML = '<div class="loading">Loading actions...</div>';
        return;
      }

      const actions = calculateQuickActions();
      let html = '';
      let hasActions = false;

      // Uncontacted addresses action
      if (actions.uncontactedCount > 0) {
        hasActions = true;
        html += `
          <div class="action-card">
            <div class="action-card-title">Contact Uncontacted Addresses</div>
            <div class="action-card-content">
              There are <strong>${actions.uncontactedCount}</strong> address${actions.uncontactedCount !== 1 ? 'es' : ''} you haven't contacted. Contact 3 of them right now.
            </div>
            <div class="action-card-links">
              <a href="#" class="action-card-link" id="actionsPageUncontactedLink">see uncontacted addresses</a>
              <a href="https://docs.google.com/document/d/1hP1N5eXjddsZfFj9GQHjIokVfAvf_Ir4gcb7bVSOFRI/view" target="_blank" rel="noopener noreferrer" class="action-card-link">sample script</a>
            </div>
          </div>
        `;
      }

      // Missing damage status action
      if (actions.noDamageStatusCount > 0) {
        hasActions = true;
        html += `
          <div class="action-card">
            <div class="action-card-title">Update Damage Status</div>
            <div class="action-card-content">
              There are <strong>${actions.noDamageStatusCount}</strong> address${actions.noDamageStatusCount !== 1 ? 'es' : ''} with no Damage Status assigned. Update 5 addresses now.
            </div>
            <div class="action-card-links">
              <a href="#" class="action-card-link" id="actionsPageNoDamageStatusLink">see addresses without damage status</a>
            </div>
          </div>
        `;
      }

      // Follow-up people action
      if (actions.followupPeople && actions.followupPeople.length > 0) {
        hasActions = true;
        const peopleNames = actions.followupPeople.map((person, index) => {
          return `<a href="#" class="action-card-link person-link-actions" data-address="${person.address.replace(/"/g, '&quot;')}">${person.name}</a>`;
        }).join(', ');
        
        html += `
          <div class="action-card">
            <div class="action-card-title">Follow-up Needed</div>
            <div class="action-card-content">
              You have <strong>${actions.followupPeople.length}</strong> ${actions.followupPeople.length !== 1 ? 'people' : 'person'} who ${actions.followupPeople.length !== 1 ? 'need' : 'needs'} a follow-up. Follow up with 1 of them now.
            </div>
            <div class="action-card-people-list">
              ${peopleNames}
            </div>
          </div>
        `;
      }

      // Share Altagether Newsletter action (always shown)
      hasActions = true;
      html += `
        <div class="action-card">
          <div class="action-card-title">Share Altagether Newsletter</div>
          <div class="action-card-content">
            Share the latest Altagether newsletter with your neighbors. Get a list of email addresses from your spreadsheet and share the newsletter link.
          </div>
          <div class="action-card-links">
            <a href="#" class="action-card-link" id="shareNewsletterLink">get email addresses</a>
            <a href="https://altagether.org/newsletter" target="_blank" rel="noopener noreferrer" class="action-card-link">view newsletter</a>
          </div>
        </div>
      `;

      if (!hasActions) {
        html = '<div class="empty">No actions available at this time.</div>';
      } else {
        html = `<div class="actions-page-container">${html}</div>`;
      }

      content.innerHTML = html;

      // Add event listeners for navigation links
      const uncontactedLink = document.getElementById('actionsPageUncontactedLink');
      if (uncontactedLink) {
        uncontactedLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToUncontactedAddresses();
        });
      }

      const noDamageStatusLink = document.getElementById('actionsPageNoDamageStatusLink');
      if (noDamageStatusLink) {
        noDamageStatusLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToAddressesWithoutDamageStatus();
        });
      }

      // Add event listeners for person name links
      document.querySelectorAll('.person-link-actions').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const address = link.getAttribute('data-address');
          if (address) {
            navigateToAddress(address);
          }
        });
      });

      // Add event listener for Share Newsletter link
      const shareNewsletterLink = document.getElementById('shareNewsletterLink');
      if (shareNewsletterLink) {
        shareNewsletterLink.addEventListener('click', (e) => {
          e.preventDefault();
          showNewsletterEmailGuide();
        });
      }
    }

    // Show newsletter email guide modal
    function showNewsletterEmailGuide() {
      if (!sheetData || !sheetData.addressMap) {
        alert('Please load your spreadsheet first to extract email addresses.');
        return;
      }

      // Find email column
      const headers = sheetData.headers;
      const emailCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('email address') || (lower.includes('email') && !lower.includes('nc email'));
      });

      if (!emailCol) {
        alert('No email address column found in your spreadsheet. Please make sure you have a column with "Email" or "Email Address" in the name.');
        return;
      }

      // Extract unique email addresses
      const emailSet = new Set();
      sheetData.data.forEach(row => {
        const email = (row[emailCol] || '').trim();
        if (email && email.includes('@')) {
          // Basic email validation
          emailSet.add(email.toLowerCase());
        }
      });

      const emails = Array.from(emailSet).sort();
      const emailCount = emails.length;

      if (emailCount === 0) {
        alert('No email addresses found in your spreadsheet. Please make sure the email column contains valid email addresses.');
        return;
      }

      // Create modal HTML
      const modalHTML = `
        <div class="newsletter-modal-overlay" id="newsletterModalOverlay">
          <div class="newsletter-modal">
            <button class="newsletter-modal-close" id="newsletterModalClose">&times;</button>
            <div class="newsletter-modal-header">
              <h3 class="newsletter-modal-title">Share Altagether Newsletter</h3>
              <p class="newsletter-modal-subtitle">Get email addresses and share the latest newsletter with your neighbors</p>
            </div>
            <div class="newsletter-modal-content">
              <div class="newsletter-modal-section">
                <h4 class="newsletter-modal-section-title">Step 1: Copy Email Addresses</h4>
                <div class="newsletter-modal-instructions">
                  <p>We found <strong>${emailCount}</strong> unique email address${emailCount !== 1 ? 'es' : ''} in your spreadsheet. Copy them below:</p>
                </div>
                <div class="newsletter-email-count">${emailCount} email address${emailCount !== 1 ? 'es' : ''} found</div>
                <div class="newsletter-email-list" id="newsletterEmailList">${emails.join(', ')}</div>
              </div>
              <div class="newsletter-modal-section">
                <h4 class="newsletter-modal-section-title">Step 2: Share the Newsletter</h4>
                <div class="newsletter-modal-instructions">
                  <ol>
                    <li>Copy the email addresses above (click the "Copy All Emails" button)</li>
                    <li>Open your email client (Gmail, Outlook, etc.)</li>
                    <li>Paste the email addresses into the "To" field</li>
                    <li>Click the "View Newsletter" button below to get the latest newsletter link</li>
                    <li>Share the newsletter link: <strong>https://altagether.org/newsletter</strong></li>
                  </ol>
                </div>
              </div>
            </div>
            <div class="newsletter-modal-actions">
              <button class="btn-copy-emails" id="copyEmailsBtn">Copy All Emails</button>
              <a href="https://altagether.org/newsletter" target="_blank" rel="noopener noreferrer" class="btn-newsletter-link">View Newsletter</a>
            </div>
          </div>
        </div>
      `;

      // Remove existing modal if any
      const existingModal = document.getElementById('newsletterModalOverlay');
      if (existingModal) {
        existingModal.remove();
      }

      // Add modal to page
      document.body.insertAdjacentHTML('beforeend', modalHTML);

      // Add event listeners
      const modalOverlay = document.getElementById('newsletterModalOverlay');
      const closeBtn = document.getElementById('newsletterModalClose');
      const copyBtn = document.getElementById('copyEmailsBtn');

      // Close on overlay click
      modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) {
          modalOverlay.remove();
        }
      });

      // Close on close button click
      closeBtn.addEventListener('click', () => {
        modalOverlay.remove();
      });

      // Copy emails button
      copyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(emails.join(', '));
          copyBtn.textContent = ' Copied!';
          copyBtn.style.background = 'linear-gradient(135deg, #4caf50 0%, #388e3c 100%)';
          setTimeout(() => {
            copyBtn.textContent = 'Copy All Emails';
            copyBtn.style.background = 'linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%)';
          }, 2000);
        } catch (err) {
          // Fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = emails.join(', ');
          textArea.style.position = 'fixed';
          textArea.style.opacity = '0';
          document.body.appendChild(textArea);
          textArea.select();
          try {
            document.execCommand('copy');
            copyBtn.textContent = ' Copied!';
            copyBtn.style.background = 'linear-gradient(135deg, #4caf50 0%, #388e3c 100%)';
            setTimeout(() => {
              copyBtn.textContent = 'Copy All Emails';
              copyBtn.style.background = 'linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%)';
            }, 2000);
          } catch (fallbackErr) {
            alert('Failed to copy. Please manually select and copy the email addresses.');
          }
          document.body.removeChild(textArea);
        }
      });

      // Close on Escape key
      document.addEventListener('keydown', function escapeHandler(e) {
        if (e.key === 'Escape' && modalOverlay && document.body.contains(modalOverlay)) {
          modalOverlay.remove();
          document.removeEventListener('keydown', escapeHandler);
        }
      });
    }

    // Display list of addresses
    // Helper function to adjust content views for filter bar
    function adjustContentViewsForFilterBar() {
      const filterBar = document.getElementById('filterBar');
      const shouldShowFilters = (currentView === 'people' || currentView === 'map');
      
      if (shouldShowFilters && filterBar && filterBar.style.display !== 'none') {
        // Force a layout recalculation by accessing offsetHeight
        const forceLayout = filterBar.offsetHeight;
        
        // Get the filter bar's bounding rectangle for accurate position
        const filterBarRect = filterBar.getBoundingClientRect();
        const filterBarTop = filterBarRect.top;
        const filterBarHeight = filterBarRect.height;
        // Add a small buffer (2px) to ensure no overlap
        const filterBarOffset = filterBarTop + filterBarHeight + 2;
        
        // Apply offset to content views
        // Both filter bar and app-container start at same viewport position (56px or 96px)
        // Filter bar is fixed, content views are absolute within app-container
        // Since they start at the same point, we just need filter bar height
        const offset = filterBarRect.height + 2; // +2px buffer to prevent any overlap
        
        document.querySelectorAll('.content-view').forEach(view => {
          if (view.id === 'peopleView' || view.id === 'mapView') {
            view.style.top = offset + 'px';
          }
        });
        
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
          mapContainer.style.top = offset + 'px';
        }
      } else {
        // No filter bar, content views start at top - reset padding
        document.querySelectorAll('.content-view').forEach(view => {
          if (view.id === 'peopleView' || view.id === 'mapView') {
            view.style.top = '0';
            view.style.paddingTop = '32px'; // Reset to default padding
          }
        });
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
          mapContainer.style.top = '0';
        }
      }
    }
    
    // Populate persistent filter bar
    function populateFilterBar() {
      if (!sheetData || !sheetData.addressMap) {
        const filterBar = document.getElementById('filterBar');
        if (filterBar) filterBar.style.display = 'none';
        return;
      }

      const filterBar = document.getElementById('filterBar');
      const filterBarContent = document.getElementById('filterBarContent');
      if (!filterBar || !filterBarContent) return;

      const addresses = Array.from(sheetData.addressMap.keys());
      const headers = sheetData.headers;
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const rebuildCol = headers.find(h => h.toLowerCase().includes('rebuild'));
      const contactDateCol = headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));

      const streets = getUniqueStreets(addresses);
      const damages = getUniqueDamage(addresses);
      const statuses = getUniqueStatus(addresses);

      // Get unique rebuild status values
      const rebuildStatuses = new Set();
      if (rebuildCol) {
        sheetData.data.forEach(row => {
          if (row[rebuildCol] !== undefined && row[rebuildCol] !== null) {
            const value = String(row[rebuildCol]).trim();
            if (value) rebuildStatuses.add(value);
          }
        });
      }
      // Sort rebuild statuses in sequential order, with any custom values at the end
      const rebuildStatusesArray = sortRebuildStatusesSequential(Array.from(rebuildStatuses));
      
      // Check if zone has multiple captains and get captain names for filter
      const ncNameCol = headers.find(h => h.toLowerCase().includes('nc name'));
      const ncPhoneCol = headers.find(h => h.toLowerCase().includes('nc phone'));
      const ncEmailCol = headers.find(h => h.toLowerCase().includes('nc email'));
      const captainAssignedCol = headers.find(h => h.toLowerCase().includes('captain assigned'));
      let hasMultipleCaptains = false;
      let captainNames = [];
      
      if (ncNameCol && sheetData.data && sheetData.data.length > 0 && captainAssignedCol) {
        const firstRow = sheetData.data[0];
        const ncName = firstRow[ncNameCol] ? (firstRow[ncNameCol] || '').trim() : '';
        const ncPhone = ncPhoneCol ? (firstRow[ncPhoneCol] || '').trim() : '';
        const ncEmail = ncEmailCol ? (firstRow[ncEmailCol] || '').trim() : '';
        const captains = parseCaptains(ncName, ncPhone, ncEmail);
        hasMultipleCaptains = captains.length > 1;
        if (hasMultipleCaptains) {
          captainNames = captains.map(c => c.name).filter(n => n !== 'N/A');
        }
      }

      const html = `
        <span class="filters-label">Filters:</span>
        <select id="persistentStreetFilter" class="${currentStreetFilter !== 'all' ? 'filter-active' : ''}">
          <option value="all" ${currentStreetFilter === 'all' ? 'selected' : ''}>All Streets</option>
          ${streets.map(street => `<option value="${street.replace(/"/g, '&quot;')}" ${currentStreetFilter === street ? 'selected' : ''}>${street}</option>`).join('')}
        </select>
        <select id="persistentDamageFilter" class="${currentDamageFilter !== 'all' ? 'filter-active' : ''}">
          <option value="all" ${currentDamageFilter === 'all' ? 'selected' : ''}>All Damage Status</option>
          <option value="" ${currentDamageFilter === '' ? 'selected' : ''}>(not set)</option>
          ${damages.map(damage => `<option value="${damage.replace(/"/g, '&quot;')}" ${currentDamageFilter === damage ? 'selected' : ''}>${damage}</option>`).join('')}
        </select>
        <select id="persistentStatusFilter" class="${currentStatusFilter !== 'all' ? 'filter-active' : ''}">
          <option value="all" ${currentStatusFilter === 'all' ? 'selected' : ''}>All Household Status</option>
          ${statuses.map(status => `<option value="${status.replace(/"/g, '&quot;')}" ${currentStatusFilter === status ? 'selected' : ''}>${status}</option>`).join('')}
        </select>
        ${rebuildCol ? `<select id="persistentRebuildFilter" class="${currentRebuildFilter !== 'all' ? 'filter-active' : ''}">
          <option value="all" ${currentRebuildFilter === 'all' ? 'selected' : ''}>All Rebuild Status</option>
          ${rebuildStatusesArray.map(status => `<option value="${status.replace(/"/g, '&quot;')}" ${currentRebuildFilter === status ? 'selected' : ''}>${status}</option>`).join('')}
        </select>` : ''}
        ${hasMultipleCaptains && captainAssignedCol ? `<select id="persistentCaptainFilter" class="${currentCaptainFilter !== 'all' ? 'filter-active' : ''}">
          <option value="all" ${currentCaptainFilter === 'all' ? 'selected' : ''}>Any Captain</option>
          <option value="" ${currentCaptainFilter === '' ? 'selected' : ''}>(not specified)</option>
          ${captainNames.map(name => `<option value="${escapeHtml(name).replace(/"/g, '&quot;')}" ${currentCaptainFilter === name ? 'selected' : ''}>${escapeHtml(name)}</option>`).join('')}
        </select>` : ''}
        ${contactDateCol ? `
        <div class="contact-filter-group">
          <label class="contact-filter-checkbox">
            <input type="checkbox" id="persistentShowContactedCheckbox" ${showContactedAddresses ? 'checked' : ''}>
            <span>Show contacted addresses</span>
          </label>
          <label class="contact-filter-checkbox">
            <input type="checkbox" id="persistentShowUncontactedCheckbox" ${showUncontactedAddresses ? 'checked' : ''}>
            <span>Show uncontacted addresses</span>
          </label>
        </div>
        ` : ''}
      `;

      filterBarContent.innerHTML = html;
      
      // Only show filter bar if we're on map or people view
      const shouldShowFilters = (currentView === 'people' || currentView === 'map');
      if (shouldShowFilters) {
        filterBar.style.display = 'block';
        // Recalculate content offset after filter bar is populated (height may change)
        // Use multiple timeouts to ensure filter bar has fully rendered and height is accurate
        setTimeout(() => {
          adjustContentViewsForFilterBar();
          // Recalculate again after a bit more time to catch any delayed rendering
          setTimeout(() => {
            adjustContentViewsForFilterBar();
          }, 100);
        }, 50);
      } else {
        filterBar.style.display = 'none';
      }

      // Add event handlers (remove old ones first to avoid duplicates)
      const oldStreetFilter = document.getElementById('persistentStreetFilter');
      if (oldStreetFilter) {
        oldStreetFilter.replaceWith(oldStreetFilter.cloneNode(true));
      }
      const oldDamageFilter = document.getElementById('persistentDamageFilter');
      if (oldDamageFilter) {
        oldDamageFilter.replaceWith(oldDamageFilter.cloneNode(true));
      }
      const oldStatusFilter = document.getElementById('persistentStatusFilter');
      if (oldStatusFilter) {
        oldStatusFilter.replaceWith(oldStatusFilter.cloneNode(true));
      }
      const oldRebuildFilter = document.getElementById('persistentRebuildFilter');
      if (oldRebuildFilter) {
        oldRebuildFilter.replaceWith(oldRebuildFilter.cloneNode(true));
      }
      const oldContactedCheckbox = document.getElementById('persistentShowContactedCheckbox');
      if (oldContactedCheckbox) {
        oldContactedCheckbox.replaceWith(oldContactedCheckbox.cloneNode(true));
      }
      const oldUncontactedCheckbox = document.getElementById('persistentShowUncontactedCheckbox');
      if (oldUncontactedCheckbox) {
        oldUncontactedCheckbox.replaceWith(oldUncontactedCheckbox.cloneNode(true));
      }
      const oldCaptainFilter = document.getElementById('persistentCaptainFilter');
      if (oldCaptainFilter) {
        oldCaptainFilter.replaceWith(oldCaptainFilter.cloneNode(true));
      }
      // Add event handlers
      const streetFilter = document.getElementById('persistentStreetFilter');
      if (streetFilter) {
        streetFilter.addEventListener('change', (e) => {
          currentStreetFilter = e.target.value;
          if (currentStreetFilter !== 'all') {
            streetFilter.classList.add('filter-active');
          } else {
            streetFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const damageFilter = document.getElementById('persistentDamageFilter');
      if (damageFilter) {
        damageFilter.addEventListener('change', (e) => {
          currentDamageFilter = e.target.value;
          if (currentDamageFilter !== 'all') {
            damageFilter.classList.add('filter-active');
          } else {
            damageFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const statusFilter = document.getElementById('persistentStatusFilter');
      if (statusFilter) {
        statusFilter.addEventListener('change', (e) => {
          currentStatusFilter = e.target.value;
          if (currentStatusFilter !== 'all') {
            statusFilter.classList.add('filter-active');
          } else {
            statusFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const rebuildFilter = document.getElementById('persistentRebuildFilter');
      if (rebuildFilter) {
        rebuildFilter.addEventListener('change', (e) => {
          currentRebuildFilter = e.target.value;
          if (currentRebuildFilter !== 'all') {
            rebuildFilter.classList.add('filter-active');
          } else {
            rebuildFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const captainFilter = document.getElementById('persistentCaptainFilter');
      if (captainFilter) {
        captainFilter.addEventListener('change', (e) => {
          currentCaptainFilter = e.target.value;
          if (currentCaptainFilter !== 'all') {
            captainFilter.classList.add('filter-active');
          } else {
            captainFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const showContactedCheckbox = document.getElementById('persistentShowContactedCheckbox');
      if (showContactedCheckbox) {
        showContactedCheckbox.addEventListener('change', (e) => {
          showContactedAddresses = e.target.checked;
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const showUncontactedCheckbox = document.getElementById('persistentShowUncontactedCheckbox');
      if (showUncontactedCheckbox) {
        showUncontactedCheckbox.addEventListener('change', (e) => {
          showUncontactedAddresses = e.target.checked;
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

    }

    // Display address table view for Addresses & People page
    function displayAddressTable() {
      if (!sheetData || !sheetData.addressMap) {
        const tableView = document.getElementById('peopleTableView');
        if (tableView) {
          tableView.innerHTML = '<div class="empty">Load a spreadsheet to see addresses</div>';
        }
        return;
      }
      
      const addresses = Array.from(sheetData.addressMap.keys()).sort();
      const tableView = document.getElementById('peopleTableView');
      if (!tableView) return;
      
      if (addresses.length === 0) {
        tableView.innerHTML = '<div class="empty">No addresses found</div>';
        return;
      }
      
      const headers = sheetData.headers;
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const rebuildCol = headers.find(h => h.toLowerCase().includes('rebuild'));
      const residentNameCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('resident name') || (lower.includes('name') && !lower.includes('first') && !lower.includes('last') && !lower.includes('nc'));
      });
      const ageCol = headers.find(h => h.toLowerCase() === 'age');
      const phoneCol = headers.find(h => h.toLowerCase().includes('phone') && !h.toLowerCase().includes('nc'));
      const emailCol = headers.find(h => h.toLowerCase().includes('email'));
      const contactDateCol = headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));
      
      // Get unique values for filters
      const streets = getUniqueStreets(addresses);
      const damages = getUniqueDamage(addresses);
      const statuses = getUniqueStatus(addresses);
      
      // Get unique rebuild status values
      const rebuildStatuses = new Set();
      if (rebuildCol) {
        sheetData.data.forEach(row => {
          if (row[rebuildCol] !== undefined && row[rebuildCol] !== null) {
            const value = String(row[rebuildCol]).trim();
            if (value) rebuildStatuses.add(value);
          }
        });
      }
      // Sort rebuild statuses in sequential order, with any custom values at the end
      const rebuildStatusesArray = sortRebuildStatusesSequential(Array.from(rebuildStatuses));
      
      // Filter addresses
      const filteredAddresses = addresses.filter(addr => {
        if (currentStreetFilter !== 'all' && extractStreet(addr) !== currentStreetFilter) return false;
        if (currentDamageFilter !== 'all') {
          if (currentDamageFilter === '') {
            // Filter for "(not set)" - addresses with no damage status
            const damage = getAddressDamage(addr);
            if (damage && damage.trim() !== '' && damage !== '(not set)') return false;
          } else {
            if (getAddressDamage(addr) !== currentDamageFilter) return false;
          }
        }
        if (currentStatusFilter !== 'all' && getAddressStatus(addr) !== currentStatusFilter) return false;
        if (currentRebuildFilter !== 'all' && rebuildCol) {
          const rows = sheetData.addressMap.get(addr);
          if (rows && rows[0]) {
            const rebuildValue = (rows[0][rebuildCol] || '').trim();
            if (rebuildValue !== currentRebuildFilter) return false;
          } else {
            return false;
          }
        }
        // Captain assigned filter
        if (currentCaptainFilter !== 'all') {
          const captainAssignedCol = headers.find(h => h.toLowerCase().includes('captain assigned'));
          if (captainAssignedCol) {
            const rows = sheetData.addressMap.get(addr);
            if (rows && rows[0]) {
              const captainValue = (rows[0][captainAssignedCol] || '').trim();
              if (currentCaptainFilter === '') {
                // Filter for "(not specified)" - addresses with no captain assigned
                if (captainValue && captainValue.trim() !== '') return false;
              } else {
                if (captainValue !== currentCaptainFilter) return false;
              }
            } else {
              // No rows for address - check if we're filtering for "(not specified)"
              if (currentCaptainFilter !== '') return false;
            }
          }
        }
        // Contact status filter
        if (contactDateCol) {
          const isContacted = isAddressContacted(addr);
          if (isContacted && !showContactedAddresses) return false;
          if (!isContacted && !showUncontactedAddresses) return false;
        }
        return true;
      });
      
      // Sort addresses if sort column is set
      let sortedAddresses = [...filteredAddresses];
      if (tableSortColumn) {
        sortedAddresses.sort((a, b) => {
          const rowsA = sheetData.addressMap.get(a);
          const rowsB = sheetData.addressMap.get(b);
          let valA = '';
          let valB = '';
          
          if (tableSortColumn === 'address') {
            valA = a;
            valB = b;
          } else if (tableSortColumn === 'residents') {
            const residentsA = rowsA && residentNameCol ? rowsA.filter(r => r[residentNameCol]?.trim()).length : 0;
            const residentsB = rowsB && residentNameCol ? rowsB.filter(r => r[residentNameCol]?.trim()).length : 0;
            valA = residentsA.toString();
            valB = residentsB.toString();
          } else {
            const col = headers.find(h => h.toLowerCase() === tableSortColumn.toLowerCase());
            if (col) {
              valA = rowsA && rowsA[0] ? (rowsA[0][col] || '').toString().trim() : '';
              valB = rowsB && rowsB[0] ? (rowsB[0][col] || '').toString().trim() : '';
            }
          }
          
          const comparison = valA.localeCompare(valB, undefined, { numeric: true, sensitivity: 'base' });
          return tableSortDirection === 'asc' ? comparison : -comparison;
        });
      }
      
      const html = `
        <div class="address-table-container">
          <table class="address-table">
            <thead>
              <tr>
                <th class="sortable" data-sort="address" title="Click to sort">Address ${tableSortColumn === 'address' ? (tableSortDirection === 'asc' ? '' : '') : ''}</th>
                <th class="sortable" data-sort="residents" title="Click to sort">Residents ${tableSortColumn === 'residents' ? (tableSortDirection === 'asc' ? '' : '') : ''}</th>
                ${damageCol ? `<th class="sortable" data-sort="${damageCol.toLowerCase()}" title="Click to sort">Damage ${tableSortColumn === damageCol.toLowerCase() ? (tableSortDirection === 'asc' ? '' : '') : ''}</th>` : ''}
                ${statusCol ? `<th class="sortable" data-sort="${statusCol.toLowerCase()}" title="Click to sort">Household Status ${tableSortColumn === statusCol.toLowerCase() ? (tableSortDirection === 'asc' ? '' : '') : ''}</th>` : ''}
                ${rebuildCol ? `<th class="sortable" data-sort="${rebuildCol.toLowerCase()}" title="Click to sort">Rebuild Status ${tableSortColumn === rebuildCol.toLowerCase() ? (tableSortDirection === 'asc' ? '' : '') : ''}</th>` : ''}
                ${ageCol ? `<th class="sortable" data-sort="${ageCol.toLowerCase()}" title="Click to sort">Age ${tableSortColumn === ageCol.toLowerCase() ? (tableSortDirection === 'asc' ? '' : '') : ''}</th>` : ''}
                ${phoneCol ? `<th>Phone</th>` : ''}
                ${emailCol ? `<th>Email</th>` : ''}
                ${contactDateCol ? `<th class="sortable" data-sort="${contactDateCol.toLowerCase()}" title="Click to sort">Last Contact ${tableSortColumn === contactDateCol.toLowerCase() ? (tableSortDirection === 'asc' ? '' : '') : ''}</th>` : ''}
              </tr>
            </thead>
            <tbody>
              ${sortedAddresses.map(addr => {
                const rows = sheetData.addressMap.get(addr);
                const residents = [];
                if (rows && residentNameCol) {
                  rows.forEach(row => {
                    if (row[residentNameCol] && row[residentNameCol].trim()) {
                      residents.push(row[residentNameCol].trim());
                    }
                  });
                }
                const damage = damageCol && rows && rows[0] ? (rows[0][damageCol] || '').trim() : '';
                const status = statusCol && rows && rows[0] ? (rows[0][statusCol] || '').trim() : '';
                const rebuild = rebuildCol && rows && rows[0] ? (rows[0][rebuildCol] || '').trim() : '';
                const age = ageCol && rows && rows[0] ? (rows[0][ageCol] || '').trim() : '';
                const phone = phoneCol && rows && rows[0] ? (rows[0][phoneCol] || '').trim() : '';
                const email = emailCol && rows && rows[0] ? (rows[0][emailCol] || '').trim() : '';
                const contactDate = contactDateCol && rows && rows[0] ? (rows[0][contactDateCol] || '').trim() : '';
                
                // Format residents with truncation
                let residentsDisplay = '-';
                if (residents.length > 0) {
                  const residentsText = residents.join(', ');
                  const totalCount = residents.length;
                  // If text is long, truncate and show count in parentheses
                  // With expanded column (300px max), allow ~35 chars before truncating
                  if (residentsText.length > 35) {
                    // Truncate to fit column width, leaving space for "... (X Total)" which is ~12-15 chars
                    const truncateTo = Math.max(20, 35 - (totalCount.toString().length + 12));
                    residentsDisplay = residentsText.substring(0, truncateTo) + '... (' + totalCount + ' Total)';
                  } else {
                    residentsDisplay = residentsText;
                  }
                }
                
                return `
                  <tr class="table-address-row" data-address="${addr.replace(/"/g, '&quot;')}">
                    <td title="${addr}">${addr}</td>
                    <td title="${residents.length > 0 ? residents.join(', ') : '-'}">${residentsDisplay}</td>
                    ${damageCol ? `<td>${damage || '-'}</td>` : ''}
                    ${statusCol ? `<td>${status || '-'}</td>` : ''}
                    ${rebuildCol ? `<td>${rebuild || '-'}</td>` : ''}
                    ${ageCol ? `<td>${age || '-'}</td>` : ''}
                    ${phoneCol ? `<td>${phone || '-'}</td>` : ''}
                    ${emailCol ? `<td>${email || '-'}</td>` : ''}
                    ${contactDateCol ? `<td>${contactDate || '-'}</td>` : ''}
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
      `;
      
      tableView.innerHTML = html;
      
      // Add sortable column handlers
      document.querySelectorAll('.sortable').forEach(th => {
        th.style.cursor = 'pointer';
        th.addEventListener('click', () => {
          const sortCol = th.getAttribute('data-sort');
          if (tableSortColumn === sortCol) {
            // Toggle direction if same column
            tableSortDirection = tableSortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            // New column, default to ascending
            tableSortColumn = sortCol;
            tableSortDirection = 'asc';
          }
          displayAddressTable();
        });
      });
      
      // Add row click handlers
      document.querySelectorAll('.table-address-row').forEach(row => {
        row.addEventListener('click', () => {
          const address = row.getAttribute('data-address');
          // Update selected state
          document.querySelectorAll('.table-address-row').forEach(r => r.classList.remove('selected'));
          row.classList.add('selected');
          // Show details in floating panel
          displayAddressDetails(address);
          // Switch to people view if not already
          if (currentView !== 'people') {
            switchView('people');
          }
        });
      });
      
      // Wire up print and export buttons
      setupPrintExportHandlers();
    }
    
    // Setup print and export button handlers
    function setupPrintExportHandlers() {
      const printBtn = document.getElementById('btnPrintAddresses');
      const exportBtn = document.getElementById('btnExportAddresses');
      
      if (printBtn) {
        // Remove existing handler to avoid duplicates
        const newPrintBtn = printBtn.cloneNode(true);
        printBtn.parentNode.replaceChild(newPrintBtn, printBtn);
        newPrintBtn.addEventListener('click', () => printAddresses());
      }
      
      if (exportBtn) {
        // Remove existing handler to avoid duplicates
        const newExportBtn = exportBtn.cloneNode(true);
        exportBtn.parentNode.replaceChild(newExportBtn, exportBtn);
        newExportBtn.addEventListener('click', () => exportAddressesToCSV());
      }
    }
    
    // Get filtered addresses (same logic as displayAddressTable)
    function getFilteredAddresses() {
      if (!sheetData || !sheetData.addressMap) return [];
      
      const addresses = Array.from(sheetData.addressMap.keys()).sort();
      const headers = sheetData.headers;
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const rebuildCol = headers.find(h => h.toLowerCase().includes('rebuild'));
      const contactDateCol = headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));
      const captainAssignedCol = headers.find(h => h.toLowerCase().includes('captain assigned'));
      
      return addresses.filter(addr => {
        if (currentStreetFilter !== 'all' && extractStreet(addr) !== currentStreetFilter) return false;
        if (currentDamageFilter !== 'all') {
          if (currentDamageFilter === '') {
            const damage = getAddressDamage(addr);
            if (damage && damage.trim() !== '' && damage !== '(not set)') return false;
          } else {
            if (getAddressDamage(addr) !== currentDamageFilter) return false;
          }
        }
        if (currentStatusFilter !== 'all' && getAddressStatus(addr) !== currentStatusFilter) return false;
        if (currentRebuildFilter !== 'all' && rebuildCol) {
          const rows = sheetData.addressMap.get(addr);
          if (rows && rows[0]) {
            const rebuildValue = (rows[0][rebuildCol] || '').trim();
            if (rebuildValue !== currentRebuildFilter) return false;
          } else {
            return false;
          }
        }
        if (currentCaptainFilter !== 'all' && captainAssignedCol) {
          const rows = sheetData.addressMap.get(addr);
          if (rows && rows[0]) {
            const captainValue = (rows[0][captainAssignedCol] || '').trim();
            if (currentCaptainFilter === '') {
              if (captainValue && captainValue.trim() !== '') return false;
            } else {
              if (captainValue !== currentCaptainFilter) return false;
            }
          } else {
            if (currentCaptainFilter !== '') return false;
          }
        }
        if (contactDateCol) {
          const isContacted = isAddressContacted(addr);
          if (isContacted && !showContactedAddresses) return false;
          if (!isContacted && !showUncontactedAddresses) return false;
        }
        return true;
      });
    }
    
    // Print addresses with print-friendly formatting
    function printAddresses() {
      const filteredAddresses = getFilteredAddresses();
      if (filteredAddresses.length === 0) {
        alert('No addresses to print. Please adjust your filters.');
        return;
      }
      
      const headers = sheetData.headers;
      const residentNameCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('resident name') || (lower.includes('name') && !lower.includes('first') && !lower.includes('last') && !lower.includes('nc'));
      });
      const phoneCol = headers.find(h => h.toLowerCase().includes('phone') && !h.toLowerCase().includes('nc'));
      const emailCol = headers.find(h => h.toLowerCase().includes('email'));
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const rebuildCol = headers.find(h => h.toLowerCase().includes('rebuild'));
      const contactDateCol = headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));
      
      // Group addresses
      const groupedByAddress = {};
      filteredAddresses.forEach(addr => {
        const rows = sheetData.addressMap.get(addr);
        if (!rows || rows.length === 0) return;
        
        const people = [];
        if (rows && residentNameCol) {
          rows.forEach(row => {
            if (row[residentNameCol] && row[residentNameCol].trim()) {
              const person = {
                name: row[residentNameCol].trim(),
                phone: phoneCol ? (row[phoneCol] || '').trim() : '',
                email: emailCol ? (row[emailCol] || '').trim() : ''
              };
              people.push(person);
            }
          });
        }
        
        const damage = damageCol && rows[0] ? (rows[0][damageCol] || '').trim() : '';
        const status = statusCol && rows[0] ? (rows[0][statusCol] || '').trim() : '';
        const rebuild = rebuildCol && rows[0] ? (rows[0][rebuildCol] || '').trim() : '';
        const contactDate = contactDateCol && rows[0] ? (rows[0][contactDateCol] || '').trim() : '';
        
        groupedByAddress[addr] = {
          people: people,
          damage: damage,
          status: status,
          rebuild: rebuild,
          contactDate: contactDate
        };
      });
      
      // Create print window
      const printWindow = window.open('', '_blank');
      const addressCount = Object.keys(groupedByAddress).length;
      const peopleCount = filteredAddresses.reduce((sum, addr) => {
        return sum + (groupedByAddress[addr]?.people.length || 0);
      }, 0);
      
      let html = `
        <!DOCTYPE html>
        <html>
        <head>
          <title>Addresses & People - ${addressCount} Address${addressCount !== 1 ? 'es' : ''}</title>
          <style>
            @media print {
              @page { margin: 1in; }
            }
            body {
              font-family: 'Alegreya', serif;
              padding: 20px;
              color: #283618;
            }
            h1 {
              color: #283618;
              margin-bottom: 8px;
              font-size: 1.8rem;
            }
            .print-meta {
              color: #606c38;
              font-size: 0.9rem;
              margin-bottom: 24px;
            }
            .address-group {
              page-break-inside: avoid;
              margin-bottom: 24px;
              border: 2px solid #606c38;
              border-radius: 8px;
              overflow: hidden;
            }
            .address-header {
              background: linear-gradient(135deg, #606c38 0%, #283618 100%);
              color: #fefae0;
              padding: 12px 16px;
              font-weight: 700;
              font-size: 1.1rem;
            }
            .address-count {
              font-size: 0.9rem;
              font-weight: 600;
              opacity: 0.9;
            }
            .people-list {
              padding: 16px;
              background: #fff;
            }
            .person-item {
              padding: 12px;
              margin-bottom: 12px;
              background: rgba(96, 108, 56, 0.05);
              border-radius: 6px;
              border-left: 3px solid #606c38;
            }
            .person-name {
              font-weight: 700;
              font-size: 1.05rem;
              color: #283618;
              margin-bottom: 8px;
            }
            .person-detail {
              font-size: 0.95rem;
              margin: 4px 0;
              color: #606c38;
            }
            .person-detail strong {
              color: #283618;
            }
            .address-info {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
              gap: 8px;
              margin-top: 8px;
              padding-top: 8px;
              border-top: 1px solid rgba(96, 108, 56, 0.2);
              font-size: 0.85rem;
              color: #606c38;
            }
          </style>
        </head>
        <body>
          <h1>Addresses & People</h1>
          <div class="print-meta">${peopleCount} contact${peopleCount !== 1 ? 's' : ''} at ${addressCount} address${addressCount !== 1 ? 'es' : ''}</div>
      `;
      
      Object.keys(groupedByAddress).sort().forEach(address => {
        const data = groupedByAddress[address];
        html += `
          <div class="address-group">
            <div class="address-header">
              ${escapeHtml(address)} <span class="address-count">(${data.people.length} ${data.people.length === 1 ? 'person' : 'people'})</span>
            </div>
            <div class="people-list">
        `;
        
        data.people.forEach(person => {
          html += `
            <div class="person-item">
              <div class="person-name">${escapeHtml(person.name)}</div>
              ${person.phone ? `<div class="person-detail"><strong>Phone:</strong> ${escapeHtml(person.phone)}</div>` : ''}
              ${person.email ? `<div class="person-detail"><strong>Email:</strong> ${escapeHtml(person.email)}</div>` : ''}
            </div>
          `;
        });
        
        html += `
              <div class="address-info">
                ${data.damage ? `<div><strong>Damage:</strong> ${escapeHtml(data.damage)}</div>` : ''}
                ${data.status ? `<div><strong>Status:</strong> ${escapeHtml(data.status)}</div>` : ''}
                ${data.rebuild ? `<div><strong>Rebuild:</strong> ${escapeHtml(data.rebuild)}</div>` : ''}
                ${data.contactDate ? `<div><strong>Last Contact:</strong> ${escapeHtml(data.contactDate)}</div>` : ''}
              </div>
            </div>
          </div>
        `;
      });
      
      html += `
        </body>
        </html>
      `;
      
      printWindow.document.write(html);
      printWindow.document.close();
      
      // Wait for content to load before printing
      setTimeout(() => {
        printWindow.print();
      }, 250);
    }
    
    // Export addresses to CSV
    function exportAddressesToCSV() {
      const filteredAddresses = getFilteredAddresses();
      if (filteredAddresses.length === 0) {
        alert('No addresses to export. Please adjust your filters.');
        return;
      }
      
      const headers = sheetData.headers;
      const residentNameCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('resident name') || (lower.includes('name') && !lower.includes('first') && !lower.includes('last') && !lower.includes('nc'));
      });
      const phoneCol = headers.find(h => h.toLowerCase().includes('phone') && !h.toLowerCase().includes('nc'));
      const emailCol = headers.find(h => h.toLowerCase().includes('email'));
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const rebuildCol = headers.find(h => h.toLowerCase().includes('rebuild'));
      const contactDateCol = headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));
      
      // Build CSV headers
      const csvHeaders = ['Address', 'Name'];
      if (phoneCol) csvHeaders.push('Phone');
      if (emailCol) csvHeaders.push('Email');
      if (damageCol) csvHeaders.push('Damage Status');
      if (statusCol) csvHeaders.push('Household Status');
      if (rebuildCol) csvHeaders.push('Rebuild Status');
      if (contactDateCol) csvHeaders.push('Last Contact');
      
      // Build CSV rows
      const csvRows = [];
      filteredAddresses.forEach(addr => {
        const rows = sheetData.addressMap.get(addr);
        if (!rows || rows.length === 0) {
          // Address with no people
          const row = [addr, ''];
          if (phoneCol) row.push('');
          if (emailCol) row.push('');
          if (damageCol) row.push('');
          if (statusCol) row.push('');
          if (rebuildCol) row.push('');
          if (contactDateCol) row.push('');
          csvRows.push(row);
          return;
        }
        
        // One row per person
        rows.forEach((row, index) => {
          const personName = residentNameCol ? (row[residentNameCol] || '').trim() : '';
          // Only include row if person has a name
          if (personName || index === 0) {
            const csvRow = [addr, personName];
            if (phoneCol) csvRow.push(row[phoneCol] || '');
            if (emailCol) csvRow.push(row[emailCol] || '');
            if (damageCol) csvRow.push(index === 0 ? (rows[0][damageCol] || '') : '');
            if (statusCol) csvRow.push(index === 0 ? (rows[0][statusCol] || '') : '');
            if (rebuildCol) csvRow.push(index === 0 ? (rows[0][rebuildCol] || '') : '');
            if (contactDateCol) csvRow.push(row[contactDateCol] || '');
            csvRows.push(csvRow);
          }
        });
      });
      
      // Convert to CSV format
      const escapeCSV = (cell) => {
        const str = String(cell || '');
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
          return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
      };
      
      const csv = [
        csvHeaders.map(escapeCSV).join(','),
        ...csvRows.map(row => row.map(escapeCSV).join(','))
      ].join('\n');
      
      // Download CSV
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `addresses-${Date.now()}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function displayAddressList(addresses) {
      // Clear selected address when showing list
      selectedAddress = null;
      
      if (addresses.length === 0) {
        addressPanelContent.innerHTML = '<div class="empty">No addresses found</div>';
        return;
      }

      // Get unique values for all filters
      const streets = getUniqueStreets(addresses);
      const damages = getUniqueDamage(addresses);
      const statuses = getUniqueStatus(addresses);
      
      // Filter addresses by all selected filters (same logic as displayAddressTable)
      const headers = sheetData.headers;
      const rebuildCol = headers.find(h => h.toLowerCase().includes('rebuild'));
      const contactDateCol = headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));
      
      const filteredAddresses = addresses.filter(addr => {
        // Street filter
        if (currentStreetFilter !== 'all' && extractStreet(addr) !== currentStreetFilter) {
          return false;
        }
        // Damage filter
        if (currentDamageFilter !== 'all') {
          const addrDamage = getAddressDamage(addr);
          if (currentDamageFilter === '') {
            // Filter for "(not set)" - addresses with no damage status
            if (addrDamage && addrDamage.trim() !== '' && addrDamage !== '(not set)') {
              return false;
            }
          } else {
            if (addrDamage !== currentDamageFilter) {
              return false;
            }
          }
        }
        // Status filter
        if (currentStatusFilter !== 'all') {
          const addrStatus = getAddressStatus(addr);
          if (addrStatus !== currentStatusFilter) {
            return false;
          }
        }
        // Rebuild filter
        if (currentRebuildFilter !== 'all' && rebuildCol) {
          const rows = sheetData.addressMap.get(addr);
          if (rows && rows[0]) {
            const rebuildValue = (rows[0][rebuildCol] || '').trim();
            if (rebuildValue !== currentRebuildFilter) return false;
          } else {
            return false;
          }
        }
        // Captain assigned filter
        if (currentCaptainFilter !== 'all') {
          const captainAssignedCol = headers.find(h => h.toLowerCase().includes('captain assigned'));
          if (captainAssignedCol) {
            const rows = sheetData.addressMap.get(addr);
            if (rows && rows[0]) {
              const captainValue = (rows[0][captainAssignedCol] || '').trim();
              if (currentCaptainFilter === '') {
                // Filter for "(not specified)" - addresses with no captain assigned
                if (captainValue && captainValue.trim() !== '') return false;
              } else {
                if (captainValue !== currentCaptainFilter) return false;
              }
            } else {
              // No rows for address - check if we're filtering for "(not specified)"
              if (currentCaptainFilter !== '') return false;
            }
          }
        }
        // Contact status filter
        if (contactDateCol) {
          const isContacted = isAddressContacted(addr);
          if (isContacted && !showContactedAddresses) return false;
          if (!isContacted && !showUncontactedAddresses) return false;
        }
        return true;
      });

      const html = `
        <ul class="address-list">
          ${filteredAddresses.map(addr => `
            <li class="address-item" data-address="${addr.replace(/"/g, '&quot;')}">
              ${addr}
            </li>
          `).join('')}
        </ul>
      `;
      
      addressPanelContent.innerHTML = html;

      // Add click handlers
      document.querySelectorAll('.address-item').forEach(item => {
        item.addEventListener('click', () => {
          const address = item.getAttribute('data-address');
          displayAddressDetails(address);
          
          // Update active state
          document.querySelectorAll('.address-item').forEach(i => i.classList.remove('active'));
          item.classList.add('active');
        });
      });
    }

    // Display details for a specific address
    function displayAddressDetails(address, preserveScroll = false) {
      if (!sheetData.addressMap || !sheetData.addressMap.has(address)) {
        return;
      }

      // Track selected address
      selectedAddress = address;
      
      // Highlight the corresponding marker on the map
      highlightSelectedMarker(address);
      
      // Save scroll position if we're refreshing
      if (preserveScroll) {
        savedScrollPosition = addressPanelContent.scrollTop;
      }

      const rows = sheetData.addressMap.get(address);
      const { headers, addressCol, data } = sheetData;

      // Check if zone has multiple captains (only show Captain Assigned dropdown if so)
      const ncNameCol = headers.find(h => h.toLowerCase().includes('nc name'));
      const ncPhoneCol = headers.find(h => h.toLowerCase().includes('nc phone'));
      const ncEmailCol = headers.find(h => h.toLowerCase().includes('nc email'));
      let hasMultipleCaptains = false;
      let captains = [];
      let captainAssignedCol = null;
      
      if (ncNameCol && data && data.length > 0) {
        const firstRow = data[0];
        const ncName = firstRow[ncNameCol] ? (firstRow[ncNameCol] || '').trim() : '';
        const ncPhone = ncPhoneCol ? (firstRow[ncPhoneCol] || '').trim() : '';
        const ncEmail = ncEmailCol ? (firstRow[ncEmailCol] || '').trim() : '';
        captains = parseCaptains(ncName, ncPhone, ncEmail);
        hasMultipleCaptains = captains.length > 1;
        
        // Find Captain Assigned column if it exists
        captainAssignedCol = headers.find(h => h.toLowerCase().includes('captain assigned'));
      }

      // Find relevant columns (exclude address column itself)
      const detailCols = headers.filter(h => 
        h !== addressCol && 
        h.toLowerCase() !== 'address' &&
        rows.some(row => row[h] && row[h].trim())
      );
      
      // Define which address-level fields to DISPLAY (others are hidden)
      // Note: "address" is excluded since it's shown as the heading
      const addressLevelDisplayFields = [
        'household size',
        'damage',
        'household status',
        'address notes',
        'indoors remediated',
        'soil remediated',
        'rebuild stage',
        'rebuild status'
      ];
      
      // Add Captain Assigned if zone has multiple captains and column exists
      if (hasMultipleCaptains && captainAssignedCol) {
        addressLevelDisplayFields.push('captain assigned');
      }
      
      // Separate address-level and person-level columns
      const addressLevelCols = headers.filter(h => {
        const lower = h.toLowerCase();
        // Explicitly exclude person-level notes and email address
        if (lower.includes('person note')) return false;
        if (lower.includes('email address')) return false;
        // Address-level: fields that are the same for all people at this address
        // But only include if they're in the display list
        const isSameForAll = rows.length > 0 && rows.every(r => (r[h] || '').trim() === (rows[0][h] || '').trim());
        const shouldDisplay = addressLevelDisplayFields.some(field => lower.includes(field));
        return isSameForAll && shouldDisplay;
      });
      
      // Fields to hide from person view
      const hiddenFromPersonView = [
        'house #',
        'street',
        'city',
        'state',
        'zip_code',
        'resident name',
        'zone',
        'nc name',
        'nc email',
        'damage',
        'household status',
        'household size',
        'latitude',
        'longitude',
        'nc phone',
        'first name',
        'middle name',
        'last name',
        'indoors remediated',
        'soil remediated',
        'rebuild stage',
        'rebuild status'
      ];
      
      const personLevelCols = headers.filter(h => {
        const lower = h.toLowerCase();
        // Skip hidden fields
        if (hiddenFromPersonView.some(field => lower.includes(field))) return false;
        // Skip Contact Notes - it's shown separately in contact mode
        if (lower.includes('contact') && lower.includes('note')) return false;
        // Person-level: Person Notes, Person Notes 2, Person Notes 3, or person-specific fields
        return lower.includes('person note') ||
               lower.includes('home phone') ||
               lower.includes('cell') ||
               lower.includes('email address') ||
               lower.includes('gender') ||
               lower.includes('age') ||
               (!addressLevelCols.includes(h) && detailCols.includes(h));
      });
      
      // Find Notes columns separately - always show them if signed in, even if empty
      // Exclude Contact Notes - it's shown separately in contact mode
      const allNotesCols = headers.filter(h => 
        h !== addressCol &&
        h.toLowerCase().includes('note') &&
        !(h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')) &&
        accessToken // Only if signed in
      );
      
      // Add Notes columns to detailCols if not already there
      allNotesCols.forEach(col => {
        if (!detailCols.includes(col)) {
          detailCols.push(col);
        }
      });

      let html = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; gap: 12px;">
          <button class="btn-back" onclick="displayAddressList(Array.from(sheetData.addressMap.keys()).sort())"> Back to List</button>
          ${accessToken ? `
            <div style="display: flex; gap: 6px; align-items: flex-start; position: relative;">
              <div style="display: flex; flex-direction: column; align-items: flex-end; height: 50px; justify-content: flex-start;">
                <div style="display: flex; gap: 6px; align-items: center; margin-bottom: 2px;">
                  <button class="btn-save btn-save-small" id="saveChangesBtnTop" style="margin: 0; align-self: center;">Save Changes</button>
                  <button class="btn-refresh-small" id="refreshBtnTop" title="Refresh addresses now" style="margin: 0;"></button>
                </div>
                <span class="save-status save-status-top" id="saveStatusTop"></span>
              </div>
            </div>
          ` : ''}
        </div>
        <div class="address-details active">
          <h3>${address}</h3>
      `;

      // Collect unique values for dropdown fields from ALL data
      const damageValues = new Set();
      const statusValues = new Set();
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      
      // Default status values (in case not all are found in data)
      const defaultDamageValues = ['Total Loss', 'Partial Loss', 'Standing'];
      const defaultStatusValues = ['Rebuilding', 'Selling', 'Renter/Moved', 'Staying'];
      
      sheetData.data.forEach(row => {
        if (damageCol && row[damageCol] !== undefined && row[damageCol] !== null) {
          const value = String(row[damageCol]).trim();
          if (value) damageValues.add(value);
        }
        if (statusCol && row[statusCol] !== undefined && row[statusCol] !== null) {
          const value = String(row[statusCol]).trim();
          if (value) statusValues.add(value);
        }
      });
      
      // Add default values if they weren't found (ensures all options are available)
      if (damageCol) {
        defaultDamageValues.forEach(val => damageValues.add(val));
      }
      if (statusCol) {
        defaultStatusValues.forEach(val => statusValues.add(val));
      }
      
      console.log('Damage values found:', Array.from(damageValues));
      console.log('Status values found:', Array.from(statusValues));

      // Get damage status to check if remediation fields should be shown
      // Note: damageCol is already declared above, so we'll use it here
      const damageStatus = damageCol && rows[0] ? (rows[0][damageCol] || '').trim() : '';
      const showRemediationFields = damageStatus.toLowerCase() === 'standing' || damageStatus.toLowerCase() === 'partial loss';
      
      // Show address-level fields once at the top (always show, not just when signed in)
      if (addressLevelCols.length > 0) {
        html += '<div class="address-level-section" style="background: rgba(255,255,255,0.7); padding: 12px; border-radius: 6px; margin-bottom: 16px; border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 1px 3px rgba(0,0,0,0.04);">';
        
        addressLevelCols.forEach(col => {
          const firstRowValue = rows[0] ? (rows[0][col] || '') : '';
          const lower = col.toLowerCase();
          const isNotes = lower.includes('note');
          const isDamage = lower.includes('damage');
          const isStatus = lower.includes('household status');
          const isRebuildStage = lower.includes('rebuild stage') || lower.includes('rebuild status');
          const isIndoorsRemediated = lower.includes('indoors remediated');
          const isSoilRemediated = lower.includes('soil remediated');
          const isCaptainAssigned = lower.includes('captain assigned');
          const isEditable = accessToken; // All fields editable when signed in
          
          // Skip remediation fields if damage status doesn't match
          if ((isIndoorsRemediated || isSoilRemediated) && !showRemediationFields) {
            return;
          }
          
          // Skip rebuild status if damage is "Standing"
          if (isRebuildStage && damageStatus.toLowerCase() === 'standing') {
            return;
          }
          
          if (isEditable) {
            if (isNotes) {
              // Notes: expandable textarea
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <textarea class="editable-notes" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-address-level="true"
                     data-column="${col}"
                     data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">${firstRowValue}</textarea>
              </div>`;
            } else if (isDamage || isStatus) {
              // Damage/Status: dropdown
              const options = isDamage ? Array.from(damageValues).sort() : Array.from(statusValues).sort();
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <select class="editable-dropdown" 
                        data-address="${address.replace(/"/g, '&quot;')}" 
                        data-address-level="true"
                        data-column="${col}"
                        data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">
                  <option value="">(not set)</option>
                  ${options.map(opt => `<option value="${opt.replace(/"/g, '&quot;')}" ${opt === firstRowValue ? 'selected' : ''}>${opt}</option>`).join('')}
                </select>
              </div>`;
            } else if (isRebuildStage) {
              // Rebuild Status: dropdown with specific options
              const rebuildStageOptions = [
                'Debris Removal & Site Clearance',
                'Professional Selection (Architect/Engineer & Builder)',
                'Plan Preparation & Design Stage',
                'Permit Application & Submittal',
                'Plan Check & Agency Review',
                'Plan Revision & Recheck',
                'Permit Issuance',
                'Construction',
                'Mandatory Inspections',
                'Final Inspection & Sign-Off',
                'Certificate of Occupancy'
              ];
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <select class="editable-dropdown" 
                        data-address="${address.replace(/"/g, '&quot;')}" 
                        data-address-level="true"
                        data-column="${col}"
                        data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">
                  <option value="">(not set)</option>
                  ${rebuildStageOptions.map(opt => `<option value="${opt.replace(/"/g, '&quot;')}" ${opt === firstRowValue ? 'selected' : ''}>${opt}</option>`).join('')}
                </select>
              </div>`;
            } else if (isCaptainAssigned && hasMultipleCaptains && captains.length > 0) {
              // Captain Assigned: dropdown with captain names (only if multiple captains exist)
              const captainNames = captains.map(c => c.name).filter(n => n !== 'N/A');
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <select class="editable-dropdown" 
                        data-address="${address.replace(/"/g, '&quot;')}" 
                        data-address-level="true"
                        data-column="${col}"
                        data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">
                  <option value="">(not specified)</option>
                  ${captainNames.map(name => `<option value="${name.replace(/"/g, '&quot;')}" ${name === firstRowValue ? 'selected' : ''}>${escapeHtml(name)}</option>`).join('')}
                </select>
              </div>`;
            } else if (isIndoorsRemediated || isSoilRemediated) {
              // Remediation fields: checkbox
              // Convert value to boolean - handle TRUE/FALSE (Google Sheets checkbox format), yes/no, true/false, or any non-empty value
              const valueStr = (firstRowValue || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              html += `<div class="person-info">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                  <input type="checkbox" 
                         class="editable-checkbox" 
                         data-address="${address.replace(/"/g, '&quot;')}" 
                         data-address-level="true"
                         data-column="${col}"
                         data-original-value="${firstRowValue.replace(/"/g, '&quot;')}"
                         ${isChecked ? 'checked' : ''}
                         style="width: 18px; height: 18px; cursor: pointer;">
                  <strong>${col}:</strong>
                </label>
              </div>`;
            } else {
              // Other fields: subtle editable
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-address-level="true"
                      data-column="${col}"
                      data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">${firstRowValue || ''}</span>
              </div>`;
            }
          } else {
            // Not signed in: display only
            if (isIndoorsRemediated || isSoilRemediated) {
              // For checkboxes, show as Yes/No
              const valueStr = (firstRowValue || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              html += `<div class="person-info"><strong>${col}:</strong> ${isChecked ? 'Yes' : 'No'}</div>`;
            } else {
              html += `<div class="person-info"><strong>${col}:</strong> ${firstRowValue || '(not set)'}</div>`;
            }
          }
        });
        
        html += '</div>';
      }

      // Check if contact mode is active
      const isContactMode = window.contactModeActive || false;
      const lastContactCol = headers.find(h => 
        h.toLowerCase() === 'last contact date' ||
        h.toLowerCase().includes('last contact') || 
        h.toLowerCase().includes('contact date') ||
        h.toLowerCase().includes('contacted')
      );

      // Show person-level fields for each person
      rows.forEach((row, index) => {
        // Get the original row index that was stored when grouping
        const originalRowIndex = row.__originalIndex !== undefined ? row.__originalIndex : -1;
        
        // Check contact status
        const lastContact = lastContactCol ? (row[lastContactCol] || '').trim() : '';
        const isContacted = lastContact && lastContact.length > 0;
        const contactClass = isContacted ? 'recent-contact' : (isContactMode ? 'no-contact' : '');
        
        html += `<div class="person-entry ${contactClass}">`;
        
        // Try to find name column - show Resident Name as the person's name
        const nameCol = headers.find(h => 
          h.toLowerCase().includes('resident name') || 
          (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name'))
        );
        
        if (nameCol && row[nameCol]) {
          html += `<div class="person-name">${row[nameCol]}</div>`;
        } else if (rows.length > 1) {
          html += `<div class="person-name">Person ${index + 1}</div>`;
        }

        // Contact mode: show contact button and quick notes
        if (isContactMode && accessToken) {
          html += `
            <div style="margin-top: 8px; margin-bottom: 8px;">
              <button class="contact-button ${isContacted ? 'contacted' : ''}" 
                      data-address="${address.replace(/"/g, '&quot;')}"
                      data-original-row-index="${originalRowIndex}"
                      data-column="${lastContactCol || 'Last Contact Date'}"
                      onclick="markContact(this, '${address.replace(/"/g, '&quot;')}', ${originalRowIndex}, '${lastContactCol || 'Last Contact Date'}')">
                ${isContacted ? ' Contacted' : 'Mark as Contacted'}
              </button>
              ${isContacted ? `<div class="contact-date">Last contact: ${lastContact}</div>` : ''}
              <textarea class="contact-notes-quick" 
                        placeholder="Quick contact notes..."
                        data-address="${address.replace(/"/g, '&quot;')}"
                        data-original-row-index="${originalRowIndex}"
                        data-column="Contact Notes"
                        data-original-value="${(row['Contact Notes'] || '').replace(/"/g, '&quot;')}">${row['Contact Notes'] || ''}</textarea>
            </div>
          `;
        } else if (isContactMode && !accessToken) {
          // Contact mode but not signed in - show status only
          html += `
            <div style="margin-top: 8px; margin-bottom: 8px;">
              <div style="font-size: 0.85rem; color: ${isContacted ? '#4caf50' : '#ff9800'};">
                ${isContacted ? ` Contacted (${lastContact})` : ' Not contacted'}
              </div>
            </div>
          `;
        }

        // Display person-level fields (show even if empty, like Notes)
        // First, identify fields that should be grouped together
        const ageCol = personLevelCols.find(col => {
          const lower = col.toLowerCase();
          return lower.includes('age') && !lower.includes('phone') && !lower.includes('resident name');
        });
        const genderCol = personLevelCols.find(col => {
          const lower = col.toLowerCase();
          return lower.includes('gender') && !lower.includes('resident name');
        });
        const homePhoneCol = personLevelCols.find(col => {
          const lower = col.toLowerCase();
          return (lower.includes('home phone') || lower.includes('homephone') || 
                  (lower.includes('phone') && lower.includes('home'))) && 
                 !lower.includes('cell') && !lower.includes('mobile');
        });
        const cellPhoneCol = personLevelCols.find(col => {
          const lower = col.toLowerCase();
          return (lower.includes('cell') || lower.includes('mobile')) && 
                 (lower.includes('phone') || lower.includes('cell') || lower.includes('mobile'));
        });
        
        const renderedFields = new Set(); // Track which fields have been rendered
        
        // Helper function to format column name for display
        const formatColumnLabel = (col) => {
          const lower = col.toLowerCase();
          if (lower.includes('home phone') || lower.includes('homephone') || 
              (lower.includes('phone') && lower.includes('home'))) {
            return 'Home';
          }
          // Remove "Person - " prefix from checkbox fields
          if (col.startsWith('Person - ')) {
            return col.substring(9); // Remove "Person - " (9 characters)
          }
          return col;
        };
        
        // Helper function to render a single field
        const renderField = (col, isInline = false) => {
          if (renderedFields.has(col)) return '';
          renderedFields.add(col);
          
          const isNotes = col.toLowerCase().includes('note');
          const isPersonCheckbox = col.startsWith('Person - ');
          const isEmail = col.toLowerCase().includes('email address');
          const isEditable = accessToken;
          const value = row[col] || '';
          const displayLabel = formatColumnLabel(col);
          
          // Copy button HTML for email addresses
          const copyButton = isEmail && value.trim() ? `
            <button class="copy-email-btn" 
                    data-email="${value.replace(/"/g, '&quot;')}" 
                    title="Copy email address"
                    style="background: none; border: none; cursor: pointer; padding: 2px 4px; display: inline-flex; align-items: center; opacity: 0.6; transition: opacity 0.2s;">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          ` : '';
          
          if (isEditable) {
            if (isNotes) {
              return `<div class="person-info${isInline ? '-item' : ''}">
                <strong>${displayLabel}:</strong>
                <textarea class="editable-notes" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-original-row-index="${originalRowIndex}" 
                     data-column="${col}"
                     data-address-level="false"
                     data-original-value="${(row[col] || '').replace(/"/g, '&quot;')}">${row[col] || ''}</textarea>
              </div>`;
            } else if (isPersonCheckbox) {
              // Person-level checkbox fields
              const valueStr = (value || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              return `<div class="person-info${isInline ? '-item' : ''}">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                  <input type="checkbox" 
                         class="editable-checkbox" 
                         data-address="${address.replace(/"/g, '&quot;')}" 
                         data-original-row-index="${originalRowIndex}" 
                         data-column="${col}"
                         data-address-level="false"
                         data-original-value="${value.replace(/"/g, '&quot;')}"
                         ${isChecked ? 'checked' : ''}
                         style="width: 18px; height: 18px; cursor: pointer;">
                  <strong>${displayLabel}:</strong>
                </label>
              </div>`;
            } else {
              return `<div class="person-info${isInline ? '-item' : ''}">
                <strong>${displayLabel}:</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-original-row-index="${originalRowIndex}" 
                      data-column="${col}"
                      data-address-level="false"
                      data-original-value="${value.replace(/"/g, '&quot;')}">${value || ''}</span>
                ${copyButton}
              </div>`;
            }
          } else {
            if (isPersonCheckbox) {
              // For checkboxes, show as Yes/No
              const valueStr = (value || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              return `<div class="person-info${isInline ? '-item' : ''}"><strong>${displayLabel}:</strong> ${isChecked ? 'Yes' : 'No'}</div>`;
            } else {
              return `<div class="person-info${isInline ? '-item' : ''}">
                <strong>${displayLabel}:</strong> ${value || '(not set)'}
                ${copyButton}
              </div>`;
            }
          }
        };
        
        // Render Age and Gender on the same line if both exist
        if (ageCol || genderCol) {
          html += '<div class="person-info-inline">';
          if (ageCol) {
            // Skip Resident Name check for age
            if (!ageCol.toLowerCase().includes('resident name')) {
              html += renderField(ageCol, true);
            }
          }
          if (genderCol) {
            if (!genderCol.toLowerCase().includes('resident name')) {
              html += renderField(genderCol, true);
            }
          }
          html += '</div>';
        }
        
        // Render Home phone and Cell phone on the same line if both exist
        if (homePhoneCol || cellPhoneCol) {
          html += '<div class="person-info-inline">';
          if (homePhoneCol) {
            html += renderField(homePhoneCol, true);
          }
          if (cellPhoneCol) {
            html += renderField(cellPhoneCol, true);
          }
          html += '</div>';
        }
        
        // Render remaining person-level fields individually
        personLevelCols.forEach(col => {
          // Skip fields already rendered or that should be skipped
          if (renderedFields.has(col)) return;
          if (col.toLowerCase().includes('resident name')) return;
          if (isContactMode && (col.toLowerCase().includes('contact') && col.toLowerCase().includes('note'))) return;
          
          const isNotes = col.toLowerCase().includes('note');
          const isPersonCheckbox = col.startsWith('Person - ');
          const isEmail = col.toLowerCase().includes('email address');
          const isEditable = accessToken;
          const displayLabel = formatColumnLabel(col);
          const value = row[col] || '';
          
          // Copy button HTML for email addresses
          const copyButton = isEmail && value.trim() ? `
            <button class="copy-email-btn" 
                    data-email="${value.replace(/"/g, '&quot;')}" 
                    title="Copy email address"
                    style="background: none; border: none; cursor: pointer; padding: 2px 4px; display: inline-flex; align-items: center; opacity: 0.6; transition: opacity 0.2s;">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          ` : '';
          
          if (isEditable) {
            if (isNotes) {
              html += `<div class="person-info">
                <strong>${displayLabel}:</strong>
                <textarea class="editable-notes" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-original-row-index="${originalRowIndex}" 
                     data-column="${col}"
                     data-address-level="false"
                     data-original-value="${(row[col] || '').replace(/"/g, '&quot;')}">${row[col] || ''}</textarea>
              </div>`;
            } else if (isPersonCheckbox) {
              // Person-level checkbox fields
              const valueStr = (value || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              html += `<div class="person-info">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                  <input type="checkbox" 
                         class="editable-checkbox" 
                         data-address="${address.replace(/"/g, '&quot;')}" 
                         data-original-row-index="${originalRowIndex}" 
                         data-column="${col}"
                         data-address-level="false"
                         data-original-value="${value.replace(/"/g, '&quot;')}"
                         ${isChecked ? 'checked' : ''}
                         style="width: 18px; height: 18px; cursor: pointer;">
                  <strong>${displayLabel}:</strong>
                </label>
              </div>`;
            } else {
              html += `<div class="person-info">
                <strong>${displayLabel}:</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-original-row-index="${originalRowIndex}" 
                      data-column="${col}"
                      data-address-level="false"
                      data-original-value="${value.replace(/"/g, '&quot;')}">${value || ''}</span>
                ${copyButton}
              </div>`;
            }
          } else {
            if (isPersonCheckbox) {
              // For checkboxes, show as Yes/No
              const valueStr = (value || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              html += `<div class="person-info"><strong>${displayLabel}:</strong> ${isChecked ? 'Yes' : 'No'}</div>`;
            } else {
              html += `<div class="person-info">
                <strong>${displayLabel}:</strong> ${value || '(not set)'}
                ${copyButton}
              </div>`;
            }
          }
        });
        
        // Display other non-notes fields that aren't address-level (but exclude hidden fields)
        detailCols.forEach(col => {
          const lower = col.toLowerCase();
          const isHidden = hiddenFromPersonView.some(field => lower.includes(field));
          if (!addressLevelCols.includes(col) && !personLevelCols.includes(col) && 
              !col.toLowerCase().includes('note') && !isHidden) {
            if (row[col] && row[col].trim()) {
              html += `<div class="person-info"><strong>${col}:</strong> ${row[col]}</div>`;
            }
          }
        });

        html += '</div>';
      });

      // Add save button if signed in and there are editable fields
      if (accessToken) {
        html += `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 2px solid var(--river);">
            <button class="btn-save" id="saveChangesBtn">Save Changes</button>
            <span class="save-status" id="saveStatus"></span>
          </div>
        `;
      }

      html += '</div>';
      addressPanelContent.innerHTML = html;
      
      // Add save button handlers (both top and bottom buttons)
      const saveBtn = document.getElementById('saveChangesBtn');
      if (saveBtn) {
        saveBtn.addEventListener('click', saveChanges);
      }
      const saveBtnTop = document.getElementById('saveChangesBtnTop');
      if (saveBtnTop) {
        saveBtnTop.addEventListener('click', saveChanges);
      }
      const refreshBtnTop = document.getElementById('refreshBtnTop');
      if (refreshBtnTop) {
        refreshBtnTop.addEventListener('click', () => {
          if (currentSheetUrl) {
            loadAddressData(currentSheetUrl);
          }
        });
      }
      
      // Add change handlers for dropdowns with auto-save
      document.querySelectorAll('.editable-dropdown').forEach(dropdown => {
        dropdown.addEventListener('change', () => {
          // Mark as changed for save
          dropdown.setAttribute('data-changed', 'true');
          // Trigger auto-save
          triggerAutoSave();
        });
      });
      
      // Add change handlers for checkboxes with auto-save
      document.querySelectorAll('.editable-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
          // Trigger auto-save
          triggerAutoSave();
        });
      });
      
      // Add change handlers for contenteditable fields with auto-save
      document.querySelectorAll('.editable-field[contenteditable="true"], .editable-inline[contenteditable="true"]').forEach(field => {
        field.addEventListener('input', () => {
          triggerAutoSave();
        });
        field.addEventListener('blur', () => {
          // Also trigger on blur in case user clicks away
          triggerAutoSave();
        });
      });
      
      // Add change handlers for textareas with auto-save
      document.querySelectorAll('.editable-notes, .contact-notes-quick').forEach(textarea => {
        textarea.addEventListener('input', () => {
          triggerAutoSave();
        });
        textarea.addEventListener('blur', () => {
          triggerAutoSave();
        });
      });
      
      // Add copy button handlers for email addresses
      document.querySelectorAll('.copy-email-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          const email = btn.getAttribute('data-email');
          if (email) {
            try {
              await navigator.clipboard.writeText(email);
              // Visual feedback
              const originalOpacity = btn.style.opacity;
              btn.style.opacity = '1';
              btn.style.color = '#4caf50';
              setTimeout(() => {
                btn.style.opacity = originalOpacity;
                btn.style.color = '';
              }, 500);
            } catch (err) {
              // Fallback for older browsers
              const textArea = document.createElement('textarea');
              textArea.value = email;
              textArea.style.position = 'fixed';
              textArea.style.left = '-999999px';
              document.body.appendChild(textArea);
              textArea.select();
              try {
                document.execCommand('copy');
                btn.style.opacity = '1';
                btn.style.color = '#4caf50';
                setTimeout(() => {
                  btn.style.opacity = '0.6';
                  btn.style.color = '';
                }, 500);
              } catch (fallbackErr) {
                console.error('Failed to copy email:', fallbackErr);
              }
              document.body.removeChild(textArea);
            }
          }
        });
        // Hover effect
        btn.addEventListener('mouseenter', () => {
          btn.style.opacity = '1';
        });
        btn.addEventListener('mouseleave', () => {
          if (btn.style.color !== '#4caf50') {
            btn.style.opacity = '0.6';
          }
        });
      });
      
      // Restore scroll position if refreshing, otherwise scroll to top
      setTimeout(() => {
        if (preserveScroll) {
          addressPanelContent.scrollTop = savedScrollPosition;
        } else {
          addressPanelContent.scrollTop = 0; // Start at top for new address
        }
      }, 0);
    }

    // Load sheet button handler
    btn.addEventListener("click", () => {
      // Validate sign-in first
      if (!accessToken) {
        alert('Please sign in with Google first before loading your spreadsheet.');
        return;
      }

      let url = input.value.trim();
      if (!url) {
        alert('Please enter a Google Sheets URL.');
        return;
      }

      if (url.includes("/view")) {
        url = url.replace("/view", "/edit");
      }

      currentSheetUrl = url;
      // Save to localStorage
      localStorage.setItem('savedSheetUrl', url);
      
      // Update UI
      updateSheetLinkLabel();
      updateWelcomeMessage();
      updateNavigationState();
      
      // Load the address data
      loadAddressData(url);
    });

    // Refresh button handler
    // Refresh button removed - data auto-loads after sign-in

    // Navigation System - Single Page Navigation
    function switchView(viewName) {
      // Prevent switching to non-home views if no spreadsheet is linked
      // Check both currentSheetUrl and localStorage for savedSheetUrl
      const hasSheet = currentSheetUrl || localStorage.getItem('savedSheetUrl');
      if (!hasSheet && viewName !== 'home') {
        // Force back to home view
        viewName = 'home';
        currentView = 'home';
      }
      
      currentView = viewName;
      
      // Save current view to localStorage
      localStorage.setItem('currentView', viewName);
      
      // Hide all content views
      document.querySelectorAll('.content-view').forEach(view => {
        view.style.display = 'none';
        view.classList.remove('active');
      });
      
      // Update nav items
      document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
      });
      
      // Show selected view (map view doesn't need a content overlay)
      if (viewName !== 'map') {
        const selectedView = document.getElementById(viewName + 'View');
        if (selectedView) {
          selectedView.style.display = 'block';
          selectedView.classList.add('active');
        }
      }
      
      // Update nav button
      const navButton = document.getElementById('nav' + viewName.charAt(0).toUpperCase() + viewName.slice(1));
      if (navButton) {
        navButton.classList.add('active');
      }
      
      // Show/hide floating panel based on view
      const floatingPanel = document.getElementById('floatingPanel');
      if (viewName === 'people' || viewName === 'map') {
        // Show floating panel for people and map views
        if (floatingPanel) floatingPanel.style.display = 'flex';
      } else {
        // Hide floating panel for other views (including home)
        if (floatingPanel) floatingPanel.style.display = 'none';
      }
      
      // Show/hide filter bar based on view
      const filterBar = document.getElementById('filterBar');
      const shouldShowFilters = (viewName === 'people' || viewName === 'map');
      
      // Show/hide map container based on view
      const mapContainer = document.querySelector('.map-container');
      if (viewName === 'map') {
        if (mapContainer) mapContainer.style.display = 'block';
        // Initialize map if not already done, and ensure it's properly sized
        // Start watchdog immediately when switching to map view
        startColorFilterWatchdog();
        
        if (!zoneMap) {
          initializeMap();
          // After map is initialized, ensure color filter control exists and restore color mode
          setTimeout(() => {
            ensureColorFilterControl();
            setTimeout(() => {
              restoreColorMode();
            }, 100);
          }, 200);
        } else {
          // Map already exists - ensure color filter control is present
          ensureColorFilterControl();
          // Wait a bit for control to be added to DOM before restoring
          setTimeout(() => {
            restoreColorMode();
          }, 100);
        }
        // Wait for container to be visible, then invalidate size and update markers
        setTimeout(() => {
          if (zoneMap) {
            zoneMap.invalidateSize();
            // Ensure control still exists after invalidation
            ensureColorFilterControl();
            // Update markers after map is properly sized
            setTimeout(() => {
              if (sheetData && sheetData.addressMap) {
                updateMapMarkers();
                // Restore saved color mode if available
                restoreColorMode();
              } else {
                // Data not loaded yet - restore color mode anyway (control should be visible)
                restoreColorMode();
              }
              // Final check after everything settles - ensure control is still there
              setTimeout(() => {
                if (currentView === 'map' && zoneMap) {
                  ensureColorFilterControl();
                }
              }, 500);
            }, 100);
          }
        }, 150);
      } else {
        if (mapContainer) mapContainer.style.display = 'none';
        // Stop watchdog when leaving map view
        stopColorFilterWatchdog();
      }
      if (shouldShowFilters) {
        // Show filter bar for people and map views
        if (filterBar && sheetData && sheetData.addressMap) {
          filterBar.style.display = 'block';
        }
        // Adjust content views to account for filter bar height
        // Use a small delay to ensure filter bar has rendered and height is accurate
        setTimeout(() => {
          adjustContentViewsForFilterBar();
        }, 50);
      } else {
        // Hide filter bar for other views
        if (filterBar) filterBar.style.display = 'none';
        // Adjust content views to start at top (no filter bar)
        document.querySelectorAll('.content-view').forEach(view => {
          view.style.top = '0';
        });
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
          mapContainer.style.top = '0';
        }
      }
      
      // Update welcome message visibility
      updateWelcomeMessage();
      
      // Update sign-in UI when switching views
      updateSignInUI();
      
      // Update content based on view
      if (viewName === 'home') {
        if (sheetData && sheetData.addressMap) {
          updateHomeDashboard();
          // Ensure home map is properly sized and KML is loaded when switching to home view
          setTimeout(() => {
            if (homeMap) {
              homeMap.invalidateSize();
              // Load KML if URL is available (in case map wasn't ready before)
              if (zoneKmlUrl) {
                console.log('Switching to home view, loading KML:', zoneKmlUrl);
                setTimeout(() => {
                  loadHomeKMLBoundary(zoneKmlUrl);
                }, 200);
              }
            }
          }, 100);
        } else {
          displayQuickActions(); // Show loading state even without data
        }
      } else if (viewName === 'meetups') {
        // Display actions page when switching to Actions view
        if (sheetData && sheetData.addressMap) {
          displayActionsPage();
        } else {
          const actionsContent = document.getElementById('actionsPageContent');
          if (actionsContent) {
            actionsContent.innerHTML = '<div class="loading">Loading actions...</div>';
          }
        }
      } else if (viewName === 'people' && sheetData && sheetData.addressMap) {
        displayAddressTable();
      } else if (viewName === 'progress' && sheetData && sheetData.addressMap) {
        updateZoneProgressCharts();
      } else if (viewName === 'tools') {
        // Initialize Contact List Creator and Zone Report Generator when Tools view is shown
        setTimeout(() => {
          initializeContactListCreator();
          initializeZoneReportGenerator();
          setupToolModuleExpansion();
        }, 100);
      }
      // Map view doesn't need special content updates - it just shows the map with floating panel
    }
    
    // Set up navigation event listeners
    document.querySelectorAll('.nav-item[data-view]').forEach(item => {
      item.addEventListener('click', (e) => {
        // Prevent navigation if no spreadsheet is linked (except Home)
        const viewName = e.target.getAttribute('data-view');
        if (!currentSheetUrl && viewName !== 'home') {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        switchView(viewName);
      });
    });
    
    // Initialize with saved view or home view (default landing page)
    const savedView = localStorage.getItem('currentView');
    // Allow restoring any view if we have a saved sheet URL, or if it's home view
    // Note: savedSheetUrl is already loaded above (line 2177), so we can check it directly
    if (savedView && (savedView === 'home' || savedSheetUrl)) {
      currentView = savedView;
      switchView(savedView);
    } else {
      currentView = 'home';
      switchView('home');
    }
    
    // Set up Open Map button

    // Convert column index to letter (A, B, C, etc.) - global helper function
    function indexToColumnLetter(index) {
      let result = '';
      while (index >= 0) {
        result = String.fromCharCode(65 + (index % 26)) + result;
        index = Math.floor(index / 26) - 1;
      }
      return result;
    }

    // Save changes to spreadsheet
    // Debounced auto-save function
    function triggerAutoSave() {
      // Clear existing timer
      if (autoSaveTimer) {
        clearTimeout(autoSaveTimer);
      }
      
      // Set new timer (1.2 seconds delay)
      autoSaveTimer = setTimeout(() => {
        saveChanges(true); // true = isAutoSave
      }, 1200);
      
      // Show "Auto-saving..." indicator in both locations (top and bottom)
      const saveStatus = document.getElementById('saveStatus');
      const saveStatusTop = document.getElementById('saveStatusTop');
      
      if (saveStatus) {
        saveStatus.textContent = 'Auto-saving...';
        saveStatus.className = 'save-status saving';
      }
      if (saveStatusTop) {
        saveStatusTop.textContent = 'Auto-saving...';
        saveStatusTop.className = 'save-status saving';
      }
    }

    async function saveChanges(isAutoSave = false) {
      if (!accessToken || !currentSheetId) {
        if (!isAutoSave) {
          alert('Please sign in to save changes.');
        }
        return;
      }

      const saveBtn = document.getElementById('saveChangesBtn');
      const saveStatus = document.getElementById('saveStatus');
      const saveStatusTop = document.getElementById('saveStatusTop');
      // Get all editable elements: Notes fields (textareas), inline fields, dropdowns, checkboxes, and Quick Contact Notes
      const editableFields = document.querySelectorAll('.editable-field[contenteditable="true"], .editable-inline[contenteditable="true"], .editable-notes, .contact-notes-quick');
      const editableDropdowns = document.querySelectorAll('.editable-dropdown');
      const editableCheckboxes = document.querySelectorAll('.editable-checkbox');
      
      if (editableFields.length === 0 && editableDropdowns.length === 0 && editableCheckboxes.length === 0) {
        return;
      }

      if (!saveBtn || !saveStatus) {
        console.warn('Save button or status element not found');
        return;
      }

      saveBtn.disabled = true;
      if (saveStatus) {
        saveStatus.textContent = isAutoSave ? 'Auto-saving...' : 'Saving...';
        saveStatus.className = 'save-status saving';
      }
      if (saveStatusTop) {
        saveStatusTop.textContent = isAutoSave ? 'Auto-saving...' : 'Saving...';
        saveStatusTop.className = 'save-status saving';
      }

      try {
        // Collect all changes
        const updates = [];
        editableFields.forEach(field => {
          // Handle textareas differently from contenteditable divs
          const newValue = field.tagName === 'TEXTAREA' ? field.value.trim() : field.textContent.trim();
          const originalValue = field.getAttribute('data-original-value') || '';
          const column = field.getAttribute('data-column');
          const isAddressLevel = field.getAttribute('data-address-level') === 'true';
          const address = field.getAttribute('data-address');
          const originalRowIndex = parseInt(field.getAttribute('data-original-row-index'));

          if (newValue !== originalValue) {
            // Find the column index - handle Contact Notes with flexible matching
            let colIndex = -1;
            if (column === 'Contact Notes' || field.classList.contains('contact-notes-quick')) {
              // For Contact Notes, use flexible search like markContact does
              colIndex = sheetData.headers.findIndex(h => 
                h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')
              );
            } else {
              colIndex = sheetData.headers.indexOf(column);
            }
            if (colIndex === -1) {
              console.warn(`Column not found: ${column}`);
              return;
            }

            // Convert column index to letter (A, B, C, etc.)
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2; // +2 because +1 for header row, +1 for 1-based indexing
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            } else {
              // Person-level: update only this specific row
              if (originalRowIndex !== -1) {
                const rowNumber = originalRowIndex + 2; // +2 because +1 for header row, +1 for 1-based indexing
                const range = `${colLetter}${rowNumber}`;
                updates.push({
                  range: `Sheet1!${range}`,
                  values: [[newValue]]
                });
              }
            }
          }
        });
        
        // Handle dropdown fields
        editableDropdowns.forEach(dropdown => {
          const newValue = dropdown.value.trim();
          const originalValue = dropdown.getAttribute('data-original-value');
          const column = dropdown.getAttribute('data-column');
          const isAddressLevel = dropdown.getAttribute('data-address-level') === 'true';
          const address = dropdown.getAttribute('data-address');

          if (newValue !== originalValue) {
            // Find the column index
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex === -1) return;

            // Convert column index to letter
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2;
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            }
          }
        });
        
        // Handle checkbox fields
        editableCheckboxes.forEach(checkbox => {
          const newValue = checkbox.checked ? 'TRUE' : 'FALSE';
          const originalValue = checkbox.getAttribute('data-original-value') || '';
          // Convert original value to boolean for comparison - handle TRUE/FALSE, yes/no, true/false
          const originalValueStr = (originalValue || '').trim();
          const originalValueStrLower = originalValueStr.toLowerCase();
          const originalChecked = originalValueStrLower === 'true' || originalValueStr === 'TRUE' || 
                                 originalValueStrLower === 'yes' || 
                                 (originalValueStr !== '' && originalValueStrLower !== 'false' && originalValueStr !== 'FALSE' && originalValueStrLower !== 'no');
          const column = checkbox.getAttribute('data-column');
          const isAddressLevel = checkbox.getAttribute('data-address-level') === 'true';
          const address = checkbox.getAttribute('data-address');

          if (checkbox.checked !== originalChecked) {
            // Find the column index
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex === -1) return;

            // Convert column index to letter
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2;
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            } else {
              // Person-level: update only this specific row
              const originalRowIndex = parseInt(checkbox.getAttribute('data-original-row-index'));
              if (originalRowIndex !== -1) {
                const rowNumber = originalRowIndex + 2;
                const range = `${colLetter}${rowNumber}`;
                updates.push({
                  range: `Sheet1!${range}`,
                  values: [[newValue]]
                });
              }
            }
          }
        });

        if (updates.length === 0) {
          if (saveStatus) {
            saveStatus.textContent = 'No changes to save';
            saveStatus.className = 'save-status';
          }
          if (saveBtn) {
            saveBtn.disabled = false;
          }
          return;
        }

        // Use Google Sheets API to update
        const response = await fetch(
          `https://sheets.googleapis.com/v4/spreadsheets/${currentSheetId}/values:batchUpdate`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              valueInputOption: 'USER_ENTERED',
              data: updates
            })
          }
        );

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || 'Failed to save');
        }

        // Update original values and in-memory data structure
        editableFields.forEach(field => {
          const value = field.tagName === 'TEXTAREA' ? field.value.trim() : field.textContent.trim();
          // Escape HTML entities for data attribute
          const escapedValue = value.replace(/"/g, '&quot;').replace(/\n/g, '&#10;');
          field.setAttribute('data-original-value', escapedValue);
          
          // Update in-memory data structure
          const column = field.getAttribute('data-column');
          const isAddressLevel = field.getAttribute('data-address-level') === 'true';
          const address = field.getAttribute('data-address');
          const originalRowIndex = parseInt(field.getAttribute('data-original-row-index'));
          
          if (column && address) {
            // Find the column index - handle Contact Notes with flexible matching
            let colIndex = -1;
            if (column === 'Contact Notes' || field.classList.contains('contact-notes-quick')) {
              colIndex = sheetData.headers.findIndex(h => 
                h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')
              );
            } else {
              colIndex = sheetData.headers.indexOf(column);
            }
            
            if (colIndex !== -1) {
              const columnName = sheetData.headers[colIndex];
              if (isAddressLevel) {
                // Address-level: update ALL rows for this address
                const rows = sheetData.addressMap.get(address);
                if (rows) {
                  rows.forEach(row => {
                    row[columnName] = value;
                  });
                }
              } else {
                // Person-level: update only this specific row
                if (originalRowIndex !== -1) {
                  const rows = sheetData.addressMap.get(address);
                  if (rows) {
                    const row = rows.find(r => r.__originalIndex === originalRowIndex);
                    if (row) {
                      row[columnName] = value;
                    }
                  }
                }
              }
            }
          }
        });
        editableDropdowns.forEach(dropdown => {
          dropdown.setAttribute('data-original-value', dropdown.value.trim());
          
          // Update in-memory data structure
          const column = dropdown.getAttribute('data-column');
          const isAddressLevel = dropdown.getAttribute('data-address-level') === 'true';
          const address = dropdown.getAttribute('data-address');
          const originalRowIndex = parseInt(dropdown.getAttribute('data-original-row-index'));
          const value = dropdown.value.trim();
          
          if (column && address) {
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex !== -1) {
              const columnName = sheetData.headers[colIndex];
              if (isAddressLevel) {
                const rows = sheetData.addressMap.get(address);
                if (rows) {
                  rows.forEach(row => {
                    row[columnName] = value;
                  });
                }
              } else {
                if (originalRowIndex !== -1) {
                  const rows = sheetData.addressMap.get(address);
                  if (rows) {
                    const row = rows.find(r => r.__originalIndex === originalRowIndex);
                    if (row) {
                      row[columnName] = value;
                    }
                  }
                }
              }
            }
          }
        });
        editableCheckboxes.forEach(checkbox => {
          const value = checkbox.checked ? 'TRUE' : 'FALSE';
          checkbox.setAttribute('data-original-value', value);
          
          // Update in-memory data structure
          const column = checkbox.getAttribute('data-column');
          const isAddressLevel = checkbox.getAttribute('data-address-level') === 'true';
          const address = checkbox.getAttribute('data-address');
          const originalRowIndex = parseInt(checkbox.getAttribute('data-original-row-index'));
          const checkboxValue = checkbox.checked ? 'TRUE' : 'FALSE';
          
          if (column && address) {
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex !== -1) {
              const columnName = sheetData.headers[colIndex];
              if (isAddressLevel) {
                const rows = sheetData.addressMap.get(address);
                if (rows) {
                  rows.forEach(row => {
                    row[columnName] = checkboxValue;
                  });
                }
              } else {
                if (originalRowIndex !== -1) {
                  const rows = sheetData.addressMap.get(address);
                  if (rows) {
                    const row = rows.find(r => r.__originalIndex === originalRowIndex);
                    if (row) {
                      row[columnName] = checkboxValue;
                    }
                  }
                }
              }
            }
          }
        });

        if (saveStatus) {
          saveStatus.textContent = isAutoSave ? 'Auto-saved!' : 'Saved!';
          saveStatus.className = 'save-status saved';
          // Clear auto-save message after 2 seconds
          if (isAutoSave) {
            setTimeout(() => {
              if (saveStatus && saveStatus.textContent === 'Auto-saved!') {
                saveStatus.textContent = '';
                saveStatus.className = 'save-status';
              }
            }, 2000);
          }
        }
        if (saveStatusTop) {
          saveStatusTop.textContent = isAutoSave ? 'Auto-saved!' : 'Saved!';
          saveStatusTop.className = 'save-status saved';
          // Clear auto-save message after 2 seconds
          if (isAutoSave) {
            setTimeout(() => {
              if (saveStatusTop && saveStatusTop.textContent === 'Auto-saved!') {
                saveStatusTop.textContent = '';
                saveStatusTop.className = 'save-status';
              }
            }, 2000);
          }
        }
        
        // Update Home page statistics immediately (for both auto-save and manual save)
        // This ensures changes are reflected on the Home page without requiring a browser refresh
        updateHomeDashboard();
        
        // Refresh data after a short delay (only for manual saves to avoid too many refreshes)
        if (!isAutoSave) {
          setTimeout(() => {
            if (currentSheetUrl) {
              loadAddressData(currentSheetUrl);
            }
          }, 1000);
        }

      } catch (error) {
        console.error('Save error:', error);
        if (saveStatus) {
          saveStatus.textContent = `Error: ${error.message}`;
          saveStatus.className = 'save-status error';
        }
        if (saveStatusTop) {
          saveStatusTop.textContent = `Error: ${error.message}`;
          saveStatusTop.className = 'save-status error';
        }
        // For auto-save errors, also show a console warning (less intrusive than alert)
        if (isAutoSave) {
          console.warn('Auto-save failed:', error.message);
        } else {
          alert(`Error saving changes: ${error.message}`);
        }
      } finally {
        if (saveBtn) {
          saveBtn.disabled = false;
        }
      }
    }

    // Create colored marker icon using SVG
    function createColoredMarkerIcon(color, isSelected = false) {
      const size = isSelected ? 30 : 25;
      const anchor = isSelected ? 15 : 12;
      
      const svgIcon = `
        <svg width="${size}" height="${size * 1.64}" viewBox="0 0 25 41" xmlns="http://www.w3.org/2000/svg">
          <path fill="${color}" stroke="#fff" stroke-width="1.5" d="M12.5 0C5.6 0 0 5.6 0 12.5c0 8.2 12.5 28.5 12.5 28.5S25 20.7 25 12.5C25 5.6 19.4 0 12.5 0z"/>
          <circle cx="12.5" cy="12.5" r="4" fill="#fff"/>
        </svg>
      `;
      
      return L.divIcon({
        html: svgIcon,
        className: 'custom-colored-marker',
        iconSize: [size, size * 1.64],
        iconAnchor: [anchor, size * 1.64],
        popupAnchor: [1, -(size * 1.64) + 10]
      });
    }

    // Color palette
    const colorPalette = {
      'dry-sage': '#b4bd9b',
      'dusty-mauve': '#bc455a',
      'light-caramel': '#fdba77',
      'apricot-cream': '#f6cf98',
      'sky-blue-light': '#81bdc3',
      'floral-white': '#fdf8ec',
      'soft-blush': '#f9d6d3',
      'ash-grey': '#ccd5c3'
    };

    // Get marker color based on current color mode and address data
    function getMarkerColor(address) {
      if (!currentColorMode || !sheetData) return null;
      
      if (currentColorMode === 'contact') {
        return isAddressContacted(address) ? colorPalette['sky-blue-light'] : colorPalette['dusty-mauve'];
      } else if (currentColorMode === 'damage') {
        const damage = getAddressDamage(address);
        if (!damage) return colorPalette['ash-grey'];
        const damageLower = damage.toLowerCase();
        if (damageLower.includes('total')) return colorPalette['dusty-mauve'];
        if (damageLower.includes('partial')) return colorPalette['light-caramel'];
        if (damageLower.includes('standing')) return colorPalette['sky-blue-light'];
        return colorPalette['ash-grey'];
      }
      return null;
    }

    // Get marker color for home map based on home color mode
    function getHomeMapMarkerColor(address) {
      if (!homeColorMode || !sheetData) return null;
      
      if (homeColorMode === 'contact') {
        return isAddressContacted(address) ? colorPalette['sky-blue-light'] : colorPalette['dusty-mauve'];
      } else if (homeColorMode === 'damage') {
        const damage = getAddressDamage(address);
        if (!damage) return colorPalette['ash-grey'];
        const damageLower = damage.toLowerCase();
        if (damageLower.includes('total')) return colorPalette['dusty-mauve'];
        if (damageLower.includes('partial')) return colorPalette['light-caramel'];
        if (damageLower.includes('standing')) return colorPalette['sky-blue-light'];
        return colorPalette['ash-grey'];
      }
      return null;
    }

    // Recolor all markers based on current color mode
    function recolorMarkers() {
      if (!addressMarkers || !zoneMap) return;
      
      addressMarkers.forEach(marker => {
        const address = marker.address;
        const isSelected = selectedAddress === address;
        
        if (currentColorMode) {
          const color = getMarkerColor(address);
          if (color) {
            marker.setIcon(createColoredMarkerIcon(color, isSelected));
          } else {
            // Fallback to default if no color determined
            marker.setIcon(L.icon({
              iconUrl: isSelected 
                ? 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png'
                : 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
              shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41]
            }));
          }
        } else {
          // Default: blue for normal, red for selected
          marker.setIcon(L.icon({
            iconUrl: isSelected 
              ? 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png'
              : 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
          }));
        }
      });
    }

    // Show color legend
    function showColorLegend(mode) {
      // Remove existing legend if any
      if (colorLegendControl) {
        zoneMap.removeControl(colorLegendControl);
      }
      
      const ColorLegendControl = L.Control.extend({
        onAdd: function(map) {
          const container = L.DomUtil.create('div', 'color-legend-control');
          container.style.cssText = 'background: white; border-radius: 4px; box-shadow: 0 1px 5px rgba(0,0,0,0.4); padding: 10px; font-size: 0.75rem; min-width: 160px; max-width: 200px;';
          
          let html = '';
          
          if (mode === 'contact') {
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Contact Status</div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['sky-blue-light']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Contacted</span>
              </div>
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['dusty-mauve']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Not Contacted</span>
              </div>
            `;
          } else if (mode === 'damage') {
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Damage Status</div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['dusty-mauve']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Total Loss</span>
              </div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['light-caramel']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Partial Loss</span>
              </div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['sky-blue-light']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Standing</span>
              </div>
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['ash-grey']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Unknown</span>
              </div>
            `;
          }
          
          container.innerHTML = html;
          L.DomEvent.disableClickPropagation(container);
          
          return container;
        }
      });
      
      colorLegendControl = new ColorLegendControl({ position: 'topleft' });
      colorLegendControl.addTo(zoneMap);
    }

    // Hide color legend
    function hideColorLegend() {
      if (colorLegendControl) {
        zoneMap.removeControl(colorLegendControl);
        colorLegendControl = null;
      }
    }

    // Show color legend for home map
    function showHomeColorLegend(mode) {
      // Remove existing legend if any
      if (homeColorLegendControl) {
        homeMap.removeControl(homeColorLegendControl);
      }
      
      const ColorLegendControl = L.Control.extend({
        onAdd: function(map) {
          const container = L.DomUtil.create('div', 'color-legend-control');
          container.style.cssText = 'background: white; border-radius: 4px; box-shadow: 0 1px 5px rgba(0,0,0,0.4); padding: 10px; font-size: 0.75rem; min-width: 160px; max-width: 200px;';
          
          let html = '';
          if (mode === 'contact') {
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Contact Status</div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['sky-blue-light']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Contacted</span>
              </div>
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['dusty-mauve']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Not Contacted</span>
              </div>
            `;
          } else if (mode === 'damage') {
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Damage Status</div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['dusty-mauve']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Total Loss</span>
              </div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['light-caramel']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Partial Loss</span>
              </div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['sky-blue-light']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Standing</span>
              </div>
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['ash-grey']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Unknown</span>
              </div>
            `;
          }
          
          container.innerHTML = html;
          L.DomEvent.disableClickPropagation(container);
          
          return container;
        }
      });
      
      homeColorLegendControl = new ColorLegendControl({ position: 'topleft' });
      homeColorLegendControl.addTo(homeMap);
    }

    // Hide color legend for home map
    function hideHomeColorLegend() {
      if (homeColorLegendControl) {
        homeMap.removeControl(homeColorLegendControl);
        homeColorLegendControl = null;
      }
    }

    // Create color filter control for home map
    function createHomeColorFilterControl() {
      if (!homeMap) return;
      
      const ColorFilterControl = L.Control.extend({
        onAdd: function(map) {
          const container = L.DomUtil.create('div', 'color-filter-control');
          container.style.cssText = 'background: white; border-radius: 4px; box-shadow: 0 1px 5px rgba(0,0,0,0.4); padding: 8px; font-size: 0.75rem; min-width: 140px;';
          
          // Header
          const header = L.DomUtil.create('div', 'color-filter-header', container);
          header.textContent = 'Color By:';
          header.style.cssText = 'font-weight: 600; margin-bottom: 6px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;';
          
          // Contact Status button
          const contactBtn = L.DomUtil.create('button', 'color-filter-btn', container);
          contactBtn.textContent = 'Contact Status';
          contactBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.75rem; text-align: left; transition: all 0.2s;';
          contactBtn.onmouseover = () => contactBtn.style.background = '#f5f5f5';
          contactBtn.onmouseout = () => {
            if (homeColorMode !== 'contact') contactBtn.style.background = 'white';
          };
          
          // Damage Status button
          const damageBtn = L.DomUtil.create('button', 'color-filter-btn', container);
          damageBtn.textContent = 'Damage Status';
          damageBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.75rem; text-align: left; transition: all 0.2s;';
          damageBtn.onmouseover = () => damageBtn.style.background = '#f5f5f5';
          damageBtn.onmouseout = () => {
            if (homeColorMode !== 'damage') damageBtn.style.background = 'white';
          };
          
          // Click handlers
          contactBtn.onclick = () => {
            if (homeColorMode === 'contact') {
              homeColorMode = null;
              contactBtn.style.background = 'white';
              contactBtn.style.fontWeight = 'normal';
              hideHomeColorLegend();
            } else {
              homeColorMode = 'contact';
              contactBtn.style.background = '#e8f4f8';
              contactBtn.style.fontWeight = '600';
              damageBtn.style.background = 'white';
              damageBtn.style.fontWeight = 'normal';
              showHomeColorLegend('contact');
            }
            recolorHomeMapMarkers();
          };
          
          damageBtn.onclick = () => {
            if (homeColorMode === 'damage') {
              homeColorMode = null;
              damageBtn.style.background = 'white';
              damageBtn.style.fontWeight = 'normal';
              hideHomeColorLegend();
            } else {
              homeColorMode = 'damage';
              damageBtn.style.background = '#e8f4f8';
              damageBtn.style.fontWeight = '600';
              contactBtn.style.background = 'white';
              contactBtn.style.fontWeight = 'normal';
              showHomeColorLegend('damage');
            }
            recolorHomeMapMarkers();
          };
          
          L.DomEvent.disableClickPropagation(container);
          
          return container;
        }
      });
      
      // Remove old control if it exists
      if (homeColorFilterControl && homeMap) {
        try {
          homeMap.removeControl(homeColorFilterControl);
        } catch (e) {
          // Control might already be removed
        }
        homeColorFilterControl = null;
      }
      
      // Create and store the control instance
      homeColorFilterControl = new ColorFilterControl({ position: 'topleft' });
      homeColorFilterControl.addTo(homeMap);
    }
    
    // Restore color mode from localStorage
    function restoreColorMode() {
      if (!zoneMap) return;
      
      const savedColorMode = localStorage.getItem('currentColorMode');
      if (!savedColorMode || savedColorMode === '') {
        currentColorMode = null;
        return;
      }
      
      // Find the color filter control buttons
      const controlContainer = document.querySelector('.color-filter-control');
      if (!controlContainer) return;
      
      const buttons = controlContainer.querySelectorAll('button');
      if (buttons.length < 2) return;
      
      const contactBtn = buttons[0];
      const damageBtn = buttons[1];
      
      if (savedColorMode === 'contact') {
        currentColorMode = 'contact';
        contactBtn.style.background = '#e8f4f8';
        contactBtn.style.fontWeight = '600';
        damageBtn.style.background = 'white';
        damageBtn.style.fontWeight = 'normal';
        showColorLegend('contact');
      } else if (savedColorMode === 'damage') {
        currentColorMode = 'damage';
        damageBtn.style.background = '#e8f4f8';
        damageBtn.style.fontWeight = '600';
        contactBtn.style.background = 'white';
        contactBtn.style.fontWeight = 'normal';
        showColorLegend('damage');
      }
      
      // Recolor markers after a short delay
      setTimeout(() => {
        recolorMarkers();
      }, 300);
    }

    // Ensure color filter control exists (creates if missing)
    function ensureColorFilterControl() {
      if (!zoneMap) return;
      
      // Check if control instance exists and is on the map
      if (colorFilterControl) {
        // Check if the control's DOM element still exists
        const existingControl = document.querySelector('.color-filter-control');
        if (existingControl) {
          // Control DOM exists, check if it's properly attached
          const mapContainer = zoneMap.getContainer();
          const controlContainer = existingControl.closest('.leaflet-control-container');
          
          if (controlContainer && mapContainer.contains(controlContainer)) {
            // Control is properly attached, just ensure it's visible
            if (controlContainer.style.display === 'none') {
              controlContainer.style.display = '';
            }
            return; // Control exists and is properly attached
          }
        }
        // Control instance exists but DOM is missing or detached - reset reference
        colorFilterControl = null;
      }
      
      // Check if control exists in DOM but we don't have a reference
      const existingControl = document.querySelector('.color-filter-control');
      if (existingControl) {
        const mapContainer = zoneMap.getContainer();
        const controlContainer = existingControl.closest('.leaflet-control-container');
        
        if (controlContainer && mapContainer.contains(controlContainer)) {
          // Control exists and is attached, we're good
          if (controlContainer.style.display === 'none') {
            controlContainer.style.display = '';
          }
          return;
        }
        // Control exists but isn't properly attached - remove it
        if (existingControl.parentNode) {
          existingControl.parentNode.removeChild(existingControl);
        }
      }
      
      // Control doesn't exist, create it
      // First verify the map container is visible and ready
      const mapDiv = document.getElementById('zoneMap');
      if (mapDiv && mapDiv.offsetParent !== null) {
        createColorFilterControl();
        // After creating, verify it was actually added and has functional buttons
        setTimeout(() => {
          const newControl = document.querySelector('.color-filter-control');
          const buttons = newControl ? newControl.querySelectorAll('button') : [];
          if (!newControl || buttons.length < 2) {
            // Control creation failed or buttons missing, try again
            console.log('Color filter control verification failed, retrying...');
            if (newControl && newControl.parentNode) {
              newControl.parentNode.removeChild(newControl);
            }
            if (colorFilterControl && zoneMap) {
              try {
                zoneMap.removeControl(colorFilterControl);
              } catch (e) {
                // Control might not be properly attached
              }
              colorFilterControl = null;
            }
            createColorFilterControl();
          }
        }, 150);
      } else {
        // Map container not ready yet, schedule retry
        setTimeout(() => {
          ensureColorFilterControl();
        }, 200);
      }
    }

    // Start watchdog to monitor color filter control
    function startColorFilterWatchdog() {
      // Clear existing watchdog if any
      if (colorFilterWatchdog) {
        clearInterval(colorFilterWatchdog);
        colorFilterWatchdog = null;
      }
      
      // Only run watchdog when on map view
      colorFilterWatchdog = setInterval(() => {
        if (currentView === 'map' && zoneMap) {
          const control = document.querySelector('.color-filter-control');
          if (!control) {
            // Control is missing, recreate it
            console.log('Color filter control missing, recreating...');
            ensureColorFilterControl();
            // Restore color mode after recreating
            setTimeout(() => {
              restoreColorMode();
            }, 100);
          }
        } else {
          // Not on map view, stop watchdog
          if (colorFilterWatchdog) {
            clearInterval(colorFilterWatchdog);
            colorFilterWatchdog = null;
          }
        }
      }, 1000); // Check every second
    }

    // Stop watchdog
    function stopColorFilterWatchdog() {
      if (colorFilterWatchdog) {
        clearInterval(colorFilterWatchdog);
        colorFilterWatchdog = null;
      }
    }

    // Create color filter control
    function createColorFilterControl() {
      const ColorFilterControl = L.Control.extend({
        onAdd: function(map) {
          const container = L.DomUtil.create('div', 'color-filter-control');
          container.style.cssText = 'background: white; border-radius: 4px; box-shadow: 0 1px 5px rgba(0,0,0,0.4); padding: 8px; font-size: 0.75rem; min-width: 140px;';
          
          // Header
          const header = L.DomUtil.create('div', 'color-filter-header', container);
          header.textContent = 'Color By:';
          header.style.cssText = 'font-weight: 600; margin-bottom: 6px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;';
          
          // Contact Status button
          const contactBtn = L.DomUtil.create('button', 'color-filter-btn', container);
          contactBtn.textContent = 'Contact Status';
          contactBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.75rem; text-align: left; transition: all 0.2s;';
          contactBtn.onmouseover = () => contactBtn.style.background = '#f5f5f5';
          contactBtn.onmouseout = () => {
            if (currentColorMode !== 'contact') contactBtn.style.background = 'white';
          };
          
          // Damage Status button
          const damageBtn = L.DomUtil.create('button', 'color-filter-btn', container);
          damageBtn.textContent = 'Damage Status';
          damageBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.75rem; text-align: left; transition: all 0.2s;';
          damageBtn.onmouseover = () => damageBtn.style.background = '#f5f5f5';
          damageBtn.onmouseout = () => {
            if (currentColorMode !== 'damage') damageBtn.style.background = 'white';
          };
          
          // Click handlers
          contactBtn.onclick = () => {
            if (currentColorMode === 'contact') {
              currentColorMode = null;
              contactBtn.style.background = 'white';
              contactBtn.style.fontWeight = 'normal';
              hideColorLegend();
              localStorage.setItem('currentColorMode', '');
            } else {
              currentColorMode = 'contact';
              contactBtn.style.background = '#e8f4f8';
              contactBtn.style.fontWeight = '600';
              damageBtn.style.background = 'white';
              damageBtn.style.fontWeight = 'normal';
              showColorLegend('contact');
              localStorage.setItem('currentColorMode', 'contact');
            }
            recolorMarkers();
          };
          
          damageBtn.onclick = () => {
            if (currentColorMode === 'damage') {
              currentColorMode = null;
              damageBtn.style.background = 'white';
              damageBtn.style.fontWeight = 'normal';
              hideColorLegend();
              localStorage.setItem('currentColorMode', '');
            } else {
              currentColorMode = 'damage';
              damageBtn.style.background = '#e8f4f8';
              damageBtn.style.fontWeight = '600';
              contactBtn.style.background = 'white';
              contactBtn.style.fontWeight = 'normal';
              showColorLegend('damage');
              localStorage.setItem('currentColorMode', 'damage');
            }
            recolorMarkers();
          };
          
          // Don't restore color mode here - let restoreColorMode() handle it after control is fully added
          // This ensures buttons are fully ready and attached before trying to restore state
          
          L.DomEvent.disableClickPropagation(container);
          
          return container;
        }
      });
      
      // Remove old control if it exists
      if (colorFilterControl && zoneMap) {
        try {
          zoneMap.removeControl(colorFilterControl);
        } catch (e) {
          // Control might already be removed
        }
        colorFilterControl = null;
      }
      
      // Create and store the control instance
      colorFilterControl = new ColorFilterControl({ position: 'topleft' });
      colorFilterControl.addTo(zoneMap);
      
      // After control is added, restore color mode (buttons will be ready)
      setTimeout(() => {
        restoreColorMode();
      }, 100);
    }

    // Initialize Leaflet map
    function initializeMap() {
      const mapDiv = document.getElementById('zoneMap');
      if (!mapDiv) {
        console.error('Map div not found');
        return;
      }
      
      if (!zoneMap) {
        try {
          // Default center (Altadena, CA - adjust as needed)
          zoneMap = L.map('zoneMap').setView([34.19, -118.15], 12);
          
          // Add OpenStreetMap tiles (default)
          currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: ' OpenStreetMap contributors',
            maxZoom: 19
          }).addTo(zoneMap);
          
          // Create satellite toggle control
          const SatelliteToggleControl = L.Control.extend({
            onAdd: function(map) {
              const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
              const button = L.DomUtil.create('a', 'satellite-toggle-btn', container);
              button.href = '#';
              button.title = 'Switch to satellite view';
              button.innerHTML = '';
              button.style.cssText = 'width: 30px; height: 30px; line-height: 30px; text-align: center; text-decoration: none; display: block; font-size: 18px;';
              
              L.DomEvent.disableClickPropagation(button);
              L.DomEvent.on(button, 'click', L.DomEvent.stop);
              L.DomEvent.on(button, 'click', () => {
                if (!zoneMap) return;
                
                // Remove current tile layer
                if (currentTileLayer) {
                  zoneMap.removeLayer(currentTileLayer);
                }
                
                // Toggle between street and satellite
                if (isSatelliteMode) {
                  // Switch to street map
                  currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: ' OpenStreetMap contributors',
                    maxZoom: 19
                  }).addTo(zoneMap);
                  button.innerHTML = '';
                  button.title = 'Switch to satellite view';
                  isSatelliteMode = false;
                } else {
                  // Switch to satellite - using Google Satellite for more recent imagery
                  currentTileLayer = L.tileLayer('https://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                    subdomains: ['0', '1', '2', '3'],
                    attribution: ' Google',
                    maxZoom: 20
                  }).addTo(zoneMap);
                  button.innerHTML = '';
                  button.title = 'Switch to street map';
                  isSatelliteMode = true;
                }
              });
              
              return container;
            }
          });
          
          // Add satellite toggle control next to zoom controls
          new SatelliteToggleControl({ position: 'topleft' }).addTo(zoneMap);
          
          // Don't create color filter control here - it will be created via ensureColorFilterControl()
          // after the map container is visible and ready
          
          // Invalidate size to ensure map renders correctly in full screen
          // Use a longer delay and check if container is visible
          setTimeout(() => {
            if (zoneMap) {
              const mapDiv = document.getElementById('zoneMap');
              if (mapDiv && mapDiv.offsetParent !== null) {
                zoneMap.invalidateSize();
                // Now that map is ready and visible, ensure color filter control exists
                if (currentView === 'map') {
                  ensureColorFilterControl();
                  // Restore color mode after a short delay to ensure control is fully ready
                  setTimeout(() => {
                    restoreColorMode();
                  }, 200);
                }
              }
            }
          }, 500); // Increased delay to ensure map is fully ready
          
          console.log('Map initialized');
        } catch (error) {
          console.error('Error initializing map:', error);
        }
      } else {
        // If map already exists, invalidate size in case container changed
        // Only invalidate if container is visible
        setTimeout(() => {
          if (zoneMap) {
            const mapDiv = document.getElementById('zoneMap');
            if (mapDiv && mapDiv.offsetParent !== null) {
              zoneMap.invalidateSize();
              // Ensure color filter control exists when map already exists
              if (currentView === 'map') {
                ensureColorFilterControl();
                // Restore color mode after a short delay
                setTimeout(() => {
                  restoreColorMode();
                }, 200);
              }
            }
          }
        }, 300);
      }
      
      // Load KML if URL is provided (commented out for now)
      // const kmlUrlInput = document.getElementById("kmlUrlInput");
      // const kmlUrl = kmlUrlInput && kmlUrlInput.value ? kmlUrlInput.value.trim() : '';
      // if (kmlUrl) {
      //   loadKMLBoundary(kmlUrl);
      // }
    }

    // Initialize homepage map
    function initializeHomeMap() {
      const mapDiv = document.getElementById('homeMap');
      if (!mapDiv) {
        console.log('Home map div not found');
        return;
      }
      
      if (!homeMap) {
        try {
          // Default center (Altadena, CA - adjust as needed)
          homeMap = L.map('homeMap').setView([34.19, -118.15], 12);
          
          // Add OpenStreetMap tiles (default)
          homeTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: ' OpenStreetMap contributors',
            maxZoom: 19
          }).addTo(homeMap);
          
          // Create satellite toggle control for home map
          const HomeSatelliteToggleControl = L.Control.extend({
            onAdd: function(map) {
              const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
              const button = L.DomUtil.create('a', 'satellite-toggle-btn', container);
              button.href = '#';
              button.title = 'Switch to satellite view';
              button.innerHTML = '';
              button.style.cssText = 'width: 30px; height: 30px; line-height: 30px; text-align: center; text-decoration: none; display: block; font-size: 18px;';
              
              L.DomEvent.disableClickPropagation(button);
              L.DomEvent.on(button, 'click', L.DomEvent.stop);
              L.DomEvent.on(button, 'click', () => {
                if (!homeMap) return;
                
                // Remove current tile layer
                if (homeTileLayer) {
                  homeMap.removeLayer(homeTileLayer);
                }
                
                // Toggle between street and satellite
                if (isHomeSatelliteMode) {
                  // Switch to street map
                  homeTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: ' OpenStreetMap contributors',
                    maxZoom: 19
                  }).addTo(homeMap);
                  button.innerHTML = '';
                  button.title = 'Switch to satellite view';
                  isHomeSatelliteMode = false;
                } else {
                  // Switch to satellite - using Google Satellite for more recent imagery
                  homeTileLayer = L.tileLayer('https://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                    subdomains: ['0', '1', '2', '3'],
                    attribution: ' Google',
                    maxZoom: 20
                  }).addTo(homeMap);
                  button.innerHTML = '';
                  button.title = 'Switch to street map';
                  isHomeSatelliteMode = true;
                }
              });
              
              return container;
            }
          });
          
          // Add satellite toggle control next to zoom controls
          new HomeSatelliteToggleControl({ position: 'topleft' }).addTo(homeMap);
          
          // Invalidate size to ensure map renders correctly
          setTimeout(() => {
            if (homeMap) {
              homeMap.invalidateSize();
            }
          }, 100);
          
          console.log('Home map initialized');
        } catch (error) {
          console.error('Error initializing home map:', error);
        }
      } else {
        // If map already exists, invalidate size in case container changed
        setTimeout(() => {
          if (homeMap) {
            homeMap.invalidateSize();
          }
        }, 100);
      }
      
      // Update markers on home map
      updateHomeMapMarkers();
      
      // Create color filter control for home map
      createHomeColorFilterControl();
      
      // Load KML if URL is provided (with delay to ensure map is fully ready)
      if (zoneKmlUrl) {
        console.log('Home map initialized, zoneKmlUrl exists:', zoneKmlUrl);
        setTimeout(() => {
          if (homeMap && zoneKmlUrl) {
            console.log('Attempting to load KML on home map after initialization delay');
            loadHomeKMLBoundary(zoneKmlUrl);
          } else {
            console.log('Home map or zoneKmlUrl not available after delay', { homeMap: !!homeMap, zoneKmlUrl });
          }
        }, 300);
      } else {
        console.log('No zoneKmlUrl when initializing home map');
      }
    }

    // Update homepage map markers
    function updateHomeMapMarkers() {
      if (!sheetData || !sheetData.addressMap || !homeMap) {
        return;
      }
      
      // Clear existing markers
      homeMapMarkers.forEach(marker => homeMap.removeLayer(marker));
      homeMapMarkers = [];
      
      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      
      // Find lat/lon columns
      const latCol = headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lat') || lower === 'latitude';
      });
      const lonCol = headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lon') || lower.includes('lng') || lower === 'longitude';
      });
      
      if (!latCol || !lonCol) {
        console.log('Lat/Lon columns not found for home map');
        return;
      }
      
      // Get all addresses
      const addresses = Array.from(addressMap.keys());
      const bounds = [];
      
      addresses.forEach(address => {
        const rows = addressMap.get(address);
        if (!rows || rows.length === 0) return;
        
        const row = rows[0];
        const latVal = row[latCol];
        const lonVal = row[lonCol];
        
        if (latVal && lonVal) {
          const lat = parseFloat(latVal);
          const lon = parseFloat(lonVal);
          
          if (!isNaN(lat) && !isNaN(lon)) {
            addHomeMapMarker(address, lat, lon, rows);
            bounds.push([lat, lon]);
          }
        }
      });
      
      // Fit bounds to show all markers
      if (bounds.length > 0 && homeMap) {
        homeMap.fitBounds(bounds, { padding: [20, 20] });
      }
    }

    // Add marker to homepage map
    function addHomeMapMarker(address, lat, lng, rows) {
      if (!homeMap) return;
      
      let icon;
      if (homeColorMode) {
        const color = getHomeMapMarkerColor(address);
        if (color) {
          icon = createColoredMarkerIcon(color, false);
        } else {
          // Fallback to default blue
          icon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [20, 32],
            iconAnchor: [10, 32],
            popupAnchor: [1, -28],
            shadowSize: [32, 32]
          });
        }
      } else {
        // Default blue marker
        icon = L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
          shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
          iconSize: [20, 32],
          iconAnchor: [10, 32],
          popupAnchor: [1, -28],
          shadowSize: [32, 32]
        });
      }
      
      const marker = L.marker([lat, lng], { icon }).addTo(homeMap);
      
      // Build popup content (same as main map)
      let popupContent = `<strong>${address}</strong>`;
      
      // Get resident names and ages
      const nameCol = sheetData.headers.find(h => h.toLowerCase().includes('resident name') || h.toLowerCase().includes('name'));
      const ageCol = sheetData.headers.find(h => h.toLowerCase() === 'age');
      const residents = [];
      rows.forEach(row => {
        if (nameCol && row[nameCol] && row[nameCol].trim()) {
          let residentLine = row[nameCol].trim();
          // Add age if available
          if (ageCol && row[ageCol] && row[ageCol].toString().trim()) {
            residentLine += ', ' + row[ageCol].toString().trim();
          }
          residents.push(residentLine);
        }
      });
      if (residents.length > 0) {
        popupContent += '<br>' + residents.join('<br>');
      }
      
      // Get damage and household status
      const firstRow = rows[0];
      const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
      const info = [];
      if (damageCol && firstRow[damageCol] && firstRow[damageCol].trim()) {
        info.push(firstRow[damageCol].trim());
      }
      if (statusCol && firstRow[statusCol] && firstRow[statusCol].trim()) {
        info.push(firstRow[statusCol].trim());
      }
      if (info.length > 0) {
        popupContent += '<br><small>' + info.join('  ') + '</small>';
      }
      
      // Add popup with address, residents, and info
      marker.bindPopup(popupContent);
      
      // Click handler to show address details (same as main map)
      marker.on('click', () => {
        displayAddressDetails(address);
      });
      
      marker.address = address;
      
      homeMapMarkers.push(marker);
    }

    // Recolor all home map markers based on home color mode
    function recolorHomeMapMarkers() {
      if (!homeMapMarkers || !homeMap) return;
      
      homeMapMarkers.forEach(marker => {
        const address = marker.address;
        
        if (homeColorMode) {
          const color = getHomeMapMarkerColor(address);
          if (color) {
            marker.setIcon(createColoredMarkerIcon(color, false));
          } else {
            // Fallback to default blue
            marker.setIcon(L.icon({
              iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
              shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
              iconSize: [20, 32],
              iconAnchor: [10, 32],
              popupAnchor: [1, -28],
              shadowSize: [32, 32]
            }));
          }
        } else {
          // Default blue marker
          marker.setIcon(L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [20, 32],
            iconAnchor: [10, 32],
            popupAnchor: [1, -28],
            shadowSize: [32, 32]
          }));
        }
      });
    }

    // Load KML boundary for homepage
    async function loadHomeKMLBoundary(kmlUrl) {
      if (!kmlUrl || !kmlUrl.trim()) {
        console.log('No KML URL provided for home map');
        return;
      }
      
      if (!homeMap) {
        console.log('Home map not initialized yet, will retry');
        // Retry after a delay if map isn't ready
        setTimeout(() => {
          if (homeMap && kmlUrl) {
            loadHomeKMLBoundary(kmlUrl);
          }
        }, 500);
        return;
      }
      
      try {
        // Remove existing KML layer
        if (homeKmlLayer) {
          homeMap.removeLayer(homeKmlLayer);
          homeKmlLayer = null;
        }
        
        // Clean the URL - remove any quotes or extra whitespace
        const cleanUrl = kmlUrl.replace(/^["']|["']$/g, '').trim();
        console.log('Cleaned KML URL for home map:', cleanUrl);
        
        // Convert Google Drive URL if needed
        const directUrl = convertGoogleDriveUrl(cleanUrl);
        console.log('Loading KML for home map from:', directUrl);
        
        // Fetch KML file with CORS proxy fallback and timeout handling (same as main map)
        let kmlText;
        try {
          // Try direct fetch first with timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
          
          try {
            const response = await fetch(directUrl, { signal: controller.signal });
            clearTimeout(timeoutId);
            
            if (!response.ok) {
              throw new Error(`Direct fetch failed: ${response.status}`);
            }
            kmlText = await response.text();
          } catch (fetchError) {
            clearTimeout(timeoutId);
            throw fetchError; // Re-throw to be caught by outer catch
          }
        } catch (error) {
          // If direct fetch fails (CORS issue or timeout), try multiple proxy services
          if (error.name === 'AbortError') {
            console.log('Direct fetch timed out for home map, trying CORS proxy...');
          } else {
            console.log('Direct fetch failed for home map, trying CORS proxy...', error);
          }
          
          // Try multiple proxy services with fallback
          const proxyServices = [
            `https://api.allorigins.win/raw?url=${encodeURIComponent(directUrl)}`,
            `https://cors-anywhere.herokuapp.com/${directUrl}`,
            `https://corsproxy.io/?${encodeURIComponent(directUrl)}`
          ];
          
          let proxySuccess = false;
          for (const proxyUrl of proxyServices) {
            try {
              const proxyResponse = await fetch(proxyUrl);
              if (proxyResponse.ok) {
                kmlText = await proxyResponse.text();
                console.log('Successfully loaded KML for home map via proxy');
                proxySuccess = true;
                break;
              }
            } catch (proxyError) {
              console.log('Proxy failed, trying next...', proxyError);
              continue;
            }
          }
          
          if (!proxySuccess) {
            throw new Error('All proxy services failed');
          }
        }
        
        const parser = new DOMParser();
        const kml = parser.parseFromString(kmlText, 'text/xml');
        const parseError = kml.querySelector('parsererror');
        if (parseError) {
          console.error('KML parsing error for home map:', parseError.textContent);
          throw new Error('KML parsing error');
        }
        
        if (typeof toGeoJSON !== 'undefined' && toGeoJSON.kml) {
          const geojson = toGeoJSON.kml(kml);
          homeKmlLayer = L.geoJSON(geojson, {
            style: {
              color: '#214025',
              weight: 2,
              opacity: 0.8,
              fillColor: '#214025',
              fillOpacity: 0.1
            }
          }).addTo(homeMap);
          
          console.log('KML boundary loaded successfully on home map');
          
          if (homeKmlLayer.getBounds && homeKmlLayer.getBounds().isValid()) {
            homeMap.fitBounds(homeKmlLayer.getBounds(), { padding: [10, 10] });
          }
        } else {
          console.error('toGeoJSON not available for home map KML loading');
        }
      } catch (error) {
        console.error('Error loading KML for home map:', error);
      }
    }

    // Convert Google Drive sharing URL to direct download URL
    function convertGoogleDriveUrl(url) {
      // Extract file ID from Google Drive sharing URL
      // Format: https://drive.google.com/file/d/FILE_ID/view?usp=sharing
      // Or: https://drive.google.com/open?id=FILE_ID
      let fileId = null;
      
      // Try pattern 1: /file/d/FILE_ID/
      const match1 = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
      if (match1 && match1[1]) {
        fileId = match1[1];
      } else {
        // Try pattern 2: ?id=FILE_ID
        const match2 = url.match(/[?&]id=([a-zA-Z0-9_-]+)/);
        if (match2 && match2[1]) {
          fileId = match2[1];
        }
      }
      
      if (fileId) {
        // Try alternative Google Drive export URL format
        // The confirm=t parameter sometimes helps bypass virus scan
        return `https://drive.google.com/uc?export=download&id=${fileId}&confirm=t`;
      }
      
      // If it's already a direct download URL or other format, return as-is
      return url;
    }

    // Load KML boundary
    async function loadKMLBoundary(kmlUrl) {
      if (!kmlUrl || !kmlUrl.trim()) {
        console.log('No KML URL provided');
        return;
      }
      
      try {
        // Remove existing KML layer
        if (kmlLayer) {
          zoneMap.removeLayer(kmlLayer);
        }
        
        // Clean the URL - remove any quotes or extra whitespace
        const cleanUrl = kmlUrl.replace(/^["']|["']$/g, '').trim();
        console.log('Cleaned KML URL:', cleanUrl);
        
        // Convert Google Drive URL if needed
        const directUrl = convertGoogleDriveUrl(cleanUrl);
        console.log('Loading KML from:', directUrl);
        
        // Fetch KML file with CORS proxy fallback and timeout handling
        let kmlText;
        try {
          // Try direct fetch first with timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
          
          try {
            const response = await fetch(directUrl, { signal: controller.signal });
            clearTimeout(timeoutId);
            
            if (!response.ok) {
              throw new Error(`Direct fetch failed: ${response.status}`);
            }
            kmlText = await response.text();
          } catch (fetchError) {
            clearTimeout(timeoutId);
            throw fetchError; // Re-throw to be caught by outer catch
          }
        } catch (error) {
          // If direct fetch fails (CORS issue or timeout), try multiple proxy services
          if (error.name === 'AbortError') {
            console.log('Direct fetch timed out, trying CORS proxy...');
          } else {
            console.log('Direct fetch failed, trying CORS proxy...', error);
          }
          
          // Try multiple proxy services with fallback
          const proxyServices = [
            `https://api.allorigins.win/raw?url=${encodeURIComponent(directUrl)}`,
            `https://corsproxy.io/?${encodeURIComponent(directUrl)}`,
            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(directUrl)}`
          ];
          
          let lastError = null;
          let success = false;
          
          for (const proxyUrl of proxyServices) {
            try {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 second timeout for proxy
              
              const response = await fetch(proxyUrl, { signal: controller.signal });
              clearTimeout(timeoutId);
              
              if (response.ok) {
                kmlText = await response.text();
                success = true;
                console.log('Successfully loaded KML via proxy:', proxyUrl);
                break; // Success, exit loop
              } else {
                lastError = new Error(`Proxy returned ${response.status}: ${response.statusText}`);
                console.log(`Proxy ${proxyUrl} returned ${response.status}`);
              }
            } catch (proxyError) {
              if (proxyError.name === 'AbortError') {
                lastError = new Error('Proxy request timed out');
              } else {
                lastError = proxyError;
              }
              console.log(`Proxy ${proxyUrl} failed:`, lastError.message);
              continue; // Try next proxy
            }
          }
          
          if (!success) {
            throw new Error(`Failed to fetch KML: ${lastError ? lastError.message : 'All proxy services failed'}. The KML file may be too large, the URL may be invalid, or the file may not be publicly accessible. Try using a direct download link or a smaller KML file.`);
          }
        }
        
        // Parse KML to GeoJSON
        const parser = new DOMParser();
        const kml = parser.parseFromString(kmlText, 'text/xml');
        
        // Check for parsing errors
        const parseError = kml.querySelector('parsererror');
        if (parseError) {
          throw new Error('KML parsing error: ' + parseError.textContent);
        }
        
        // Convert KML to GeoJSON (toGeoJSON is from @mapbox/togeojson)
        let geojson;
        if (typeof toGeoJSON !== 'undefined' && toGeoJSON.kml) {
          geojson = toGeoJSON.kml(kml);
        } else {
          throw new Error('toGeoJSON library not loaded');
        }
        
        // Add to map
        kmlLayer = L.geoJSON(geojson, {
          style: {
            color: '#214025',
            weight: 3,
            opacity: 0.8,
            fillColor: '#214025',
            fillOpacity: 0.1
          }
        }).addTo(zoneMap);
        
        // Fit map to boundary
        if (kmlLayer.getBounds && kmlLayer.getBounds().isValid()) {
          zoneMap.fitBounds(kmlLayer.getBounds(), { padding: [20, 20] });
        }
      } catch (error) {
        console.error('Error loading KML:', error);
        alert('Error loading KML file: ' + error.message);
      }
    }

    // Highlight the selected address marker
    function highlightSelectedMarker(address) {
      if (!zoneMap || !addressMarkers) return;
      
      let selectedMarker = null;
      addressMarkers.forEach(marker => {
        if (marker.address === address) {
          selectedMarker = marker;
          // Highlight selected marker - use colored icon if color mode is active
          if (currentColorMode) {
            const color = getMarkerColor(address);
            if (color) {
              marker.setIcon(createColoredMarkerIcon(color, true));
            } else {
              marker.setIcon(L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
              }));
            }
          } else {
            marker.setIcon(L.icon({
              iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
              shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41]
            }));
          }
        } else if (selectedAddress && marker.address !== selectedAddress) {
          // Reset other markers - use colored icon if color mode is active
          if (currentColorMode) {
            const color = getMarkerColor(marker.address);
            if (color) {
              marker.setIcon(createColoredMarkerIcon(color, false));
            } else {
              marker.setIcon(L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
              }));
            }
          } else {
            marker.setIcon(L.icon({
              iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
              shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41]
            }));
          }
        }
      });
      
      // Don't pan or zoom - just highlight the marker
    }

    // Update map markers based on filtered addresses
    function updateMapMarkers() {
      if (!sheetData || !sheetData.addressMap) {
        console.log('No sheet data available for map');
        return;
      }
      
      // Make sure map is initialized
      if (!zoneMap) {
        console.log('Map not initialized, initializing now...');
        initializeMap();
        if (!zoneMap) {
          console.error('Failed to initialize map');
          return;
        }
      }
      
      // Clear existing markers
      addressMarkers.forEach(marker => zoneMap.removeLayer(marker));
      addressMarkers = [];
      
      // Get filtered addresses (same logic as displayAddressTable)
      const addresses = Array.from(sheetData.addressMap.keys());
      const contactDateCol = sheetData.headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));
      const filteredAddresses = addresses.filter(address => {
        // Street filter
        if (currentStreetFilter !== 'all') {
          const street = extractStreet(address);
          if (street !== currentStreetFilter) return false;
        }
        
        // Damage filter
        if (currentDamageFilter !== 'all') {
          const damage = getAddressDamage(address);
          if (currentDamageFilter === '') {
            // Filter for "(not set)" - addresses with no damage status
            if (damage && damage.trim() !== '' && damage !== '(not set)') return false;
          } else {
            if (damage !== currentDamageFilter) return false;
          }
        }
        
        // Status filter
        if (currentStatusFilter !== 'all') {
          const status = getAddressStatus(address);
          if (status !== currentStatusFilter) return false;
        }
        
        // Rebuild filter
        const rebuildCol = sheetData.headers.find(h => h.toLowerCase().includes('rebuild'));
        if (currentRebuildFilter !== 'all' && rebuildCol) {
          const rows = sheetData.addressMap.get(address);
          if (rows && rows[0]) {
            const rebuildValue = (rows[0][rebuildCol] || '').trim();
            if (rebuildValue !== currentRebuildFilter) return false;
          } else {
            return false;
          }
        }
        
        // Captain assigned filter
        if (currentCaptainFilter !== 'all') {
          const captainAssignedCol = sheetData.headers.find(h => h.toLowerCase().includes('captain assigned'));
          if (captainAssignedCol) {
            const rows = sheetData.addressMap.get(address);
            if (rows && rows[0]) {
              const captainValue = (rows[0][captainAssignedCol] || '').trim();
              if (currentCaptainFilter === '') {
                // Filter for "(not specified)" - addresses with no captain assigned
                if (captainValue && captainValue.trim() !== '') return false;
              } else {
                if (captainValue !== currentCaptainFilter) return false;
              }
            } else {
              // No rows for address - check if we're filtering for "(not specified)"
              if (currentCaptainFilter !== '') return false;
            }
          }
        }
        
        // Contact status filter
        if (contactDateCol) {
          const isContacted = isAddressContacted(address);
          if (isContacted && !showContactedAddresses) return false;
          if (!isContacted && !showUncontactedAddresses) return false;
        }
        
        return true;
      });
      
      // Check for lat/lon columns
      const latCol = sheetData.headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lat') || lower === 'latitude';
      });
      const lonCol = sheetData.headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lon') || lower.includes('lng') || lower === 'longitude';
      });
      
      console.log('Looking for coordinates - Lat column:', latCol, 'Lon column:', lonCol);
      console.log('Available headers:', sheetData.headers);
      
      if (!latCol || !lonCol) {
        console.log('Lat/Lon columns not found. Available columns:', sheetData.headers);
        return;
      }
      
      // Add markers for filtered addresses
      const bounds = [];
      let markerCount = 0;
      filteredAddresses.forEach(address => {
        const rows = sheetData.addressMap.get(address);
        if (!rows || rows.length === 0) return;
        
        const firstRow = rows[0];
        let lat, lon;
        
        // Try to get coordinates from lat/lon columns
        const latVal = firstRow[latCol];
        const lonVal = firstRow[lonCol];
        
        if (latVal !== undefined && latVal !== null && latVal !== '' && 
            lonVal !== undefined && lonVal !== null && lonVal !== '') {
          lat = parseFloat(String(latVal).trim());
          lon = parseFloat(String(lonVal).trim());
          if (isNaN(lat) || isNaN(lon)) {
            console.log(`Invalid coordinates for ${address}: lat=${latVal}, lon=${lonVal}`);
            return;
          }
        } else {
          return; // Skip if no coordinates
        }
        
        // Create marker
        try {
          // Use colored icon if color mode is active, otherwise use default
          const isSelected = selectedAddress === address;
          let icon;
          
          if (currentColorMode) {
            const color = getMarkerColor(address);
            if (color) {
              icon = createColoredMarkerIcon(color, isSelected);
            } else {
              // Fallback to default if no color determined
              icon = L.icon({
                iconUrl: isSelected 
                  ? 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png'
                  : 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
              });
            }
          } else {
            // Default: blue for normal, red for selected
            icon = L.icon({
              iconUrl: isSelected 
                ? 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png'
                : 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
              shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41]
            });
          }
          
          const marker = L.marker([lat, lon], { icon: icon }).addTo(zoneMap);
          
          // Build popup content
          let popupContent = `<strong>${address}</strong>`;
          
          // Get resident names and ages
          const nameCol = sheetData.headers.find(h => h.toLowerCase().includes('resident name') || h.toLowerCase().includes('name'));
          const ageCol = sheetData.headers.find(h => h.toLowerCase() === 'age');
          const residents = [];
          rows.forEach(row => {
            if (nameCol && row[nameCol] && row[nameCol].trim()) {
              let residentLine = row[nameCol].trim();
              // Add age if available
              if (ageCol && row[ageCol] && row[ageCol].toString().trim()) {
                residentLine += ', ' + row[ageCol].toString().trim();
              }
              residents.push(residentLine);
            }
          });
          if (residents.length > 0) {
            popupContent += '<br>' + residents.join('<br>');
          }
          
          // Get damage and household status
          const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
          const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
          const info = [];
          if (damageCol && firstRow[damageCol] && firstRow[damageCol].trim()) {
            info.push(firstRow[damageCol].trim());
          }
          if (statusCol && firstRow[statusCol] && firstRow[statusCol].trim()) {
            info.push(firstRow[statusCol].trim());
          }
          if (info.length > 0) {
            popupContent += '<br><small>' + info.join('  ') + '</small>';
          }
          
          // Add popup with address, residents, and info
          marker.bindPopup(popupContent);
          
          // Click handler to show address details
          marker.on('click', () => {
            displayAddressDetails(address);
          });
          
          // Store address with marker for highlighting
          marker.address = address;
          
          addressMarkers.push(marker);
          bounds.push([lat, lon]);
          markerCount++;
        } catch (error) {
          console.error(`Error creating marker for ${address}:`, error);
        }
      });
      
      console.log(`Added ${markerCount} markers to map`);
      
      if (markerCount === 0) {
        console.log('No markers created - check that Latitude and Longitude columns have data');
        return;
      }
      
      // Fit map to show all markers (if we have markers and no KML boundary)
      // Wait for map to be properly sized before fitting bounds
      setTimeout(() => {
        if (zoneMap && bounds.length > 0 && !kmlLayer) {
          const mapDiv = document.getElementById('zoneMap');
          if (mapDiv && mapDiv.offsetParent !== null) {
            try {
              zoneMap.fitBounds(bounds, { 
                padding: [20, 20],
                maxZoom: 16 // Prevent zooming in too close
              });
            } catch (error) {
              console.error('Error fitting bounds:', error);
            }
          }
        }
      }, 200);
    }

    // Satellite toggle is now handled by Leaflet control (created in initializeMap)

    // KML URL input handler (commented out for now)
    // if (kmlUrlInput) {
    //   kmlUrlInput.addEventListener('keypress', (e) => {
    //     if (e.key === 'Enter') {
    //       if (zoneMap) {
    //         loadKMLBoundary(kmlUrlInput.value.trim());
    //       }
    //     }
    //   });
    // }

    // Update Zone Notes UI
    function updateZoneNotesUI() {
      const zoneNotesText = document.getElementById('zoneNotesText');
      
      console.log('Updating Zone Notes UI, zoneNotes:', zoneNotes);
      
      if (zoneNotesText) {
        zoneNotesText.value = zoneNotes || '';
      } else {
        console.error('Zone Notes UI elements not found');
      }
    }

    // Tab switching functionality
    const addressesTab = document.getElementById('addressesTab');
    const zoneNotesTab = document.getElementById('zoneNotesTab');
    const zoneNotesContent = document.getElementById('zoneNotesContent');

    if (addressesTab && zoneNotesTab) {
      addressesTab.addEventListener('click', () => {
        addressesTab.classList.add('active');
        zoneNotesTab.classList.remove('active');
        if (addressPanelContent) addressPanelContent.style.display = 'block';
        if (zoneNotesContent) zoneNotesContent.style.display = 'none';
      });

      zoneNotesTab.addEventListener('click', () => {
        zoneNotesTab.classList.add('active');
        addressesTab.classList.remove('active');
        if (addressPanelContent) addressPanelContent.style.display = 'none';
        if (zoneNotesContent) zoneNotesContent.style.display = 'flex';
      });
    }

    // Save Zone Notes to Metadata sheet
    async function saveZoneNotes() {
      if (!metadataSheetId || !accessToken) {
        alert('Please sign in to save notes.');
        return;
      }

      const zoneNotesText = document.getElementById('zoneNotesText');
      const saveStatus = document.getElementById('zoneNotesStatus');
      const saveBtn = document.getElementById('saveZoneNotesBtn');
      
      if (!zoneNotesText) return;
      
      const newNotes = zoneNotesText.value.trim();
      saveBtn.disabled = true;
      saveStatus.textContent = 'Saving...';
      saveStatus.className = 'save-status-small';

      try {
        // First, try to read existing metadata to preserve KML URL
        let kmlUrlValue = zoneKmlUrl;
        try {
          const existingMetadata = await fetchMetadata(metadataSheetId);
          if (existingMetadata && existingMetadata.kmlUrl) {
            kmlUrlValue = existingMetadata.kmlUrl;
          }
        } catch (e) {
          // If Zone Notes sheet doesn't exist, we'll create it
        }

        // Prepare the metadata rows
        const values = [
          ['Zone Notes', newNotes],
          ['KML URL', kmlUrlValue || '']
        ];

        // Use batchUpdate to write to Zone Notes sheet
        const response = await fetch(
          `https://sheets.googleapis.com/v4/spreadsheets/${metadataSheetId}/values/Zone Notes!A1:B2?valueInputOption=USER_ENTERED`,
          {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              values: values
            })
          }
        );

        if (!response.ok) {
          // If Zone Notes sheet doesn't exist, try to create it first
          // For now, just show error - user can create the sheet manually
          throw new Error('Zone Notes sheet not found. Please create a sheet named "Zone Notes" with columns A (key) and B (value).');
        }

        zoneNotes = newNotes;
        saveStatus.textContent = 'Saved!';
        saveStatus.className = 'save-status-small saved';
        
        setTimeout(() => {
          saveStatus.textContent = '';
        }, 2000);

      } catch (error) {
        console.error('Save error:', error);
        saveStatus.textContent = `Error: ${error.message}`;
        saveStatus.className = 'save-status-small error';
      } finally {
        saveBtn.disabled = false;
      }
    }

    // Zone Notes save button handler
    const saveZoneNotesBtn = document.getElementById('saveZoneNotesBtn');
    if (saveZoneNotesBtn) {
      saveZoneNotesBtn.addEventListener('click', saveZoneNotes);
    }

    // Contact Mode toggle
    let contactModeActive = false;
    window.contactModeActive = false;
    const contactModeBtn = document.getElementById('contactModeBtn');
    if (contactModeBtn) {
      contactModeBtn.addEventListener('click', () => {
        contactModeActive = !contactModeActive;
        window.contactModeActive = contactModeActive;
        contactModeBtn.classList.toggle('active', contactModeActive);
        
        // If we're viewing an address detail, refresh it to show/hide contact mode UI
        const addressDetails = document.querySelector('.address-details.active');
        if (addressDetails) {
          const addressHeading = addressDetails.querySelector('h3');
          if (addressHeading) {
            const address = addressHeading.textContent.trim();
            displayAddressDetails(address);
          }
        }
      });
    }

    // Mark contact function
    window.markContact = async function(button, address, originalRowIndex, contactColumn) {
      if (!accessToken) {
        alert('Please sign in to mark contacts.');
        return;
      }

      // Get the current sheet URL - try multiple sources
      let sheetUrl = currentSheetUrl;
      if (!sheetUrl) {
        sheetUrl = localStorage.getItem('savedSheetUrl') || '';
      }
      if (!sheetUrl) {
        alert('No sheet loaded. Please load a spreadsheet first.');
        return;
      }

      const today = new Date().toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric' 
      });

      try {
        const sheetInfo = extractSheetId(sheetUrl);
        if (!sheetInfo || !sheetInfo.sheetId) {
          console.error('Sheet URL:', sheetUrl);
          console.error('Sheet Info:', sheetInfo);
          throw new Error('Invalid sheet URL. Make sure a spreadsheet is loaded.');
        }

        // Find the row to update (using originalRowIndex + 2 because row 1 is header, row 2 is first data)
        const rowNumber = originalRowIndex + 2;

        // Get column letters for contact date and contact notes
        const headers = sheetData.headers;
        const contactColIndex = headers.findIndex(h => 
          h.toLowerCase() === 'last contact date' ||
          h.toLowerCase().includes('last contact') || 
          h.toLowerCase().includes('contact date') ||
          h.toLowerCase().includes('contacted')
        );
        
        const contactNotesColIndex = headers.findIndex(h => 
          h.toLowerCase() === 'contact notes' ||
          h.toLowerCase().includes('contact notes')
        );

        console.log('Contact Notes column search:', {
          headers: headers,
          contactNotesColIndex: contactNotesColIndex,
          foundColumn: contactNotesColIndex >= 0 ? headers[contactNotesColIndex] : 'NOT FOUND'
        });

        // Get contact notes from the textarea
        const contactNotesTextarea = button.parentNode.querySelector('.contact-notes-quick');
        const contactNotes = contactNotesTextarea ? contactNotesTextarea.value.trim() : '';

        console.log('Contact notes from textarea:', contactNotes);

        // Prepare updates for both date and notes
        const updates = [];
        
        // Update Last Contact Date
        if (contactColIndex >= 0) {
          const columnLetter = indexToColumnLetter(contactColIndex);
          const sheetName = 'Sheet1';
          const cellRange = `${sheetName}!${columnLetter}${rowNumber}`;
          updates.push({
            range: cellRange,
            values: [[today]]
          });
          console.log('Adding Last Contact Date update:', cellRange, today);
        }

        // Update Contact Notes if column exists (save even if empty to allow clearing)
        if (contactNotesColIndex >= 0) {
          const notesColumnLetter = indexToColumnLetter(contactNotesColIndex);
          const sheetName = 'Sheet1';
          const notesCellRange = `${sheetName}!${notesColumnLetter}${rowNumber}`;
          updates.push({
            range: notesCellRange,
            values: [[contactNotes]]
          });
          console.log('Adding Contact Notes update:', notesCellRange, contactNotes);
        } else {
          console.warn('Contact Notes column not found in headers:', headers);
        }

        // Save both updates using batchUpdate
        if (updates.length > 0) {
          console.log('Sending batch update with', updates.length, 'updates:', updates);
          const response = await fetch(
            `https://sheets.googleapis.com/v4/spreadsheets/${sheetInfo.sheetId}/values:batchUpdate`,
            {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                valueInputOption: 'USER_ENTERED',
                data: updates
              })
            }
          );

          if (!response.ok) {
            const error = await response.json();
            console.error('Batch update error:', error);
            throw new Error(error.error?.message || 'Failed to save contact');
          }
          
          const result = await response.json();
          console.log('Batch update successful:', result);
        } else {
          console.warn('No updates to save');
        }

        // Update UI
        button.classList.add('contacted');
        button.textContent = ' Contacted';
        
        // Add date display if it doesn't exist
        const existingDate = button.parentNode.querySelector('.contact-date');
        if (!existingDate) {
          const dateDiv = document.createElement('div');
          dateDiv.className = 'contact-date';
          dateDiv.textContent = `Last contact: ${today}`;
          button.parentNode.insertBefore(dateDiv, button.nextSibling);
        } else {
          existingDate.textContent = `Last contact: ${today}`;
        }

        // Update local data
        if (sheetData && sheetData.data && sheetData.data[originalRowIndex]) {
          const contactCol = headers.find(h => 
            h.toLowerCase() === 'last contact date' ||
            h.toLowerCase().includes('last contact') || 
            h.toLowerCase().includes('contact date') ||
            h.toLowerCase().includes('contacted')
          ) || contactColumn;
          sheetData.data[originalRowIndex][contactCol] = today;
          
          // Update contact notes in local data if column exists
          if (contactNotesColIndex >= 0 && contactNotes) {
            const contactNotesCol = headers[contactNotesColIndex];
            sheetData.data[originalRowIndex][contactNotesCol] = contactNotes;
          }
          
          // Update address map
          if (sheetData.addressMap && sheetData.addressMap.has(address)) {
            const rows = sheetData.addressMap.get(address);
            const row = rows.find(r => r.__originalIndex === originalRowIndex);
            if (row) {
              row[contactCol] = today;
              if (contactNotesColIndex >= 0 && contactNotes) {
                const contactNotesCol = headers[contactNotesColIndex];
                row[contactNotesCol] = contactNotes;
              }
            }
          }
        }

        // Update person entry styling
        const personEntry = button.closest('.person-entry');
        if (personEntry) {
          personEntry.classList.remove('no-contact');
          personEntry.classList.add('recent-contact');
        }

      } catch (error) {
        console.error('Error marking contact:', error);
        alert('Error saving contact: ' + error.message);
      }
    };


    // Chart instances
    let peopleContactChart = null;
    let householdsContactChart = null;
    let damageChart = null;
    let householdStatusChart = null;
    let rebuildStatusChart = null;
    let zoneOverviewAddressesChart = null;
    let zoneOverviewDamageChart = null;
    
    // Chart carousel state
    let zoneOverviewCarouselLeft = { currentIndex: 0, charts: [] };
    let zoneOverviewCarouselRight = { currentIndex: 0, charts: [] };

    // Update Zone Progress Charts
    function updateZoneProgressCharts() {
      if (!sheetData || !sheetData.data || sheetData.data.length === 0) {
        return;
      }

      // Charts are now in the progress view, not a separate panel
      // The view will be shown/hidden by the navigation system

      const headers = sheetData.headers;
      const data = sheetData.data;

      // Find relevant columns
      const lastContactCol = headers.find(h => 
        h.toLowerCase() === 'last contact date' ||
        h.toLowerCase().includes('last contact') || 
        h.toLowerCase().includes('contact date') ||
        h.toLowerCase().includes('contacted')
      );
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));

      // 1. People Contacted Chart
      let peopleContacted = 0;
      let peopleNotContacted = 0;
      data.forEach(row => {
        const hasContact = lastContactCol && row[lastContactCol] && String(row[lastContactCol]).trim().length > 0;
        if (hasContact) {
          peopleContacted++;
        } else {
          peopleNotContacted++;
        }
      });

      const peopleTotal = peopleContacted + peopleNotContacted;
      const peopleContactedPct = peopleTotal > 0 ? ((peopleContacted / peopleTotal) * 100).toFixed(1) : '0';
      const peopleNotContactedPct = peopleTotal > 0 ? ((peopleNotContacted / peopleTotal) * 100).toFixed(1) : '0';

      const peopleContactCtx = document.getElementById('peopleContactChart');
      if (peopleContactChart) peopleContactChart.destroy();
      if (peopleContactCtx) {
        peopleContactChart = new Chart(peopleContactCtx, {
          type: 'pie',
          data: {
            labels: [`Contacted (${peopleContactedPct}%)`, `Not Contacted (${peopleNotContactedPct}%)`],
            datasets: [{
              data: [peopleContacted, peopleNotContacted],
              backgroundColor: ['#b4bd9b', '#bc455a'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    return context.label + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 2. Households Contacted Chart
      const households = new Set();
      const householdsContacted = new Set();
      const houseNumCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'House #' || lower === 'house #' || lower.includes('house #') || 
               lower.includes('house#') || lower === 'house number' || lower === 'house num' ||
               (lower === 'house' && !lower.includes('hold'));
      });
      const streetCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'Street' || lower === 'street' || (lower.includes('street') && !lower.includes('address'));
      });

      data.forEach(row => {
        const houseNum = houseNumCol ? (row[houseNumCol] || '').trim() : '';
        const street = streetCol ? (row[streetCol] || '').trim() : '';
        const address = houseNum && street ? `${houseNum} ${street}` : '';
        if (address) {
          households.add(address);
          const hasContact = lastContactCol && row[lastContactCol] && String(row[lastContactCol]).trim().length > 0;
          if (hasContact) {
            householdsContacted.add(address);
          }
        }
      });

      const householdsContactedCount = householdsContacted.size;
      const householdsNotContactedCount = households.size - householdsContactedCount;
      const householdsTotal = householdsContactedCount + householdsNotContactedCount;
      const householdsContactedPct = householdsTotal > 0 ? ((householdsContactedCount / householdsTotal) * 100).toFixed(1) : '0';
      const householdsNotContactedPct = householdsTotal > 0 ? ((householdsNotContactedCount / householdsTotal) * 100).toFixed(1) : '0';

      const householdsContactCtx = document.getElementById('householdsContactChart');
      if (householdsContactChart) householdsContactChart.destroy();
      if (householdsContactCtx) {
        householdsContactChart = new Chart(householdsContactCtx, {
          type: 'pie',
          data: {
            labels: [`Contacted (${householdsContactedPct}%)`, `Not Contacted (${householdsNotContactedPct}%)`],
            datasets: [{
              data: [householdsContactedCount, householdsNotContactedCount],
              backgroundColor: ['#b4bd9b', '#bc455a'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    return context.label + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 3. Damage Chart
      const damageCounts = {};
      let damageUnknown = 0;
      if (damageCol) {
        data.forEach(row => {
          const damage = row[damageCol] ? String(row[damageCol]).trim() : '';
          if (damage) {
            damageCounts[damage] = (damageCounts[damage] || 0) + 1;
          } else {
            damageUnknown++;
          }
        });
      } else {
        // If no damage column, all are unknown
        damageUnknown = data.length;
      }

      const damageLabels = Object.keys(damageCounts);
      const damageData = Object.values(damageCounts);
      const damageTotal = damageData.reduce((a, b) => a + b, 0) + damageUnknown;
      
      // Add Unknown if there are any
      if (damageUnknown > 0) {
        damageLabels.push('Unknown');
        damageData.push(damageUnknown);
      }
      
      // Calculate percentages for labels
      const damageLabelsWithPct = damageLabels.map((label, index) => {
        const value = damageData[index];
        const pct = damageTotal > 0 ? ((value / damageTotal) * 100).toFixed(1) : '0';
        return `${label} (${pct}%)`;
      });
      
      const damageColors = ['#bc455a', '#fdba77', '#b4bd9b', '#81bdc3', '#f6cf98', '#ccd5c3', '#f9d6d3'];

      const damageCtx = document.getElementById('damageChart');
      if (damageChart) damageChart.destroy();
      if (damageCtx && (damageLabels.length > 0 || damageUnknown > 0)) {
        damageChart = new Chart(damageCtx, {
          type: 'pie',
          data: {
            labels: damageLabelsWithPct,
            datasets: [{
              data: damageData,
              backgroundColor: damageColors.slice(0, damageLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    // Remove percentage from label for tooltip (it's already in the label)
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 4. Household Status Chart
      const statusCounts = {};
      let statusUnknown = 0;
      if (statusCol) {
        data.forEach(row => {
          const status = row[statusCol] ? String(row[statusCol]).trim() : '';
          if (status) {
            statusCounts[status] = (statusCounts[status] || 0) + 1;
          } else {
            statusUnknown++;
          }
        });
      } else {
        // If no status column, all are unknown
        statusUnknown = data.length;
      }

      const statusLabels = Object.keys(statusCounts);
      const statusData = Object.values(statusCounts);
      const statusTotal = statusData.reduce((a, b) => a + b, 0) + statusUnknown;
      
      // Add Unknown if there are any
      if (statusUnknown > 0) {
        statusLabels.push('Unknown');
        statusData.push(statusUnknown);
      }
      
      // Calculate percentages for labels
      const statusLabelsWithPct = statusLabels.map((label, index) => {
        const value = statusData[index];
        const pct = statusTotal > 0 ? ((value / statusTotal) * 100).toFixed(1) : '0';
        return `${label} (${pct}%)`;
      });
      
      const statusColors = ['#b4bd9b', '#81bdc3', '#fdba77', '#f6cf98', '#bc455a', '#ccd5c3', '#f9d6d3'];

      const statusCtx = document.getElementById('householdStatusChart');
      if (householdStatusChart) householdStatusChart.destroy();
      if (statusCtx && (statusLabels.length > 0 || statusUnknown > 0)) {
        householdStatusChart = new Chart(statusCtx, {
          type: 'pie',
          data: {
            labels: statusLabelsWithPct,
            datasets: [{
              data: statusData,
              backgroundColor: statusColors.slice(0, statusLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    // Remove percentage from label for tooltip (it's already in the label)
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
    }

    // Update Rebuild Progress Charts (bar charts for home page)
    function updateRebuildProgressCharts() {
      if (!sheetData || !sheetData.data || sheetData.data.length === 0) {
        return;
      }
      
      const headers = sheetData.headers;
      const data = sheetData.data;
      const addressMap = sheetData.addressMap;
      
      // Find relevant columns
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const rebuildCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('rebuild');
      });
      
      // 1. Household Status Bar Chart
      const statusCounts = {};
      let statusUnknown = 0;
      if (statusCol) {
        data.forEach(row => {
          const status = row[statusCol] ? String(row[statusCol]).trim() : '';
          if (status) {
            statusCounts[status] = (statusCounts[status] || 0) + 1;
          } else {
            statusUnknown++;
          }
        });
      } else {
        statusUnknown = data.length;
      }
      
      const statusLabels = Object.keys(statusCounts);
      const statusData = Object.values(statusCounts);
      if (statusUnknown > 0) {
        statusLabels.push('Unknown');
        statusData.push(statusUnknown);
      }
      
      const statusColors = ['#b4bd9b', '#81bdc3', '#fdba77', '#f6cf98', '#bc455a', '#ccd5c3', '#f9d6d3'];
      
      const statusCtx = document.getElementById('householdStatusChart');
      if (householdStatusChart) householdStatusChart.destroy();
      if (statusCtx && (statusLabels.length > 0 || statusUnknown > 0)) {
        // Calculate percentages for labels
        const statusTotal = statusData.reduce((a, b) => a + b, 0);
        const statusLabelsWithPct = statusLabels.map((label, index) => {
          const value = statusData[index];
          const pct = statusTotal > 0 ? ((value / statusTotal) * 100).toFixed(1) : '0';
          return `${label} (${pct}%)`;
        });
        
        householdStatusChart = new Chart(statusCtx, {
          type: 'doughnut',
          data: {
            labels: statusLabelsWithPct,
            datasets: [{
              data: statusData,
              backgroundColor: statusColors.slice(0, statusLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: '60%',
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10,
                labels: {
                  padding: 12,
                  font: {
                    size: 11
                  },
                  usePointStyle: true
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
      
      // 2. Rebuild Status Bar Chart
      const rebuildStages = [
        'Debris Removal & Site Clearance',
        'Professional Selection (Architect/Engineer & Builder)',
        'Plan Preparation & Design Stage',
        'Permit Application & Submittal',
        'Plan Check & Agency Review',
        'Plan Revision & Recheck',
        'Permit Issuance',
        'Construction',
        'Mandatory Inspections',
        'Final Inspection & Sign-Off',
        'Certificate of Occupancy'
      ];
      
      const rebuildCounts = {};
      rebuildStages.forEach(stage => {
        rebuildCounts[stage] = 0;
      });
      rebuildCounts['Not Started'] = 0;
      rebuildCounts['Unknown'] = 0;
      
      if (rebuildCol && addressMap) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          if (!row || !row[rebuildCol]) {
            rebuildCounts['Not Started']++;
            return;
          }
          
          const stage = String(row[rebuildCol] || '').trim();
          if (!stage || stage === '' || stage.toLowerCase() === 'none') {
            rebuildCounts['Not Started']++;
            return;
          }
          
          const stageLower = stage.toLowerCase();
          let matched = false;
          
          // Try exact match first (case-insensitive) with predefined stages
          for (const knownStage of rebuildStages) {
            const knownStageLower = knownStage.toLowerCase().trim();
            if (stageLower === knownStageLower) {
              rebuildCounts[knownStage]++;
              matched = true;
              break;
            }
          }
          
          // If no exact match, check for "Not Started" variations
          if (!matched) {
            if (stageLower.includes('not started') || 
                stageLower === 'none' ||
                stageLower === '') {
              rebuildCounts['Not Started']++;
              matched = true;
            }
          }
          
          // If still not matched, use the actual value from spreadsheet (preserve original case)
          // This allows for custom stages in the spreadsheet
          if (!matched) {
            // Check if we already have this exact value in rebuildCounts (preserve original case)
            if (rebuildCounts.hasOwnProperty(stage)) {
              rebuildCounts[stage]++;
            } else {
              // Use the actual stage value from spreadsheet (preserve original case)
              rebuildCounts[stage] = 1;
            }
          }
        });
      } else {
        rebuildCounts['Not Started'] = addressMap ? addressMap.size : 0;
      }
      
      // Collect all stages (predefined + custom from spreadsheet)
      const allStagesSet = new Set(rebuildStages);
      Object.keys(rebuildCounts).forEach(key => {
        if (key !== 'Not Started' && key !== 'Unknown') {
          allStagesSet.add(key);
        }
      });
      
      // Build final labels array: Not Started first, then predefined stages, then custom stages, then Unknown
      const customStages = Array.from(allStagesSet).filter(s => !rebuildStages.includes(s) && s !== 'Not Started' && s !== 'Unknown');
      const allRebuildLabels = ['Not Started', ...rebuildStages, ...customStages, 'Unknown'];
      
      // Generate data array for all labels (use 0 if stage doesn't exist in rebuildCounts)
      const rebuildData = allRebuildLabels.map(label => rebuildCounts[label] || 0);
      
      // Show all stages even if they're zero (as requested)
      const rebuildColors = ['#9e9e9e', '#bc455a', '#fdba77', '#f6cf98', '#b4bd9b', '#81bdc3', '#ccd5c3', '#f9d6d3', '#e0e0e0', '#d4a574', '#c8a2c8', '#a8d8ea'];
      
      const rebuildCtx = document.getElementById('rebuildStatusChart');
      if (rebuildStatusChart) rebuildStatusChart.destroy();
      if (rebuildCtx) {
        rebuildStatusChart = new Chart(rebuildCtx, {
          type: 'bar',
          data: {
            labels: allRebuildLabels,
            datasets: [{
              label: 'Count',
              data: rebuildData,
              backgroundColor: rebuildColors.slice(0, allRebuildLabels.length),
              borderColor: rebuildColors.slice(0, allRebuildLabels.length),
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    // Use the full label from allRebuildLabels array (not truncated version)
                    const fullLabel = allRebuildLabels[context.dataIndex] || context.label;
                    return fullLabel + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            },
            scales: {
              x: {
                beginAtZero: true,
                ticks: {
                  stepSize: 1,
                  precision: 0,
                  font: {
                    size: 11
                  }
                },
                grid: {
                  display: true,
                  color: 'rgba(0, 0, 0, 0.05)'
                }
              },
              y: {
                ticks: {
                  font: {
                    size: 10
                  },
                  maxRotation: 0,
                  autoSkip: false,
                  callback: function(value, index) {
                    const label = allRebuildLabels[index];
                    // Truncate long labels and show full text in tooltip
                    if (label && label.length > 35) {
                      return label.substring(0, 32) + '...';
                    }
                    return label;
                  }
                },
                grid: {
                  display: false
                }
              }
            },
            layout: {
              padding: {
                right: 10
              }
            }
          }
        });
      }
    }

    // Home Dashboard Functions
    
    // Update all home dashboard panels
    function updateHomeDashboard() {
      if (!sheetData || !sheetData.addressMap) {
        // Show empty state
        const zoneSnapshotContent = document.getElementById('zoneSnapshotContent');
        const homeMapContainer = document.getElementById('homeMapContainer');
        if (zoneSnapshotContent) {
          zoneSnapshotContent.innerHTML = '<div class="empty">Load a spreadsheet to see zone stats</div>';
        }
        if (homeMapContainer) {
          homeMapContainer.innerHTML = '<div class="empty">Load a spreadsheet to see map</div>';
        }
        return;
      }
      
      updateZoneSnapshot();
      updateZoneProgressCharts();
      updateRebuildProgressCharts();
      initializeHomeMap();
      // Load KML for home map if URL is available (in case it was set after map initialization)
      if (zoneKmlUrl) {
        console.log('updateHomeDashboard: zoneKmlUrl exists:', zoneKmlUrl);
        if (homeMap) {
          console.log('Home map exists, loading KML');
          loadHomeKMLBoundary(zoneKmlUrl);
        } else {
          console.log('Home map not initialized yet, will try after delay');
          setTimeout(() => {
            if (homeMap && zoneKmlUrl) {
              console.log('Loading KML on home map after delay in updateHomeDashboard');
              loadHomeKMLBoundary(zoneKmlUrl);
            }
          }, 500);
        }
      }
      fetchAndDisplayCentralFeed();
      displayQuickActions();
      updateZoneLeadership();
      
      // Update Actions page if it's currently visible
      if (currentView === 'meetups') {
        displayActionsPage();
      }
      
      // Update Zone Overview charts after a short delay to ensure DOM is ready
      setTimeout(() => {
        if (sheetData && sheetData.addressMap) {
          updateZoneOverviewCharts();
        }
      }, 100);
    }
    
    // Panel A: Zone Overview
    function updateZoneSnapshot() {
      if (!sheetData || !sheetData.addressMap || !sheetData.headers) {
        return;
      }
      
      const content = document.getElementById('zoneSnapshotContent');
      if (!content) return;
      
      const headers = sheetData.headers;
      const data = sheetData.data;
      const addressMap = sheetData.addressMap;
      
      // 1. Households in your zone (count of addresses)
      const householdsCount = addressMap.size;
      
      // 2. People in your zone (count unique resident names, or use "# of residents" field per address)
      const residentsCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('# of residents') || 
               lower.includes('number of residents') ||
               (lower.includes('#') && lower.includes('resident'));
      });
      
      const residentNameCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('resident name') || 
               lower.includes('name') && !lower.includes('household') && !lower.includes('address');
      });
      
      let peopleCount = 0;
      if (residentsCol) {
        // Use "# of residents" field - count per address, not per row
        addressMap.forEach((rows, address) => {
          const row = rows[0]; // Get first row for this address
          const residents = parseInt(row[residentsCol]) || 0;
          peopleCount += residents > 0 ? residents : 1;
        });
      } else if (residentNameCol) {
        // Count unique resident names across all addresses
        const uniqueResidents = new Set();
        addressMap.forEach((rows, address) => {
          rows.forEach(row => {
            const name = (row[residentNameCol] || '').trim();
            if (name) {
              uniqueResidents.add(name.toLowerCase());
            }
          });
        });
        peopleCount = uniqueResidents.size || householdsCount;
      } else {
        // Fallback: 1 person per address
        peopleCount = householdsCount;
      }
      
      // 3. Homes by damage status
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const damageCounts = {
        'Total Loss': 0,
        'Partial Loss': 0,
        'Standing Home': 0,
        'Unknown': 0
      };
      
      if (damageCol) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          const damage = (row[damageCol] || '').trim();
          if (damage) {
            const damageLower = damage.toLowerCase();
            if (damageLower.includes('total')) {
              damageCounts['Total Loss']++;
            } else if (damageLower.includes('partial')) {
              damageCounts['Partial Loss']++;
            } else if (damageLower.includes('standing')) {
              damageCounts['Standing Home']++;
            } else {
              // Check if it matches one of our known values
              if (damageCounts.hasOwnProperty(damage)) {
                damageCounts[damage]++;
              } else {
                damageCounts['Unknown']++;
              }
            }
          } else {
            damageCounts['Unknown']++;
          }
        });
      }
      
      // 4. Households not yet contacted
      const contactStatusCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('contact status');
      });
      const contactDateCol = headers.find(h => {
        const lower = h.toLowerCase();
        return (lower.includes('contact') && lower.includes('date')) ||
               lower.includes('last contact');
      });
      
      let uncontactedCount = 0;
      addressMap.forEach((rows, address) => {
        const row = rows[0];
        let isContacted = false;
        
        if (contactStatusCol && row[contactStatusCol]) {
          const status = String(row[contactStatusCol]).toLowerCase().trim();
          isContacted = status && !status.includes('uncontacted') && status !== 'no';
        } else if (contactDateCol && row[contactDateCol]) {
          const date = String(row[contactDateCol]).trim();
          isContacted = date.length > 0;
        }
        
        if (!isContacted) {
          uncontactedCount++;
        }
      });
      
      // 5. Last updated - find most recent timestamp
      const timestampCols = headers.filter(h => {
        const lower = h.toLowerCase();
        return lower.includes('date') || 
               lower.includes('timestamp') ||
               lower.includes('updated') ||
               lower.includes('last modified');
      });
      
      let lastUpdated = null;
      timestampCols.forEach(col => {
        data.forEach(row => {
          const value = row[col];
          if (value) {
            const date = new Date(value);
            if (!isNaN(date.getTime())) {
              if (!lastUpdated || date > lastUpdated) {
                lastUpdated = date;
              }
            }
          }
        });
      });
      
      // Format last updated date
      let lastUpdatedText = 'Not available';
      if (lastUpdated) {
        lastUpdatedText = lastUpdated.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }
      
      // Render the panel
      content.innerHTML = `
        <div class="stat-group">
          <div class="stat-item">
            <span class="stat-value">${householdsCount}</span>
            <span class="stat-label">addresses in your zone</span>
          </div>
          <div class="stat-item">
            <span class="stat-value">${peopleCount}</span>
            <span class="stat-label">people in your zone</span>
          </div>
          <div class="stat-item">
            <span class="stat-value">${uncontactedCount}</span>
            <span class="stat-label">addresses not yet contacted</span>
          </div>
        </div>
        
      `;
      
      // Show charts container and render charts
      const chartsContainer = document.getElementById('zoneOverviewCharts');
      const footerContainer = document.getElementById('zoneOverviewFooter');
      if (chartsContainer) {
        chartsContainer.style.display = 'flex';
        updateZoneOverviewCharts();
      }
      
      // Update footer with last updated
      if (footerContainer) {
        footerContainer.style.display = 'block';
        const lastUpdatedSpan = footerContainer.querySelector('.stat-value');
        if (lastUpdatedSpan) {
          lastUpdatedSpan.textContent = lastUpdatedText;
        }
      }
    }
    
    // Panel E: Zone Leadership
    function updateZoneLeadership() {
      if (!sheetData || !sheetData.headers || !sheetData.data || sheetData.data.length === 0) {
        const content = document.getElementById('zoneLeadershipContent');
        if (content) {
          content.innerHTML = '<div class="empty">No zone leadership data available</div>';
        }
        return;
      }
      
      const content = document.getElementById('zoneLeadershipContent');
      if (!content) return;
      
      const headers = sheetData.headers;
      const allRows = sheetData.data;
      
      // Find NC columns (case-insensitive)
      const ncNameCol = headers.find(h => h.toLowerCase().includes('nc name'));
      const ncPhoneCol = headers.find(h => h.toLowerCase().includes('nc phone'));
      const ncEmailCol = headers.find(h => h.toLowerCase().includes('nc email'));
      
      // Get captain data from first row (should be the same for all rows in a zone)
      const firstRow = allRows[0];
      if (!firstRow) {
        content.innerHTML = '<div class="empty">No zone leadership data available</div>';
        return;
      }
      
      const ncName = ncNameCol ? (firstRow[ncNameCol] || '').trim() : '';
      const ncPhone = ncPhoneCol ? (firstRow[ncPhoneCol] || '').trim() : '';
      const ncEmail = ncEmailCol ? (firstRow[ncEmailCol] || '').trim() : '';
      
      // Parse captains
      const captains = parseCaptains(ncName, ncPhone, ncEmail);
      
      if (captains.length === 0) {
        content.innerHTML = '<div class="empty">No neighborhood captains assigned to this zone</div>';
        return;
      }
      
      // Build HTML for each captain
      let html = '<div style="display: flex; flex-direction: column; gap: 20px;">';
      
      captains.forEach((captain, index) => {
        html += `
          <div style="padding: 16px; background: rgba(96, 108, 56, 0.05); border-radius: 8px; border: 2px solid rgba(96, 108, 56, 0.2);">
            <div style="font-weight: 700; font-size: 1.1rem; color: var(--primary-dark); margin-bottom: 12px; font-family: 'Alegreya', serif;">
              ${escapeHtml(captain.name)}
            </div>
            <div style="display: flex; flex-direction: column; gap: 8px; font-size: 0.95rem;">
              ${captain.phone !== 'N/A' ? `
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="color: var(--text-light); font-weight: 600;">Phone:</span>
                  <a href="tel:${captain.phone.replace(/[^0-9+()-]/g, '')}" style="color: var(--primary); text-decoration: none;">${escapeHtml(captain.phone)}</a>
                </div>
              ` : ''}
              ${captain.email !== 'N/A' ? `
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="color: var(--text-light); font-weight: 600;">Email:</span>
                  <a href="mailto:${escapeHtml(captain.email)}" style="color: var(--primary); text-decoration: none; word-break: break-word;">${escapeHtml(captain.email)}</a>
                </div>
              ` : ''}
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      content.innerHTML = html;
    }
    
    // Store chart references
    const zoneOverviewChartRefs = {};
    
    // Chart carousel helper functions
    function renderChartInCanvas(canvasId, chartConfig) {
      const ctx = document.getElementById(canvasId);
      if (!ctx) return null;
      
      // Destroy existing chart if it exists
      if (zoneOverviewChartRefs[canvasId]) {
        zoneOverviewChartRefs[canvasId].destroy();
        zoneOverviewChartRefs[canvasId] = null;
      }
      
      if (!chartConfig) return null;
      
      const chart = new Chart(ctx, {
        type: chartConfig.type,
        data: chartConfig.data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: {
              top: 5,
              bottom: 5
            }
          },
          plugins: {
            legend: {
              position: 'bottom',
              padding: 6,
              labels: {
                font: {
                  size: 10
                },
                boxWidth: 10,
                boxHeight: 10,
                padding: 8
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.dataset.data.reduce((a, b) => a + b, 0);
                  const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                  const labelText = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                  return labelText + ': ' + context.parsed + ' (' + percentage + '%)';
                }
              }
            }
          },
          ...(chartConfig.options || {})
        }
      });
      
      // Store chart reference
      zoneOverviewChartRefs[canvasId] = chart;
      return chart;
    }

    // Get chart data functions
    function getAddressesContactedData(headers, data) {
      const lastContactCol = headers.find(h => 
        h.toLowerCase() === 'last contact date' ||
        h.toLowerCase().includes('last contact') || 
        h.toLowerCase().includes('contact date') ||
        h.toLowerCase().includes('contacted')
      );
      const houseNumCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'House #' || lower === 'house #' || lower.includes('house #') || 
               lower.includes('house#') || lower === 'house number' || lower === 'house num' ||
               (lower === 'house' && !lower.includes('hold'));
      });
      const streetCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'Street' || lower === 'street' || (lower.includes('street') && !lower.includes('address'));
      });

      const households = new Set();
      const householdsContacted = new Set();

      data.forEach(row => {
        const houseNum = houseNumCol ? (row[houseNumCol] || '').trim() : '';
        const street = streetCol ? (row[streetCol] || '').trim() : '';
        const address = houseNum && street ? `${houseNum} ${street}` : '';
        if (address) {
          households.add(address);
          const hasContact = lastContactCol && row[lastContactCol] && String(row[lastContactCol]).trim().length > 0;
          if (hasContact) {
            householdsContacted.add(address);
          }
        }
      });

      return {
        contacted: householdsContacted.size,
        notContacted: households.size - householdsContacted.size
      };
    }

    function getDamageStatusData(headers, data) {
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const damageCounts = {};
      let damageUnknown = 0;
      
      if (damageCol) {
        data.forEach(row => {
          const damage = row[damageCol] ? String(row[damageCol]).trim() : '';
          if (damage) {
            damageCounts[damage] = (damageCounts[damage] || 0) + 1;
          } else {
            damageUnknown++;
          }
        });
      } else {
        damageUnknown = data.length;
      }

      const labels = Object.keys(damageCounts);
      const dataValues = Object.values(damageCounts);
      
      if (damageUnknown > 0) {
        labels.push('Unknown');
        dataValues.push(damageUnknown);
      }

      return { labels, data: dataValues };
    }

    function getHouseholdStatusData(headers, data, addressMap) {
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const statusCounts = {};
      let statusUnknown = 0;
      
      if (statusCol) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          const status = row[statusCol] ? String(row[statusCol]).trim() : '';
          if (status) {
            statusCounts[status] = (statusCounts[status] || 0) + 1;
          } else {
            statusUnknown++;
          }
        });
      } else {
        statusUnknown = addressMap.size;
      }

      const labels = Object.keys(statusCounts);
      const dataValues = Object.values(statusCounts);
      
      if (statusUnknown > 0) {
        labels.push('Unknown');
        dataValues.push(statusUnknown);
      }

      return { labels, data: dataValues };
    }

    function getStreetsDistributionData(headers, data) {
      const streetCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'Street' || lower === 'street' || (lower.includes('street') && !lower.includes('address'));
      });
      
      if (!streetCol) return { labels: [], data: [] };
      
      const streetCounts = {};
      data.forEach(row => {
        const street = row[streetCol] ? String(row[streetCol]).trim() : '';
        if (street) {
          streetCounts[street] = (streetCounts[street] || 0) + 1;
        }
      });

      // Sort by count (descending) and take top 8
      const sorted = Object.entries(streetCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);
      
      const labels = sorted.map(([street]) => street);
      const dataValues = sorted.map(([, count]) => count);

      return { labels, data: dataValues };
    }

    function getPeoplePerAddressData(headers, data, addressMap) {
      const residentNameCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('resident name') || (lower.includes('name') && !lower.includes('first') && !lower.includes('last') && !lower.includes('nc'));
      });
      
      const peoplePerAddress = {};
      addressMap.forEach((rows, address) => {
        let peopleCount = 0;
        rows.forEach(row => {
          if (residentNameCol && row[residentNameCol] && String(row[residentNameCol]).trim()) {
            peopleCount++;
          }
        });
        if (peopleCount > 0) {
          peoplePerAddress[peopleCount] = (peoplePerAddress[peopleCount] || 0) + 1;
        }
      });

      const labels = Object.keys(peoplePerAddress).sort((a, b) => parseInt(a) - parseInt(b)).map(n => `${n} ${n === '1' ? 'person' : 'people'}`);
      const dataValues = Object.keys(peoplePerAddress).sort((a, b) => parseInt(a) - parseInt(b)).map(n => peoplePerAddress[n]);

      return { labels, data: dataValues };
    }

    function getRebuildStatusData(headers, addressMap) {
      const rebuildCol = headers.find(h => h.toLowerCase().includes('rebuild'));
      const rebuildCounts = {};
      let rebuildUnknown = 0;
      
      if (rebuildCol) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          const rebuild = row[rebuildCol] ? String(row[rebuildCol]).trim() : '';
          if (rebuild) {
            rebuildCounts[rebuild] = (rebuildCounts[rebuild] || 0) + 1;
          } else {
            rebuildUnknown++;
          }
        });
      } else {
        rebuildUnknown = addressMap.size;
      }

      const labels = Object.keys(rebuildCounts);
      const dataValues = Object.values(rebuildCounts);
      
      if (rebuildUnknown > 0) {
        labels.push('Not Started');
        dataValues.push(rebuildUnknown);
      }

      return { labels, data: dataValues };
    }

    // Carousel navigation
    function navigateCarousel(carouselId, direction) {
      const carousel = carouselId === 'left' ? zoneOverviewCarouselLeft : zoneOverviewCarouselRight;
      const childIndex = carouselId === 'left' ? '1' : '2';
      const slides = document.querySelectorAll(`.chart-carousel-wrapper:nth-child(${childIndex}) .chart-carousel-slide`);
      const totalSlides = slides.length;
      
      if (totalSlides === 0) return;
      
      // Remove active class from current slide
      slides[carousel.currentIndex].classList.remove('active');
      
      // Calculate new index
      if (direction === 'next') {
        carousel.currentIndex = (carousel.currentIndex + 1) % totalSlides;
      } else {
        carousel.currentIndex = (carousel.currentIndex - 1 + totalSlides) % totalSlides;
      }
      
      // Add active class to new slide
      slides[carousel.currentIndex].classList.add('active');
      
      // Update dots
      updateCarouselDots(carouselId);
      
      // Render chart for active slide
      renderCarouselChart(carouselId, carousel.currentIndex);
    }

    function updateCarouselDots(carouselId) {
      const carousel = carouselId === 'left' ? zoneOverviewCarouselLeft : zoneOverviewCarouselRight;
      const dotsContainer = document.querySelector(`.chart-carousel-dots[data-carousel="${carouselId}"]`);
      if (!dotsContainer) return;
      
      const childIndex = carouselId === 'left' ? '1' : '2';
      const slides = document.querySelectorAll(`.chart-carousel-wrapper:nth-child(${childIndex}) .chart-carousel-slide`);
      const totalSlides = slides.length;
      
      dotsContainer.innerHTML = '';
      for (let i = 0; i < totalSlides; i++) {
        const dot = document.createElement('button');
        dot.className = `chart-carousel-dot ${i === carousel.currentIndex ? 'active' : ''}`;
        dot.setAttribute('aria-label', `Go to chart ${i + 1}`);
        dot.addEventListener('click', () => {
          const carousel = carouselId === 'left' ? zoneOverviewCarouselLeft : zoneOverviewCarouselRight;
          const childIndex = carouselId === 'left' ? '1' : '2';
          const slides = document.querySelectorAll(`.chart-carousel-wrapper:nth-child(${childIndex}) .chart-carousel-slide`);
          slides[carousel.currentIndex].classList.remove('active');
          carousel.currentIndex = i;
          slides[carousel.currentIndex].classList.add('active');
          updateCarouselDots(carouselId);
          renderCarouselChart(carouselId, i);
        });
        dotsContainer.appendChild(dot);
      }
    }

    function renderCarouselChart(carouselId, chartIndex) {
      if (!sheetData || !sheetData.data || !sheetData.addressMap) return;
      
      const headers = sheetData.headers;
      const data = sheetData.data;
      const addressMap = sheetData.addressMap;
      
      // Define chart configurations - same for both carousels
      const allCharts = [
        {
          canvasId: 'zoneOverviewAddressesChart',
          render: () => {
            const contactData = getAddressesContactedData(headers, data);
            return {
              type: 'pie',
              data: {
                labels: [`Contacted (${contactData.contacted})`, `Not Contacted (${contactData.notContacted})`],
                datasets: [{
                  data: [contactData.contacted, contactData.notContacted],
                  backgroundColor: ['#81bdc3', '#bc455a'],
                  borderWidth: 2,
                  borderColor: '#fff'
                }]
              },
              options: {}
            };
          }
        },
        {
          canvasId: 'zoneOverviewDamageChart',
          render: () => {
            const damageData = getDamageStatusData(headers, data);
            const damageColors = ['#bc455a', '#fdba77', '#b4bd9b', '#81bdc3', '#f6cf98', '#ccd5c3', '#f9d6d3'];
            const labelsWithCount = damageData.labels.map((label, i) => `${label} (${damageData.data[i]})`);
            return {
              type: 'pie',
              data: {
                labels: labelsWithCount,
                datasets: [{
                  data: damageData.data,
                  backgroundColor: damageColors.slice(0, damageData.labels.length),
                  borderWidth: 2,
                  borderColor: '#fff'
                }]
              },
              options: {}
            };
          }
        },
        {
          canvasId: 'zoneOverviewHouseholdChart',
          render: () => {
            const statusData = getHouseholdStatusData(headers, data, addressMap);
            const statusColors = ['#b4bd9b', '#81bdc3', '#fdba77', '#f6cf98', '#bc455a', '#ccd5c3', '#f9d6d3'];
            const labelsWithCount = statusData.labels.map((label, i) => `${label} (${statusData.data[i]})`);
            return {
              type: 'doughnut',
              data: {
                labels: labelsWithCount,
                datasets: [{
                  data: statusData.data,
                  backgroundColor: statusColors.slice(0, statusData.labels.length),
                  borderWidth: 2,
                  borderColor: '#fff'
                }]
              },
              options: {
                cutout: '60%'
              }
            };
          }
        },
        {
          canvasId: 'zoneOverviewStreetsChart',
          render: () => {
            const streetsData = getStreetsDistributionData(headers, data);
            if (streetsData.labels.length === 0) return null;
            return {
              type: 'bar',
              data: {
                labels: streetsData.labels,
                datasets: [{
                  label: 'Addresses',
                  data: streetsData.data,
                  backgroundColor: '#81bdc3',
                  borderColor: '#606C38',
                  borderWidth: 1
                }]
              },
              options: {
                indexAxis: 'y',
                scales: {
                  x: {
                    beginAtZero: true,
                    ticks: { stepSize: 1, precision: 0 }
                  }
                }
              }
            };
          }
        },
        {
          canvasId: 'zoneOverviewPeopleChart',
          render: () => {
            const peopleData = getPeoplePerAddressData(headers, data, addressMap);
            if (peopleData.labels.length === 0) return null;
            return {
              type: 'bar',
              data: {
                labels: peopleData.labels,
                datasets: [{
                  label: 'Addresses',
                  data: peopleData.data,
                  backgroundColor: '#b4bd9b',
                  borderColor: '#606C38',
                  borderWidth: 1
                }]
              },
              options: {
                scales: {
                  y: {
                    beginAtZero: true,
                    ticks: { stepSize: 1, precision: 0 }
                  }
                }
              }
            };
          }
        },
        {
          canvasId: 'zoneOverviewRebuildChart',
          render: () => {
            const rebuildData = getRebuildStatusData(headers, addressMap);
            if (rebuildData.labels.length === 0) return null;
            const rebuildColors = ['#9e9e9e', '#bc455a', '#fdba77', '#f6cf98', '#b4bd9b', '#81bdc3', '#ccd5c3', '#f9d6d3'];
            const labelsWithCount = rebuildData.labels.map((label, i) => `${label} (${rebuildData.data[i]})`);
            return {
              type: 'doughnut',
              data: {
                labels: labelsWithCount,
                datasets: [{
                  data: rebuildData.data,
                  backgroundColor: rebuildColors.slice(0, rebuildData.labels.length),
                  borderWidth: 2,
                  borderColor: '#fff'
                }]
              },
              options: {
                cutout: '60%'
              }
            };
          }
        }
      ];

      // Map chart definitions to the correct canvas IDs for each carousel
      // LEFT: Addresses Contacted (0), Streets Distribution (3), People per Address (4)
      // RIGHT: Damage Status (1), Rebuild Status (5), Household Status (2)
      const chartIndexMap = {
        'left': [0, 3, 4],  // Addresses Contacted, Streets Distribution, People per Address
        'right': [1, 5, 2]  // Damage Status, Rebuild Status, Household Status
      };
      
      const canvasIdMap = {
        'left': [
          'zoneOverviewLeftAddressesChart',
          'zoneOverviewLeftStreetsChart',
          'zoneOverviewLeftPeopleChart'
        ],
        'right': [
          'zoneOverviewRightDamageChart',
          'zoneOverviewRightRebuildChart',
          'zoneOverviewRightHouseholdChart'
        ]
      };
      
      // Get the chart indices for this carousel
      const chartIndices = chartIndexMap[carouselId];
      const charts = chartIndices.map((originalIndex, carouselIndex) => ({
        ...allCharts[originalIndex],
        canvasId: canvasIdMap[carouselId][carouselIndex]
      }));
      if (chartIndex >= charts.length) return;
      
      const chartConfig = charts[chartIndex].render();
      if (chartConfig) {
        renderChartInCanvas(charts[chartIndex].canvasId, chartConfig);
      }
    }


    // Initialize carousel controls
    function initializeCarouselControls() {
      // Left carousel arrows
      const leftPrev = document.querySelector('.chart-carousel-wrapper:nth-child(1) .chart-carousel-arrow-left');
      const leftNext = document.querySelector('.chart-carousel-wrapper:nth-child(1) .chart-carousel-arrow-right');
      
      if (leftPrev) {
        leftPrev.addEventListener('click', () => {
          navigateCarousel('left', 'prev');
        });
      }
      if (leftNext) {
        leftNext.addEventListener('click', () => {
          navigateCarousel('left', 'next');
        });
      }

      // Right carousel arrows
      const rightPrev = document.querySelector('.chart-carousel-wrapper:nth-child(2) .chart-carousel-arrow-left');
      const rightNext = document.querySelector('.chart-carousel-wrapper:nth-child(2) .chart-carousel-arrow-right');
      
      if (rightPrev) {
        rightPrev.addEventListener('click', () => {
          navigateCarousel('right', 'prev');
        });
      }
      if (rightNext) {
        rightNext.addEventListener('click', () => {
          navigateCarousel('right', 'next');
        });
      }
    }

    // Update Zone Overview charts with carousel
    function updateZoneOverviewCharts() {
      if (!sheetData || !sheetData.data || sheetData.data.length === 0) {
        return;
      }
      
      // Reset carousel indices
      zoneOverviewCarouselLeft.currentIndex = 0;
      zoneOverviewCarouselRight.currentIndex = 0;
      
      // Show first slide in each carousel
      const leftSlides = document.querySelectorAll('.chart-carousel-wrapper:nth-child(1) .chart-carousel-slide');
      const rightSlides = document.querySelectorAll('.chart-carousel-wrapper:nth-child(2) .chart-carousel-slide');
      
      leftSlides.forEach((slide, index) => {
        slide.classList.remove('active');
        if (index === 0) {
          slide.classList.add('active');
        }
      });
      
      rightSlides.forEach((slide, index) => {
        slide.classList.remove('active');
        if (index === 0) {
          slide.classList.add('active');
        }
      });
      
      // Initialize dots
      updateCarouselDots('left');
      updateCarouselDots('right');
      
      // Render initial charts
      renderCarouselChart('left', 0);
      renderCarouselChart('right', 0);
      
      // Initialize controls (only once)
      const firstWrapper = document.querySelector('.chart-carousel-wrapper');
      if (firstWrapper && !firstWrapper.hasAttribute('data-initialized')) {
        initializeCarouselControls();
        document.querySelectorAll('.chart-carousel-wrapper').forEach(w => w.setAttribute('data-initialized', 'true'));
      }
    }
    
    // Panel B: Rebuild Progress Snapshot
    function updateRebuildProgress() {
      if (!sheetData || !sheetData.addressMap || !sheetData.headers) {
        return;
      }
      
      const content = document.getElementById('rebuildProgressContent');
      if (!content) return;
      
      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      
      // Find Rebuild Stage column
      const rebuildCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('rebuild stage') ||
               (lower.includes('rebuild') && lower.includes('stage'));
      });
      
      const rebuildCounts = {};
      const defaultStages = [
        'Not started',
        'Planning / Design',
        'Permits in progress',
        'Construction in progress',
        'Rebuild completed'
      ];
      
      // Initialize default stages
      defaultStages.forEach(stage => {
        rebuildCounts[stage] = 0;
      });
      rebuildCounts['Unknown'] = 0;
      
      if (rebuildCol) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          const stage = (row[rebuildCol] || '').trim();
          if (stage) {
            // Try to match to known stages or use as-is
            let matched = false;
            for (const defaultStage of defaultStages) {
              if (stage.toLowerCase().includes(defaultStage.toLowerCase()) ||
                  defaultStage.toLowerCase().includes(stage.toLowerCase())) {
                rebuildCounts[defaultStage]++;
                matched = true;
                break;
              }
            }
            if (!matched) {
              // Check if it's an exact match to any key
              if (rebuildCounts.hasOwnProperty(stage)) {
                rebuildCounts[stage]++;
              } else {
                rebuildCounts['Unknown']++;
              }
            }
          } else {
            rebuildCounts['Unknown']++;
          }
        });
      } else {
        // No rebuild column found
        rebuildCounts['Unknown'] = addressMap.size;
      }
      
      // Render the panel
      content.innerHTML = `
        <div class="stat-group">
          ${Object.entries(rebuildCounts).filter(([stage, count]) => count > 0 || stage === 'Not started').map(([stage, count]) => `
            <div class="rebuild-stat-item">
              <span class="rebuild-stat-label">${stage}</span>
              <span class="rebuild-stat-count">${count}</span>
            </div>
          `).join('')}
        </div>
      `;
    }
    
    // Helper function to convert markdown-style links and URLs to clickable links
    function linkifyText(text) {
      if (!text) return '';
      
      // Use placeholders to protect already-converted links
      const placeholders = [];
      let placeholderIndex = 0;
      
      // First, convert markdown-style links [text](url) and replace with placeholder
      let result = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, linkText, url) => {
        // Only allow http/https URLs for security
        if (url.match(/^https?:\/\//i)) {
          const placeholder = `__LINK_PLACEHOLDER_${placeholderIndex}__`;
          placeholders[placeholderIndex] = `<a href="${url}" target="_blank" rel="noopener noreferrer">${linkText}</a>`;
          placeholderIndex++;
          return placeholder;
        }
        return match; // Return original if not a valid URL
      });
      
      // Then, auto-detect any remaining plain URLs and convert them
      const urlPattern = /(https?:\/\/[^\s<>"']+)/g;
      result = result.replace(urlPattern, (match) => {
        const placeholder = `__LINK_PLACEHOLDER_${placeholderIndex}__`;
        placeholders[placeholderIndex] = `<a href="${match}" target="_blank" rel="noopener noreferrer">${match}</a>`;
        placeholderIndex++;
        return placeholder;
      });
      
      // Replace placeholders with actual HTML
      placeholders.forEach((html, index) => {
        result = result.replace(`__LINK_PLACEHOLDER_${index}__`, html);
      });
      
      return result;
    }

    // Panel C: From Altagether (Central Feed)
    async function fetchAndDisplayCentralFeed() {
      const content = document.getElementById('altagetherContent');
      if (!content) return;
      
      content.innerHTML = '<div class="loading">Loading announcements...</div>';
      
      try {
        const response = await fetch('/api/homepage-feed');
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const feed = await response.json();
        
        // Display alert in header if there's an alert
        const alertBar = document.getElementById('alertBar');
        const alertBarContent = document.getElementById('alertBarContent');
        if (feed.alert && feed.alert.trim()) {
          alertBarContent.innerHTML = linkifyText(feed.alert);
          alertBar.style.display = 'block';
        } else {
          alertBar.style.display = 'none';
        }
        
        let html = '';
        
        // Display each item: Label (bold) followed by Content from columns B, C, D, etc.
        if (feed.items && feed.items.length > 0) {
          feed.items.forEach(item => {
            if (item.label) {
              html += `
                <div class="announcement-item">
                  <div class="announcement-title"><strong>${item.label}</strong></div>
                  ${item.content && item.content.length > 0 ? item.content.map(contentText => 
                    `<div class="announcement-description">${linkifyText(contentText)}</div>`
                  ).join('') : ''}
                </div>
              `;
            }
          });
        }
        
        if (!html) {
          html = '<div class="empty">No announcements at this time.</div>';
        }
        
        content.innerHTML = html;
      } catch (error) {
        console.error('Error fetching central feed:', error);
        content.innerHTML = '<div class="error">Failed to load announcements. Please try again later.</div>';
      }
    }

    // ============================================
    // Contact List Creator Functions
    // ============================================
    
    let currentListType = null; // 'email', 'phone', or 'walk'
    let currentListSource = null; // 'canned' or 'custom'
    let currentListData = []; // Generated list data
    let contactListCreatorInitialized = false; // Track if listeners are set up
    
    // Initialize Contact List Creator when Tools view is shown
    function initializeContactListCreator() {
      const creator = document.getElementById('contactListCreator');
      if (!creator) {
        console.log('Contact List Creator: creator element not found');
        return;
      }
      
      console.log('Contact List Creator: Initializing...', {
        hasSheetData: !!sheetData,
        hasAddressMap: !!(sheetData && sheetData.addressMap),
        sheetDataKeys: sheetData ? Object.keys(sheetData) : []
      });
      
      // Reset initialization flag so listeners can be set up fresh each time
      contactListCreatorInitialized = false;
      
      // Check if we have an error message div, or create one
      let errorDiv = creator.querySelector('.contact-list-error');
      if (!errorDiv) {
        errorDiv = document.createElement('div');
        errorDiv.className = 'contact-list-error';
        errorDiv.style.display = 'none';
        errorDiv.style.padding = '16px';
        errorDiv.style.margin = '16px 0';
        errorDiv.style.background = 'rgba(255, 0, 0, 0.1)';
        errorDiv.style.border = '2px solid #d32f2f';
        errorDiv.style.borderRadius = '8px';
        errorDiv.style.color = '#d32f2f';
        errorDiv.style.fontWeight = '600';
        const toolModuleHeader = creator.querySelector('.tool-module-header');
        if (toolModuleHeader && toolModuleHeader.nextSibling) {
          creator.insertBefore(errorDiv, toolModuleHeader.nextSibling);
        } else {
          creator.appendChild(errorDiv);
        }
      }
      
      if (!sheetData || !sheetData.addressMap) {
        console.log('Contact List Creator: No data available');
        errorDiv.textContent = 'Please load a spreadsheet first to use the Contact List Creator.';
        errorDiv.style.display = 'block';
        // Hide wizard and results
        const wizard = document.getElementById('listCreatorWizard');
        const resultsStep = document.getElementById('stepListResults');
        if (wizard) wizard.style.display = 'none';
        if (resultsStep) resultsStep.style.display = 'none';
        return;
      }
      
      console.log('Contact List Creator: Data available, setting up...');
      
      // Hide error if data is available
      errorDiv.style.display = 'none';
      
      // Populate street filter in custom builder
      populateCustomBuilderStreets();
      
      // Set up event listeners (will be set up fresh each time)
      setupContactListCreatorListeners();
      
      // Set up "All" checkbox handlers
      setupAllCheckboxHandlers();
      
      // Reset wizard interface
      resetContactListCreator();
    }
    
    function setupAllCheckboxHandlers() {
      // Damage Status "All" checkbox
      const damageAll = document.getElementById('damageAll');
      const damageOptions = document.querySelectorAll('.damage-option');
      
      if (damageAll) {
        damageAll.addEventListener('change', (e) => {
          damageOptions.forEach(option => {
            option.checked = e.target.checked;
          });
        });
        
        // When individual options change, update "All" checkbox
        damageOptions.forEach(option => {
          option.addEventListener('change', () => {
            const allChecked = Array.from(damageOptions).every(opt => opt.checked);
            damageAll.checked = allChecked;
          });
        });
      }
      
      // Household Status "All" checkbox
      const statusAll = document.getElementById('statusAll');
      const statusOptions = document.querySelectorAll('.status-option');
      
      if (statusAll) {
        statusAll.addEventListener('change', (e) => {
          statusOptions.forEach(option => {
            option.checked = e.target.checked;
          });
        });
        
        // When individual options change, update "All" checkbox
        statusOptions.forEach(option => {
          option.addEventListener('change', () => {
            const allChecked = Array.from(statusOptions).every(opt => opt.checked);
            statusAll.checked = allChecked;
          });
        });
      }
    }
    
    function setupContactListCreatorListeners() {
      // Only set up once
      if (contactListCreatorInitialized) return;
      contactListCreatorInitialized = true;
      
      // Wait a bit to ensure DOM is ready
      setTimeout(() => {
        // Quick Start buttons
        const quickStartButtons = document.querySelectorAll('.quick-start-btn');
        quickStartButtons.forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const action = btn.getAttribute('data-action');
            handleQuickStart(action);
          });
        });
        
        // Purpose radio buttons (email/phone/walk)
        const purposeRadios = document.querySelectorAll('input[name="listPurpose"]');
        purposeRadios.forEach(radio => {
          radio.addEventListener('change', () => {
            if (radio.checked) {
              currentListType = radio.value;
              updateSummary();
              checkGenerateButton();
            }
          });
        });
        
        // Who radio buttons (everyone/uncontacted/followup/oldcontact/custom)
        const whoRadios = document.querySelectorAll('input[name="listWho"]');
        whoRadios.forEach(radio => {
          radio.addEventListener('change', () => {
            if (radio.checked) {
              const whoValue = radio.value;
              // Show/hide custom filters
              const customFiltersSection = document.getElementById('customFiltersSection');
              if (customFiltersSection) {
                customFiltersSection.style.display = whoValue === 'custom' ? 'block' : 'none';
              }
              updateSummary();
              checkGenerateButton();
            }
          });
        });
        
        // Generate button
        const generateBtn = document.getElementById('btnGenerateList');
        if (generateBtn) {
          generateBtn.addEventListener('click', (e) => {
            e.preventDefault();
            generateListFromWizard();
          });
        }
        
        // Back to builder button (from results)
        const backToBuilder = document.getElementById('btnBackToBuilder');
        if (backToBuilder) {
          backToBuilder.addEventListener('click', (e) => {
            e.preventDefault();
            resetContactListCreator();
          });
        }
        
        // Export and print buttons
        const exportBtn = document.getElementById('btnExportList');
        if (exportBtn) {
          exportBtn.addEventListener('click', (e) => {
            e.preventDefault();
            exportListToCSV();
          });
        }
        
        const printBtn = document.getElementById('btnPrintList');
        if (printBtn) {
          printBtn.addEventListener('click', (e) => {
            e.preventDefault();
            printList();
          });
        }
        
        // Set up "All" checkbox handlers for custom filters
        setupAllCheckboxHandlers();
      }, 200);
    }
    
    function handleQuickStart(action) {
      // Parse action: "email-everyone", "phone-uncontacted", "walk-standing"
      const parts = action.split('-');
      const purpose = parts[0]; // email, phone, walk
      const who = parts[1]; // everyone, uncontacted, standing
      
      // Set purpose
      currentListType = purpose;
      const purposeRadio = document.getElementById(`purpose${purpose.charAt(0).toUpperCase() + purpose.slice(1)}`);
      if (purposeRadio) {
        purposeRadio.checked = true;
      }
      
      // Set who
      let whoValue = who;
      if (who === 'standing') {
        whoValue = 'custom';
        // Set custom filters for standing homes
        setTimeout(() => {
          const damageStanding = document.querySelector('#customFilterDamage input[value="Standing"]');
          if (damageStanding) {
            damageStanding.checked = true;
            // Uncheck "All" if it's checked
            const damageAll = document.getElementById('damageAll');
            if (damageAll && damageAll.checked) {
              damageAll.checked = false;
            }
          }
        }, 100);
      }
      
      const whoRadio = document.getElementById(`who${whoValue.charAt(0).toUpperCase() + whoValue.slice(1)}`);
      if (whoRadio) {
        whoRadio.checked = true;
        // Trigger change event to show custom filters if needed
        whoRadio.dispatchEvent(new Event('change'));
      }
      
      // Update summary and generate
      updateSummary();
      checkGenerateButton();
      
      // Auto-generate after a short delay
      setTimeout(() => {
        generateListFromWizard();
      }, 300);
    }
    
    function updateSummary() {
      const summary = document.getElementById('listSummary');
      if (!summary) return;
      
      const purposeRadio = document.querySelector('input[name="listPurpose"]:checked');
      const whoRadio = document.querySelector('input[name="listWho"]:checked');
      
      if (!purposeRadio || !whoRadio) {
        summary.style.display = 'none';
        return;
      }
      
      summary.style.display = 'block';
      
      const purposeText = {
        'email': 'Send Emails',
        'phone': 'Make Phone Calls',
        'walk': 'Visit In Person'
      };
      
      const whoText = {
        'everyone': 'Everyone',
        'uncontacted': 'Haven\'t Contacted Yet',
        'followup': 'Need Follow-up',
        'oldcontact': 'Not Contacted Recently',
        'custom': 'Custom Selection'
      };
      
      const purposeEl = document.getElementById('summaryPurpose');
      const whoEl = document.getElementById('summaryWho');
      const filtersEl = document.getElementById('summaryFilters');
      const filtersTextEl = document.getElementById('summaryFiltersText');
      
      if (purposeEl) purposeEl.textContent = purposeText[purposeRadio.value] || '-';
      if (whoEl) whoEl.textContent = whoText[whoRadio.value] || '-';
      
      // Show filters if custom is selected
      if (whoRadio.value === 'custom') {
        const activeFilters = getActiveCustomFilters();
        if (activeFilters.length > 0) {
          filtersEl.style.display = 'block';
          filtersTextEl.textContent = activeFilters.join(', ');
        } else {
          filtersEl.style.display = 'none';
        }
      } else {
        filtersEl.style.display = 'none';
      }
    }
    
    function getActiveCustomFilters() {
      const filters = [];
      
      // Damage status
      const damageChecked = Array.from(document.querySelectorAll('#customFilterDamage input:checked:not([value="__all__"])'))
        .map(cb => cb.nextElementSibling.textContent.trim());
      if (damageChecked.length > 0 && damageChecked.length < 5) {
        filters.push(`Damage: ${damageChecked.join(', ')}`);
      }
      
      // Household status
      const statusChecked = Array.from(document.querySelectorAll('#customFilterStatus input:checked:not([value="__all__"])'))
        .map(cb => cb.nextElementSibling.textContent.trim());
      if (statusChecked.length > 0 && statusChecked.length < 6) {
        filters.push(`Status: ${statusChecked.join(', ')}`);
      }
      
      // Contact status
      const contactSelect = document.getElementById('customFilterContact');
      if (contactSelect && contactSelect.value !== 'all') {
        filters.push(`Contact: ${contactSelect.options[contactSelect.selectedIndex].text}`);
      }
      
      // Follow-up
      const followupSelect = document.getElementById('customFilterFollowup');
      if (followupSelect && followupSelect.value !== 'all') {
        filters.push(`Follow-up: ${followupSelect.options[followupSelect.selectedIndex].text}`);
      }
      
      // Street
      const streetSelect = document.getElementById('customFilterStreet');
      if (streetSelect && streetSelect.value !== 'all') {
        filters.push(`Street: ${streetSelect.value}`);
      }
      
      return filters;
    }
    
    function checkGenerateButton() {
      const generateBtn = document.getElementById('btnGenerateList');
      if (!generateBtn) return;
      
      const purposeRadio = document.querySelector('input[name="listPurpose"]:checked');
      const whoRadio = document.querySelector('input[name="listWho"]:checked');
      
      if (purposeRadio && whoRadio) {
        generateBtn.disabled = false;
      } else {
        generateBtn.disabled = true;
      }
    }
    
    function generateListFromWizard() {
      const purposeRadio = document.querySelector('input[name="listPurpose"]:checked');
      const whoRadio = document.querySelector('input[name="listWho"]:checked');
      
      if (!purposeRadio || !whoRadio) {
        alert('Please select both "What do you want to do?" and "Who do you want to contact?"');
        return;
      }
      
      currentListType = purposeRadio.value;
      const whoValue = whoRadio.value;
      
      if (whoValue === 'custom') {
        // Use custom list generator
        generateCustomList();
      } else {
        // Use canned list generator
        generateCannedList(whoValue);
      }
    }
    
    function showStep(stepId) {
      // Hide all steps
      document.querySelectorAll('.list-creator-step').forEach(step => {
        step.style.display = 'none';
      });
      
      // Show requested step
      const step = document.getElementById(stepId);
      if (step) {
        step.style.display = 'block';
      }
    }
    
    function populateCustomBuilderStreets() {
      if (!sheetData || !sheetData.addressMap) return;
      
      const streetSelect = document.getElementById('customFilterStreet');
      if (!streetSelect) return;
      
      const streets = getUniqueStreets(Array.from(sheetData.addressMap.keys()));
      streetSelect.innerHTML = '<option value="all">All Streets</option>';
      streets.forEach(street => {
        const option = document.createElement('option');
        option.value = street;
        option.textContent = street;
        streetSelect.appendChild(option);
      });
    }
    
    function generateCannedList(type) {
      if (!sheetData || !sheetData.addressMap) return;
      
      let contacts = [];
      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      
      // Find relevant columns
      const nameCol = headers.find(h => 
        h.toLowerCase().includes('resident name') || 
        (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name') && 
         !h.toLowerCase().includes('first') && !h.toLowerCase().includes('last') && 
         !h.toLowerCase().includes('middle'))
      );
      const phoneCol = headers.find(h => 
        h.toLowerCase().includes('phone') && !h.toLowerCase().includes('email')
      );
      const emailCol = headers.find(h => 
        h.toLowerCase().includes('email')
      );
      const contactDateCol = headers.find(h => 
        (h.toLowerCase().includes('contact') && h.toLowerCase().includes('date')) ||
        h.toLowerCase().includes('last contact')
      );
      const followupCol = headers.find(h => 
        h.toLowerCase().includes('follow') && (h.toLowerCase().includes('up') || h.toLowerCase().includes('-up'))
      );
      const notesCol = headers.find(h => 
        h.toLowerCase().includes('note') && !h.toLowerCase().includes('contact')
      );
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      
      addressMap.forEach((rows, address) => {
        // For walk lists, only include Standing homes
        if (currentListType === 'walk') {
          const damage = getAddressDamage(address);
          if (damage !== 'Standing') {
            return;
          }
        }
        
        rows.forEach(row => {
          let include = false;
          
          if (type === 'uncontacted') {
            // Check if this person/household is uncontacted
            const hasContactDate = contactDateCol && row[contactDateCol] && String(row[contactDateCol]).trim() !== '';
            include = !hasContactDate;
          } else if (type === 'followup') {
            // Check if this person needs follow-up
            if (followupCol) {
              const followupValue = (row[followupCol] || '').toString().trim().toLowerCase();
              include = followupValue === 'true' || followupValue === 'yes' || 
                        (followupValue !== '' && followupValue !== 'false' && followupValue !== 'no');
            }
          } else if (type === 'oldcontact') {
            // Check if last contact was 2+ months ago
            if (contactDateCol && row[contactDateCol]) {
              const contactDateStr = String(row[contactDateCol]).trim();
              if (contactDateStr) {
                const contactDate = parseDate(contactDateStr);
                if (contactDate) {
                  const twoMonthsAgo = new Date();
                  twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                  include = contactDate < twoMonthsAgo;
                }
              }
            }
          }
          
          if (include) {
            const name = nameCol ? (row[nameCol] || '').trim() : '';
            const phone = phoneCol ? (row[phoneCol] || '').trim() : '';
            const email = emailCol ? (row[emailCol] || '').trim() : '';
            const notes = notesCol ? (row[notesCol] || '').trim() : '';
            
            // Only include if they have the required contact method for the list type
            if (currentListType === 'email' && !email) return;
            if (currentListType === 'phone' && !phone) return;
            
            if (name || address) {
              contacts.push({
                name: name || 'Unknown',
                address: address,
                phone: phone,
                email: email,
                notes: notes
              });
            }
          }
        });
      });
      
      currentListData = contacts;
      displayListResults(type);
    }
    
    function generateCustomList() {
      if (!sheetData || !sheetData.addressMap) return;
      
      // Get checked values from checkbox groups (excluding "All" checkbox)
      const damageFilter = Array.from(document.querySelectorAll('#customFilterDamage input[type="checkbox"]:checked'))
        .filter(cb => cb.value !== '__all__')
        .map(cb => cb.value);
      const statusFilter = Array.from(document.querySelectorAll('#customFilterStatus input[type="checkbox"]:checked'))
        .filter(cb => cb.value !== '__all__')
        .map(cb => cb.value);
      const contactFilter = document.getElementById('customFilterContact').value;
      const followupFilter = document.getElementById('customFilterFollowup').value;
      const streetFilter = document.getElementById('customFilterStreet').value;
      
      let contacts = [];
      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      
      // Find relevant columns
      const nameCol = headers.find(h => 
        h.toLowerCase().includes('resident name') || 
        (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name') && 
         !h.toLowerCase().includes('first') && !h.toLowerCase().includes('last') && 
         !h.toLowerCase().includes('middle'))
      );
      const phoneCol = headers.find(h => 
        h.toLowerCase().includes('phone') && !h.toLowerCase().includes('email')
      );
      const emailCol = headers.find(h => 
        h.toLowerCase().includes('email')
      );
      const notesCol = headers.find(h => 
        h.toLowerCase().includes('note') && !h.toLowerCase().includes('contact')
      );
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const contactDateCol = headers.find(h => 
        (h.toLowerCase().includes('contact') && h.toLowerCase().includes('date')) ||
        h.toLowerCase().includes('last contact')
      );
      const followupCol = headers.find(h => 
        h.toLowerCase().includes('follow') && (h.toLowerCase().includes('up') || h.toLowerCase().includes('-up'))
      );
      
      addressMap.forEach((rows, address) => {
        // Filter by street
        if (streetFilter !== 'all') {
          const street = extractStreet(address);
          if (street !== streetFilter) return;
        }
        
        // For walk lists, only include Standing homes
        if (currentListType === 'walk') {
          const damage = getAddressDamage(address);
          if (damage !== 'Standing') {
            return;
          }
        }
        
        rows.forEach(row => {
          // Filter by damage status
          if (damageFilter.length > 0 && damageCol) {
            const damage = (row[damageCol] || '').trim();
            // Handle "(not set)" - empty string means no value set
            const damageValue = damage === '' || damage === '(not set)' ? '' : damage;
            if (!damageFilter.includes(damageValue)) return;
          }
          
          // Filter by household status
          if (statusFilter.length > 0 && statusCol) {
            const status = (row[statusCol] || '').trim();
            // Handle "(not set)" - empty string means no value set
            const statusValue = status === '' || status === '(not set)' ? '' : status;
            if (!statusFilter.includes(statusValue)) return;
          }
          
          // Filter by contact status
          if (contactFilter !== 'all' && contactDateCol) {
            const hasContactDate = row[contactDateCol] && String(row[contactDateCol]).trim() !== '';
            if (contactFilter === 'contacted' && !hasContactDate) return;
            if (contactFilter === 'uncontacted' && hasContactDate) return;
          }
          
          // Filter by follow-up
          if (followupFilter !== 'all' && followupCol) {
            const followupValue = (row[followupCol] || '').toString().trim().toLowerCase();
            const needsFollowup = followupValue === 'true' || followupValue === 'yes' || 
                                 (followupValue !== '' && followupValue !== 'false' && followupValue !== 'no');
            if (followupFilter === 'yes' && !needsFollowup) return;
            if (followupFilter === 'no' && needsFollowup) return;
          }
          
          const name = nameCol ? (row[nameCol] || '').trim() : '';
          const phone = phoneCol ? (row[phoneCol] || '').trim() : '';
          const email = emailCol ? (row[emailCol] || '').trim() : '';
          const notes = notesCol ? (row[notesCol] || '').trim() : '';
          
          // Only include if they have the required contact method for the list type
          if (currentListType === 'email' && !email) return;
          if (currentListType === 'phone' && !phone) return;
          
          if (name || address) {
            contacts.push({
              name: name || 'Unknown',
              address: address,
              phone: phone,
              email: email,
              notes: notes
            });
          }
        });
      });
      
      currentListData = contacts;
      displayListResults('custom');
    }
    
    function displayListResults(listType) {
      // Hide wizard, show results
      const wizard = document.getElementById('listCreatorWizard');
      const resultsStep = document.getElementById('stepListResults');
      if (wizard) wizard.style.display = 'none';
      if (resultsStep) resultsStep.style.display = 'block';
      
      const titleEl = document.getElementById('listResultsTitle');
      const countEl = document.getElementById('listResultsCount');
      const contentEl = document.getElementById('listResultsContent');
      
      if (!titleEl || !countEl || !contentEl) return;
      
      // Set title based on list type
      const typeNames = {
        'email': 'Email List',
        'phone': 'Phone List',
        'walk': 'Walk List'
      };
      
      const listNames = {
        'uncontacted': 'Uncontacted Households',
        'followup': 'Needs Follow-up',
        'oldcontact': 'Not Contacted in 2+ Months',
        'everyone': 'Everyone',
        'custom': 'Custom List'
      };
      
      const listTypeDisplay = typeNames[currentListType] || 'Contact List';
      titleEl.textContent = `${listTypeDisplay} - ${listNames[listType]}`;
      
      // Add list type indicator below title
      let listTypeIndicator = titleEl.parentElement.querySelector('.list-type-indicator');
      if (!listTypeIndicator) {
        listTypeIndicator = document.createElement('div');
        listTypeIndicator.className = 'list-type-indicator';
        listTypeIndicator.style.cssText = 'font-size: 0.9rem; color: var(--text-light); margin-top: 4px; font-weight: 500;';
        titleEl.parentElement.insertBefore(listTypeIndicator, titleEl.nextSibling);
      }
      listTypeIndicator.textContent = `List Type: ${listTypeDisplay}`;
      
      if (currentListData.length === 0) {
        contentEl.innerHTML = '<div class="contact-list-empty">No contacts match your criteria.</div>';
        countEl.textContent = '0 contacts';
        return;
      }
      
      // Group contacts by address
      const groupedByAddress = {};
      currentListData.forEach(contact => {
        const address = contact.address || 'Unknown Address';
        if (!groupedByAddress[address]) {
          groupedByAddress[address] = [];
        }
        groupedByAddress[address].push(contact);
      });
      
      const addressCount = Object.keys(groupedByAddress).length;
      const peopleCount = currentListData.length;
      countEl.textContent = `${peopleCount} contact${peopleCount !== 1 ? 's' : ''} at ${addressCount} address${addressCount !== 1 ? 'es' : ''}`;
      
      let html = '';
      Object.keys(groupedByAddress).sort().forEach(address => {
        const contacts = groupedByAddress[address];
        html += `
          <div class="contact-list-address-group">
            <div class="contact-list-address-header">
              <div class="contact-list-address-title">${escapeHtml(address)}</div>
              <div class="contact-list-address-count">${contacts.length} ${contacts.length === 1 ? 'person' : 'people'}</div>
            </div>
            <div class="contact-list-people">
        `;
        
        contacts.forEach(contact => {
          html += `
            <div class="contact-list-person">
              <div class="contact-list-person-name">${escapeHtml(contact.name)}</div>
              <div class="contact-list-item-details">
                ${currentListType === 'email' && contact.email ? `
                  <div class="contact-list-detail-item">
                    <div class="contact-list-detail-label">Email</div>
                    <div class="contact-list-detail-value">${escapeHtml(contact.email)}</div>
                  </div>
                ` : ''}
                ${currentListType === 'phone' && contact.phone ? `
                  <div class="contact-list-detail-item">
                    <div class="contact-list-detail-label">Phone</div>
                    <div class="contact-list-detail-value">${escapeHtml(contact.phone)}</div>
                  </div>
                ` : ''}
                ${currentListType === 'walk' ? `
                  ${contact.phone ? `
                    <div class="contact-list-detail-item">
                      <div class="contact-list-detail-label">Phone</div>
                      <div class="contact-list-detail-value">${escapeHtml(contact.phone)}</div>
                    </div>
                  ` : ''}
                  ${contact.email ? `
                    <div class="contact-list-detail-item">
                      <div class="contact-list-detail-label">Email</div>
                      <div class="contact-list-detail-value">${escapeHtml(contact.email)}</div>
                    </div>
                  ` : ''}
                ` : ''}
              </div>
              ${contact.notes ? `
                <div class="contact-list-item-notes">
                  <div class="contact-list-notes-label">Notes</div>
                  <div class="contact-list-notes-value">${escapeHtml(contact.notes)}</div>
                </div>
              ` : ''}
            </div>
          `;
        });
        
        html += `
            </div>
          </div>
        `;
      });
      
      contentEl.innerHTML = html;
    }
    
    function exportListToCSV() {
      if (currentListData.length === 0) {
        alert('No data to export');
        return;
      }
      
      const headers = ['Name', 'Address'];
      if (currentListType === 'email' || currentListType === 'walk') {
        headers.push('Email');
      }
      if (currentListType === 'phone' || currentListType === 'walk') {
        headers.push('Phone');
      }
      headers.push('Notes');
      
      const rows = currentListData.map(contact => {
        const row = [contact.name, contact.address];
        if (currentListType === 'email' || currentListType === 'walk') {
          row.push(contact.email || '');
        }
        if (currentListType === 'phone' || currentListType === 'walk') {
          row.push(contact.phone || '');
        }
        row.push(contact.notes || '');
        return row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',');
      });
      
      const csv = [headers.map(h => `"${h}"`).join(','), ...rows].join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `contact-list-${currentListType}-${Date.now()}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    
    function printList() {
      const printWindow = window.open('', '_blank');
      const typeNames = {
        'email': 'Email List',
        'phone': 'Phone List',
        'walk': 'Walk List'
      };
      
      // Group contacts by address
      const groupedByAddress = {};
      currentListData.forEach(contact => {
        const address = contact.address || 'Unknown Address';
        if (!groupedByAddress[address]) {
          groupedByAddress[address] = [];
        }
        groupedByAddress[address].push(contact);
      });
      
      const addressCount = Object.keys(groupedByAddress).length;
      const peopleCount = currentListData.length;
      
      // Build HTML grouped by address
      let groupedHtml = '';
      Object.keys(groupedByAddress).sort().forEach(address => {
        const contacts = groupedByAddress[address];
        groupedHtml += `
          <div class="address-group">
            <div class="address-header">${escapeHtml(address)} <span class="address-count">(${contacts.length} ${contacts.length === 1 ? 'person' : 'people'})</span></div>
            ${contacts.map(contact => `
              <div class="contact-item">
                <div class="contact-name">${escapeHtml(contact.name)}</div>
                ${currentListType === 'email' && contact.email ? `<div class="contact-detail"><strong>Email:</strong> ${escapeHtml(contact.email)}</div>` : ''}
                ${currentListType === 'phone' && contact.phone ? `<div class="contact-detail"><strong>Phone:</strong> ${escapeHtml(contact.phone)}</div>` : ''}
                ${currentListType === 'walk' ? `
                  ${contact.phone ? `<div class="contact-detail"><strong>Phone:</strong> ${escapeHtml(contact.phone)}</div>` : ''}
                  ${contact.email ? `<div class="contact-detail"><strong>Email:</strong> ${escapeHtml(contact.email)}</div>` : ''}
                ` : ''}
                ${contact.notes ? `<div class="contact-notes"><strong>Notes:</strong> ${escapeHtml(contact.notes)}</div>` : ''}
              </div>
            `).join('')}
          </div>
        `;
      });
      
      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Contact List - ${typeNames[currentListType]}</title>
          <style>
            body { font-family: Arial, sans-serif; padding: 20px; }
            h1 { color: #283618; }
            .address-group { margin-bottom: 30px; page-break-inside: avoid; }
            .address-header { font-weight: bold; font-size: 1.3em; color: #283618; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 2px solid #283618; }
            .address-count { font-size: 0.9em; color: #666; font-weight: normal; }
            .contact-item { margin-bottom: 15px; padding: 10px; padding-left: 20px; border-left: 3px solid #606C38; }
            .contact-name { font-weight: bold; font-size: 1.1em; margin-bottom: 5px; }
            .contact-detail { margin-top: 5px; }
            .contact-notes { margin-top: 8px; font-style: italic; color: #555; }
          </style>
        </head>
        <body>
          <h1>${typeNames[currentListType]}</h1>
          <p>Total: ${peopleCount} contact${peopleCount !== 1 ? 's' : ''} at ${addressCount} address${addressCount !== 1 ? 'es' : ''}</p>
          ${groupedHtml}
        </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.focus();
      setTimeout(() => {
        printWindow.print();
      }, 250);
    }
    
    function resetContactListCreator() {
      currentListType = null;
      currentListSource = null;
      currentListData = [];
      
      // Hide results, show wizard
      const resultsStep = document.getElementById('stepListResults');
      const wizard = document.getElementById('listCreatorWizard');
      if (resultsStep) resultsStep.style.display = 'none';
      if (wizard) wizard.style.display = 'block';
      
      // Reset form
      const purposeRadios = document.querySelectorAll('input[name="listPurpose"]');
      purposeRadios.forEach(radio => radio.checked = false);
      
      const whoRadios = document.querySelectorAll('input[name="listWho"]');
      whoRadios.forEach(radio => radio.checked = false);
      
      // Hide custom filters
      const customFiltersSection = document.getElementById('customFiltersSection');
      if (customFiltersSection) customFiltersSection.style.display = 'none';
      
      // Hide summary
      const summary = document.getElementById('listSummary');
      if (summary) summary.style.display = 'none';
      
      // Disable generate button
      const generateBtn = document.getElementById('btnGenerateList');
      if (generateBtn) generateBtn.disabled = true;
      
      // Reset custom filters
      document.querySelectorAll('#customFilterDamage input, #customFilterStatus input').forEach(cb => {
        if (cb.value === '__all__') {
          cb.checked = true;
        } else {
          cb.checked = false;
        }
      });
      
      const contactSelect = document.getElementById('customFilterContact');
      if (contactSelect) contactSelect.value = 'all';
      
      const followupSelect = document.getElementById('customFilterFollowup');
      if (followupSelect) followupSelect.value = 'all';
      
      const streetSelect = document.getElementById('customFilterStreet');
      if (streetSelect) streetSelect.value = 'all';
    }
    
    function parseDate(dateStr) {
      // Try to parse various date formats
      const date = new Date(dateStr);
      if (!isNaN(date.getTime())) {
        return date;
      }
      // Try MM/DD/YYYY format
      const parts = dateStr.split('/');
      if (parts.length === 3) {
        const month = parseInt(parts[0]) - 1;
        const day = parseInt(parts[1]);
        const year = parseInt(parts[2]);
        const date2 = new Date(year, month, day);
        if (!isNaN(date2.getTime())) {
          return date2;
        }
      }
      return null;
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // ============================================
    // Zone Report Generator Functions
    // ============================================
    
    // Initialize Zone Report Generator
    function initializeZoneReportGenerator() {
      const generateBtn = document.getElementById('btnGenerateReport');
      const exportBtn = document.getElementById('btnExportReportPDF');
      
      if (generateBtn) {
        // Remove existing listeners to avoid duplicates
        const newGenerateBtn = generateBtn.cloneNode(true);
        generateBtn.parentNode.replaceChild(newGenerateBtn, generateBtn);
        newGenerateBtn.addEventListener('click', function(e) {
          e.preventDefault();
          generateZoneReport();
        });
      }
      
      if (exportBtn) {
        const newExportBtn = exportBtn.cloneNode(true);
        exportBtn.parentNode.replaceChild(newExportBtn, exportBtn);
        newExportBtn.addEventListener('click', function(e) {
          e.preventDefault();
          exportReportToPDF();
        });
      }
    }
    
    // Generate comprehensive zone report
    function generateZoneReport() {
      console.log('generateZoneReport called');
      const statusEl = document.getElementById('zoneReportStatus');
      const container = document.getElementById('zoneReportContainer');
      const content = document.getElementById('zoneReportContent');
      
      if (!sheetData || !sheetData.addressMap) {
        if (statusEl) {
          statusEl.textContent = 'Please load a spreadsheet first.';
          statusEl.className = 'zone-report-status error';
        }
        alert('Please load a spreadsheet first to generate a zone report.');
        return;
      }
      
      if (statusEl) {
        statusEl.textContent = 'Generating report...';
        statusEl.className = 'zone-report-status loading';
      }
      
      try {
        const { html: report, stats } = buildZoneReport();
        if (content) {
          content.innerHTML = report;
        }
        if (container) {
          container.style.display = 'block';
          // Scroll to report
          container.scrollIntoView({ behavior: 'smooth', block: 'start' });
          // Create charts after a short delay to ensure DOM is ready
          setTimeout(() => {
            if (typeof Chart !== 'undefined') {
              createReportCharts(stats);
            } else {
              console.error('Chart.js is not loaded');
            }
          }, 200);
        }
        if (statusEl) {
          statusEl.textContent = 'Report generated successfully!';
          statusEl.className = 'zone-report-status';
          setTimeout(() => {
            statusEl.textContent = '';
          }, 3000);
        }
      } catch (error) {
        console.error('Error generating report:', error);
        if (statusEl) {
          statusEl.textContent = 'Error generating report: ' + error.message;
          statusEl.className = 'zone-report-status error';
        }
        alert('Error generating report: ' + error.message);
      }
    }
    
    // Build the complete zone report HTML
    function buildZoneReport() {
      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      const allRows = Array.from(addressMap.values()).flat();
      
      // Find all relevant columns
      const nameCol = headers.find(h => 
        h.toLowerCase().includes('resident name') || 
        (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name') && 
         !h.toLowerCase().includes('first') && !h.toLowerCase().includes('last') && 
         !h.toLowerCase().includes('middle'))
      );
      const phoneCol = headers.find(h => 
        h.toLowerCase().includes('phone') && !h.toLowerCase().includes('email')
      );
      const emailCol = headers.find(h => h.toLowerCase().includes('email'));
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const contactDateCol = headers.find(h => 
        (h.toLowerCase().includes('contact') && h.toLowerCase().includes('date')) ||
        h.toLowerCase().includes('last contact')
      );
      const followupCol = headers.find(h => 
        h.toLowerCase().includes('follow') && (h.toLowerCase().includes('up') || h.toLowerCase().includes('-up'))
      );
      const notesCol = headers.find(h => 
        h.toLowerCase().includes('note') && !h.toLowerCase().includes('contact')
      );
      const contactNotesCol = headers.find(h => 
        h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')
      );
      const ncNameCol = headers.find(h => h.toLowerCase().includes('nc name'));
      const ncPhoneCol = headers.find(h => h.toLowerCase().includes('nc phone'));
      const ncEmailCol = headers.find(h => h.toLowerCase().includes('nc email'));
      
      // Parse captains for display
      let captains = [];
      if (ncNameCol && allRows.length > 0) {
        const firstRow = allRows[0];
        const ncName = firstRow[ncNameCol] ? (firstRow[ncNameCol] || '').trim() : '';
        const ncPhone = ncPhoneCol ? (firstRow[ncPhoneCol] || '').trim() : '';
        const ncEmail = ncEmailCol ? (firstRow[ncEmailCol] || '').trim() : '';
        captains = parseCaptains(ncName, ncPhone, ncEmail);
      }
      
      // Calculate statistics
      const stats = calculateZoneStatistics(headers, addressMap);
      
      // Get current date
      const reportDate = new Date().toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      });
      
      // Get zone name for title
      const zoneName = currentZoneName ? currentZoneName.trim() : 'Zone';
      const reportTitle = `${zoneName}: Zone Report`;
      
      let html = `
        <div class="zone-report-header">
          <h1 class="zone-report-title">${escapeHtml(reportTitle)}</h1>
          <p class="zone-report-subtitle">Comprehensive Zone Analysis & Data Summary</p>
          <div class="zone-report-meta">Generated: ${reportDate}</div>
        </div>
        
        <!-- Executive Summary -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Executive Summary</h2>
          <div class="zone-report-stats-grid">
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.totalAddresses}</div>
              <div class="zone-report-stat-label">Total Addresses</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.totalPeople}</div>
              <div class="zone-report-stat-label">Total People</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.contactedAddresses}</div>
              <div class="zone-report-stat-label">Contacted Addresses</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.uncontactedAddresses}</div>
              <div class="zone-report-stat-label">Uncontacted Addresses</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.contactRate}%</div>
              <div class="zone-report-stat-label">Contact Rate</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.followupCount}</div>
              <div class="zone-report-stat-label">Follow-ups Needed</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.uniquePhoneCount}</div>
              <div class="zone-report-stat-label">Unique Phone Numbers</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.uniqueEmailCount}</div>
              <div class="zone-report-stat-label">Unique Email Addresses</div>
            </div>
          </div>
        </div>
        
        <!-- Zone Information -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Zone Information</h2>
          <div class="zone-report-subsection">
            <h3 class="zone-report-subsection-title">Neighborhood Captain${captains.length > 1 ? 's' : ''}</h3>
            ${captains.length > 0 ? `
              <div style="display: flex; flex-direction: column; gap: 20px;">
                ${captains.map((captain, index) => `
                  <div style="padding: 16px; background: rgba(96, 108, 56, 0.05); border-radius: 8px; border: 2px solid rgba(96, 108, 56, 0.2);">
                    <div style="font-weight: 700; font-size: 1.1rem; color: var(--primary-dark); margin-bottom: 12px; font-family: 'Alegreya', serif;">
                      ${escapeHtml(captain.name)}
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 8px; font-size: 0.95rem;">
                      ${captain.phone !== 'N/A' ? `
                        <div style="display: flex; align-items: center; gap: 8px;">
                          <span style="color: var(--text-light); font-weight: 600;">Phone:</span>
                          <span style="color: var(--primary);">${escapeHtml(captain.phone)}</span>
                        </div>
                      ` : ''}
                      ${captain.email !== 'N/A' ? `
                        <div style="display: flex; align-items: center; gap: 8px;">
                          <span style="color: var(--text-light); font-weight: 600;">Email:</span>
                          <span style="color: var(--primary); word-break: break-word;">${escapeHtml(captain.email)}</span>
                        </div>
                      ` : ''}
                    </div>
                  </div>
                `).join('')}
              </div>
            ` : '<p>No neighborhood captains assigned to this zone</p>'}
          </div>
        </div>
        
        <!-- Damage Analysis -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Damage Status Analysis</h2>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 24px; align-items: start;">
            <div>
              <div class="zone-report-stats-grid">
                ${Object.entries(stats.damageBreakdown).map(([damage, count]) => `
                  <div class="zone-report-stat-card">
                    <div class="zone-report-stat-value">${count}</div>
                    <div class="zone-report-stat-label">${damage || 'Not Set'}</div>
                  </div>
                `).join('')}
              </div>
              <div class="zone-report-insight" style="margin-top: 20px;">
                <div class="zone-report-insight-title"> Insight</div>
                <div class="zone-report-insight-text">
                  ${stats.damageBreakdown['Standing'] || 0} addresses are standing (${stats.totalAddresses > 0 ? Math.round((stats.damageBreakdown['Standing'] || 0) / stats.totalAddresses * 100) : 0}% of total).
                  ${stats.damageBreakdown['Total Loss'] || 0} addresses are total losses (${stats.totalAddresses > 0 ? Math.round((stats.damageBreakdown['Total Loss'] || 0) / stats.totalAddresses * 100) : 0}% of total).
                </div>
              </div>
            </div>
            <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <h3 style="margin: 0 0 16px 0; color: var(--primary-dark); font-size: 1.2rem; text-align: center;">Damage Distribution</h3>
              <canvas id="reportDamageChart" style="max-height: 250px; max-width: 100%; height: 250px !important;"></canvas>
            </div>
          </div>
        </div>
        
        <!-- Household Status Analysis -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Household Status Analysis</h2>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 24px; align-items: start;">
            <div>
              <div class="zone-report-stats-grid">
                ${Object.entries(stats.statusBreakdown).map(([status, count]) => `
                  <div class="zone-report-stat-card">
                    <div class="zone-report-stat-value">${count}</div>
                    <div class="zone-report-stat-label">${status || 'Not Set'}</div>
                  </div>
                `).join('')}
              </div>
            </div>
            <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <h3 style="margin: 0 0 16px 0; color: var(--primary-dark); font-size: 1.2rem; text-align: center;">Household Status Distribution</h3>
              <canvas id="reportStatusChart" style="max-height: 250px; max-width: 100%; height: 250px !important;"></canvas>
            </div>
          </div>
        </div>
        
        <!-- Contact Analysis Chart -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Contact Analysis</h2>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 24px; align-items: start;">
            <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <h3 style="margin: 0 0 16px 0; color: var(--primary-dark); font-size: 1.2rem; text-align: center;">Contact Status</h3>
              <canvas id="reportContactChart" style="max-height: 250px; max-width: 100%; height: 250px !important;"></canvas>
            </div>
            <div>
              <div class="zone-report-subsection">
                <h3 class="zone-report-subsection-title">Contact Timeline</h3>
                <table class="zone-report-table">
                  <tr>
                    <th>Time Period</th>
                    <th>Addresses Contacted</th>
                  </tr>
                  ${Object.entries(stats.contactTimeline).map(([period, count]) => `
                    <tr>
                      <td>${period}</td>
                      <td>${count}</td>
                    </tr>
                  `).join('')}
                </table>
              </div>
            </div>
          </div>
        
          ${stats.followupPeople.length > 0 ? `
            <div class="zone-report-subsection" style="margin-top: 24px;">
              <h3 class="zone-report-subsection-title">Follow-up Needed (${stats.followupPeople.length} people)</h3>
              <ul class="zone-report-list">
                ${stats.followupPeople.slice(0, 20).map(person => `
                  <li class="zone-report-list-item">
                    <strong>${escapeHtml(person.name)}</strong> - ${escapeHtml(person.address)}
                  </li>
                `).join('')}
                ${stats.followupPeople.length > 20 ? `<li style="padding: 12px; font-style: italic; color: var(--text-light);">... and ${stats.followupPeople.length - 20} more</li>` : ''}
              </ul>
            </div>
          ` : ''}
        </div>
        
        <!-- Street Analysis -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Street-by-Street Breakdown</h2>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 24px; align-items: start;">
            <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <h3 style="margin: 0 0 16px 0; color: var(--primary-dark); font-size: 1.2rem; text-align: center;">Addresses by Street</h3>
              <canvas id="reportStreetChart" style="max-height: 300px; max-width: 100%; height: 300px !important;"></canvas>
            </div>
            <div>
              <table class="zone-report-table">
                <tr>
                  <th>Street</th>
                  <th>Addresses</th>
                  <th>People</th>
                  <th>Contacted</th>
                  <th>Contact Rate</th>
                </tr>
                ${Object.entries(stats.streetStats).sort((a, b) => b[1].addresses - a[1].addresses).map(([street, data]) => `
                  <tr>
                    <td><strong>${escapeHtml(street || 'Unknown')}</strong></td>
                    <td>${data.addresses}</td>
                    <td>${data.people}</td>
                    <td>${data.contacted}</td>
                    <td>${data.contactRate}%</td>
                  </tr>
                `).join('')}
              </table>
            </div>
          </div>
        </div>
        
        <!-- Data Completeness -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Data Completeness Analysis</h2>
          <table class="zone-report-table">
            <tr>
              <th>Field</th>
              <th>Complete</th>
              <th>Missing</th>
              <th>Completion Rate</th>
            </tr>
            ${Object.entries(stats.dataCompleteness).map(([field, data]) => `
              <tr>
                <td><strong>${field}</strong></td>
                <td>${data.complete}</td>
                <td>${data.missing}</td>
                <td>${data.rate}%</td>
              </tr>
            `).join('')}
          </table>
        </div>
        
        <!-- Additional Insights -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Key Insights & Recommendations</h2>
          ${generateInsights(stats)}
        </div>
        
        <!-- Detailed Address List -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Complete Address Directory</h2>
          ${Array.from(addressMap.keys()).sort().map(address => {
            const rows = addressMap.get(address);
            const damage = getAddressDamage(address);
            const status = getAddressStatus(address);
            const isContacted = rows.some(row => {
              if (contactDateCol && row[contactDateCol]) {
                return String(row[contactDateCol]).trim() !== '';
              }
              return false;
            });
            
            return `
              <div class="zone-report-subsection" style="margin-bottom: 24px; padding: 16px; background: rgba(96, 108, 56, 0.03); border-radius: 6px;">
                <h4 style="margin: 0 0 12px 0; color: var(--primary-dark); font-size: 1.2rem; font-family: 'Alegreya', serif;">
                  ${escapeHtml(address)}
                  ${damage ? `<span class="zone-report-badge ${damage.toLowerCase().replace(/\s+/g, '')}">${escapeHtml(damage)}</span>` : ''}
                  ${status ? `<span class="zone-report-badge ${status.toLowerCase().replace(/\s+/g, '').replace('/', '')}">${escapeHtml(status)}</span>` : ''}
                  ${isContacted ? '<span class="zone-report-badge" style="background: rgba(76, 175, 80, 0.2); color: #2e7d32;">Contacted</span>' : '<span class="zone-report-badge" style="background: rgba(244, 67, 54, 0.2); color: #b71c1c;">Uncontacted</span>'}
                </h4>
                <table class="zone-report-table" style="font-size: 0.85rem;">
                  <tr>
                    ${nameCol ? '<th>Name</th>' : ''}
                    ${phoneCol ? '<th>Phone</th>' : ''}
                    ${emailCol ? '<th>Email</th>' : ''}
                    ${contactDateCol ? '<th>Last Contact</th>' : ''}
                    ${followupCol ? '<th>Follow-up</th>' : ''}
                    ${notesCol ? '<th>Notes</th>' : ''}
                  </tr>
                  ${rows.map(row => `
                    <tr>
                      ${nameCol ? `<td>${escapeHtml(row[nameCol] || '')}</td>` : ''}
                      ${phoneCol ? `<td>${escapeHtml(row[phoneCol] || '')}</td>` : ''}
                      ${emailCol ? `<td>${escapeHtml(row[emailCol] || '')}</td>` : ''}
                      ${contactDateCol ? `<td>${escapeHtml(row[contactDateCol] || '')}</td>` : ''}
                      ${followupCol ? `<td>${(row[followupCol] || '').toString().toLowerCase().includes('yes') || (row[followupCol] || '').toString().toLowerCase().includes('true') ? 'Yes' : 'No'}</td>` : ''}
                      ${notesCol ? `<td style="max-width: 300px; word-wrap: break-word;">${escapeHtml(row[notesCol] || '')}</td>` : ''}
                    </tr>
                  `).join('')}
                </table>
                ${contactNotesCol && rows.some(r => r[contactNotesCol]) ? `
                  <div style="margin-top: 12px; padding: 12px; background: rgba(221, 161, 94, 0.1); border-radius: 4px;">
                    <strong>Contact Notes:</strong>
                    ${rows.filter(r => r[contactNotesCol]).map(r => escapeHtml(r[contactNotesCol])).join('; ')}
                  </div>
                ` : ''}
              </div>
            `;
          }).join('')}
        </div>
      `;
      
      return { html, stats };
    }
    
    // Calculate comprehensive zone statistics
    function calculateZoneStatistics(headers, addressMap) {
      const stats = {
        totalAddresses: addressMap.size,
        totalPeople: 0,
        contactedAddresses: 0,
        uncontactedAddresses: 0,
        contactRate: 0,
        followupCount: 0,
        followupPeople: [],
        damageBreakdown: {},
        statusBreakdown: {},
        contactTimeline: {
          'Last 7 days': 0,
          'Last 30 days': 0,
          'Last 90 days': 0,
          'Over 90 days ago': 0,
          'Never contacted': 0
        },
        streetStats: {},
        dataCompleteness: {},
        uniquePhoneCount: 0,
        uniqueEmailCount: 0
      };
      
      // Find columns
      const nameCol = headers.find(h => 
        h.toLowerCase().includes('resident name') || 
        (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name') && 
         !h.toLowerCase().includes('first') && !h.toLowerCase().includes('last') && 
         !h.toLowerCase().includes('middle'))
      );
      const phoneCol = headers.find(h => 
        h.toLowerCase().includes('phone') && !h.toLowerCase().includes('email')
      );
      const emailCol = headers.find(h => h.toLowerCase().includes('email'));
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const contactDateCol = headers.find(h => 
        (h.toLowerCase().includes('contact') && h.toLowerCase().includes('date')) ||
        h.toLowerCase().includes('last contact')
      );
      const followupCol = headers.find(h => 
        h.toLowerCase().includes('follow') && (h.toLowerCase().includes('up') || h.toLowerCase().includes('-up'))
      );
      
      const now = new Date();
      const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
      
      addressMap.forEach((rows, address) => {
        stats.totalPeople += rows.length;
        
        // Damage breakdown
        const damage = getAddressDamage(address);
        stats.damageBreakdown[damage || 'Not Set'] = (stats.damageBreakdown[damage || 'Not Set'] || 0) + 1;
        
        // Status breakdown
        const status = getAddressStatus(address);
        stats.statusBreakdown[status || 'Not Set'] = (stats.statusBreakdown[status || 'Not Set'] || 0) + 1;
        
        // Contact analysis
        let isContacted = false;
        let lastContactDate = null;
        
        rows.forEach(row => {
          if (contactDateCol && row[contactDateCol]) {
            const dateStr = String(row[contactDateCol]).trim();
            if (dateStr) {
              isContacted = true;
              const contactDate = parseDate(dateStr);
              if (contactDate && (!lastContactDate || contactDate > lastContactDate)) {
                lastContactDate = contactDate;
              }
            }
          }
          
          // Follow-up tracking
          if (followupCol) {
            const followupValue = (row[followupCol] || '').toString().trim().toLowerCase();
            const needsFollowup = followupValue === 'true' || followupValue === 'yes' || 
                                 (followupValue !== '' && followupValue !== 'false' && followupValue !== 'no');
            if (needsFollowup) {
              stats.followupCount++;
              const personName = nameCol ? (row[nameCol] || '').trim() : '';
              if (personName) {
                stats.followupPeople.push({ name: personName, address: address });
              }
            }
          }
        });
        
        if (isContacted) {
          stats.contactedAddresses++;
          if (lastContactDate) {
            if (lastContactDate >= sevenDaysAgo) {
              stats.contactTimeline['Last 7 days']++;
            } else if (lastContactDate >= thirtyDaysAgo) {
              stats.contactTimeline['Last 30 days']++;
            } else if (lastContactDate >= ninetyDaysAgo) {
              stats.contactTimeline['Last 90 days']++;
            } else {
              stats.contactTimeline['Over 90 days ago']++;
            }
          }
        } else {
          stats.uncontactedAddresses++;
          stats.contactTimeline['Never contacted']++;
        }
        
        // Street statistics
        const street = extractStreet(address);
        if (!stats.streetStats[street]) {
          stats.streetStats[street] = { addresses: 0, people: 0, contacted: 0 };
        }
        stats.streetStats[street].addresses++;
        stats.streetStats[street].people += rows.length;
        if (isContacted) {
          stats.streetStats[street].contacted++;
        }
      });
      
      // Calculate contact rates
      stats.contactRate = stats.totalAddresses > 0 
        ? Math.round((stats.contactedAddresses / stats.totalAddresses) * 100) 
        : 0;
      
      Object.keys(stats.streetStats).forEach(street => {
        const streetData = stats.streetStats[street];
        streetData.contactRate = streetData.addresses > 0 
          ? Math.round((streetData.contacted / streetData.addresses) * 100) 
          : 0;
      });
      
      // Data completeness
      const allRows = Array.from(addressMap.values()).flat();
      const totalRows = allRows.length;
      
      if (nameCol) {
        const complete = allRows.filter(r => r[nameCol] && String(r[nameCol]).trim()).length;
        stats.dataCompleteness['Resident Name'] = {
          complete,
          missing: totalRows - complete,
          rate: totalRows > 0 ? Math.round((complete / totalRows) * 100) : 0
        };
      }
      
      if (phoneCol) {
        const complete = allRows.filter(r => r[phoneCol] && String(r[phoneCol]).trim()).length;
        stats.dataCompleteness['Phone'] = {
          complete,
          missing: totalRows - complete,
          rate: totalRows > 0 ? Math.round((complete / totalRows) * 100) : 0
        };
      }
      
      if (emailCol) {
        const complete = allRows.filter(r => r[emailCol] && String(r[emailCol]).trim()).length;
        stats.dataCompleteness['Email'] = {
          complete,
          missing: totalRows - complete,
          rate: totalRows > 0 ? Math.round((complete / totalRows) * 100) : 0
        };
      }
      
      if (damageCol) {
        const complete = allRows.filter(r => r[damageCol] && String(r[damageCol]).trim()).length;
        stats.dataCompleteness['Damage Status'] = {
          complete,
          missing: totalRows - complete,
          rate: totalRows > 0 ? Math.round((complete / totalRows) * 100) : 0
        };
      }
      
      if (statusCol) {
        const complete = allRows.filter(r => r[statusCol] && String(r[statusCol]).trim()).length;
        stats.dataCompleteness['Household Status'] = {
          complete,
          missing: totalRows - complete,
          rate: totalRows > 0 ? Math.round((complete / totalRows) * 100) : 0
        };
      }
      
      // Count unique phone numbers from all phone columns
      const allPhoneCols = headers.filter(h => {
        const lower = h.toLowerCase();
        return (lower.includes('phone') || lower.includes('cell') || lower.includes('mobile')) && 
               !lower.includes('nc phone') && 
               !lower.includes('email');
      });
      const uniquePhones = new Set();
      allRows.forEach(row => {
        allPhoneCols.forEach(col => {
          const phone = row[col] ? String(row[col]).trim() : '';
          if (phone) {
            // Normalize phone number (remove common formatting for better uniqueness)
            const normalized = phone.replace(/[\s\-\(\)\.]/g, '').toLowerCase();
            if (normalized.length >= 10) { // Only count valid-looking phone numbers
              uniquePhones.add(normalized);
            }
          }
        });
      });
      stats.uniquePhoneCount = uniquePhones.size;
      
      // Count unique email addresses from all email columns
      const allEmailCols = headers.filter(h => {
        const lower = h.toLowerCase();
        return lower.includes('email') && !lower.includes('nc email');
      });
      const uniqueEmails = new Set();
      allRows.forEach(row => {
        allEmailCols.forEach(col => {
          const email = row[col] ? String(row[col]).trim() : '';
          if (email && email.includes('@')) { // Basic email validation
            uniqueEmails.add(email.toLowerCase()); // Case-insensitive
          }
        });
      });
      stats.uniqueEmailCount = uniqueEmails.size;
      
      return stats;
    }
    
    // Generate insights based on statistics
    function generateInsights(stats) {
      const insights = [];
      
      if (stats.contactRate < 50) {
        insights.push({
          title: 'Low Contact Rate',
          text: `Only ${stats.contactRate}% of addresses have been contacted. Consider prioritizing outreach to uncontacted addresses.`
        });
      }
      
      if (stats.uncontactedAddresses > 0) {
        insights.push({
          title: 'Uncontacted Addresses',
          text: `There are ${stats.uncontactedAddresses} uncontacted addresses. These should be prioritized for initial outreach.`
        });
      }
      
      if (stats.followupCount > 0) {
        insights.push({
          title: 'Follow-ups Needed',
          text: `${stats.followupCount} people need follow-up contact. Review the follow-up list to ensure timely responses.`
        });
      }
      
      if (stats.contactTimeline['Over 90 days ago'] > 0) {
        insights.push({
          title: 'Stale Contacts',
          text: `${stats.contactTimeline['Over 90 days ago']} addresses were last contacted over 90 days ago. Consider re-engaging these households.`
        });
      }
      
      const standingCount = stats.damageBreakdown['Standing'] || 0;
      if (standingCount > 0 && standingCount < stats.totalAddresses * 0.5) {
        insights.push({
          title: 'Damage Distribution',
          text: `Only ${standingCount} addresses (${Math.round(standingCount / stats.totalAddresses * 100)}%) are standing. The zone has significant damage requiring attention.`
        });
      }
      
      const rebuildingCount = stats.statusBreakdown['Rebuilding'] || 0;
      if (rebuildingCount > 0) {
        insights.push({
          title: 'Rebuilding Activity',
          text: `${rebuildingCount} households are rebuilding. These may need ongoing support and resources.`
        });
      }
      
      return insights.map(insight => `
        <div class="zone-report-insight">
          <div class="zone-report-insight-title">${insight.title}</div>
          <div class="zone-report-insight-text">${insight.text}</div>
        </div>
      `).join('');
    }
    
    // Export report to PDF
    function exportReportToPDF() {
      const content = document.getElementById('zoneReportContent');
      if (!content) {
        alert('Please generate a report first.');
        return;
      }
      
      // Use html2pdf library if available, otherwise use browser print
      if (typeof html2pdf !== 'undefined') {
        // Wait a moment to ensure charts are fully rendered
        setTimeout(() => {
          // Clone the content to avoid modifying the original
          const clonedContent = content.cloneNode(true);
          
          // Convert Chart.js canvases to static images
          // This ensures charts appear in the PDF
          const canvases = content.querySelectorAll('canvas[id^="report"]');
          const canvasImages = new Map();
          
          canvases.forEach((canvas) => {
            try {
              const dataURL = canvas.toDataURL('image/png', 1.0);
              canvasImages.set(canvas.id, dataURL);
            } catch (e) {
              console.warn('Could not convert canvas to image:', e);
            }
          });
          
          // Replace canvas elements in cloned content with img elements
          canvasImages.forEach((dataURL, canvasId) => {
            const clonedCanvas = clonedContent.querySelector(`canvas#${canvasId}`);
            if (clonedCanvas) {
              const img = document.createElement('img');
              img.src = dataURL;
              img.style.maxWidth = '100%';
              img.style.height = 'auto';
              img.style.display = 'block';
              // Preserve the original canvas dimensions
              const computedStyle = window.getComputedStyle(clonedCanvas);
              if (computedStyle.width) img.style.width = computedStyle.width;
              if (computedStyle.height) img.style.height = computedStyle.height;
              clonedCanvas.parentNode.replaceChild(img, clonedCanvas);
            }
          });
          
          // Create a temporary container for the cloned content
          const tempContainer = document.createElement('div');
          tempContainer.style.cssText = 'position: absolute; left: -9999px; top: 0; width: 100%;';
          tempContainer.appendChild(clonedContent);
          document.body.appendChild(tempContainer);
          
          const opt = {
            margin: [10, 10, 10, 10],
            filename: `zone-report-${new Date().toISOString().split('T')[0]}.pdf`,
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { 
              scale: 1.5, // Reduced from 2 to prevent canvas size issues
              useCORS: true, 
              logging: false,
              allowTaint: true
            },
            jsPDF: { unit: 'mm', format: 'letter', orientation: 'landscape' },
            pagebreak: { 
              mode: ['avoid-all', 'css'],
              avoid: ['.zone-report-section', '.zone-report-section-title', '.zone-report-table']
            }
          };
          
          html2pdf().set(opt).from(clonedContent).save().then(() => {
            // Clean up temporary container
            if (tempContainer.parentNode) {
              document.body.removeChild(tempContainer);
            }
          }).catch((error) => {
            console.error('PDF export error:', error);
            // Clean up on error
            if (tempContainer.parentNode) {
              document.body.removeChild(tempContainer);
            }
          });
        }, 500); // Wait 500ms for charts to fully render
      } else {
        // Fallback to print dialog
        alert('PDF export library not available. Please use browser print instead.');
      }
    }
    
    // Create charts for the report
    function createReportCharts(stats) {
      console.log('createReportCharts called with stats:', stats);
      
      if (typeof Chart === 'undefined') {
        console.error('Chart.js is not available');
        return;
      }
      
      if (!stats) {
        console.error('Stats object is missing');
        return;
      }
      
      // Damage Chart
      const damageCtx = document.getElementById('reportDamageChart');
      console.log('Damage chart canvas found:', !!damageCtx);
      if (damageCtx && stats.damageBreakdown) {
        const damageLabels = Object.keys(stats.damageBreakdown);
        const damageData = Object.values(stats.damageBreakdown);
        const damageTotal = damageData.reduce((a, b) => a + b, 0);
        const damageLabelsWithPct = damageLabels.map((label, index) => {
          const value = damageData[index];
          const pct = damageTotal > 0 ? ((value / damageTotal) * 100).toFixed(1) : '0';
          return `${label || 'Not Set'} (${pct}%)`;
        });
        const damageColors = ['#b4bd9b', '#fdba77', '#bc455a', '#81bdc3', '#f6cf98', '#ccd5c3', '#f9d6d3'];
        
        new Chart(damageCtx, {
          type: 'pie',
          data: {
            labels: damageLabelsWithPct,
            datasets: [{
              data: damageData,
              backgroundColor: damageColors.slice(0, damageLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 1.5,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 8,
                labels: {
                  padding: 8,
                  font: { size: 10 }
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
      
      // Status Chart
      const statusCtx = document.getElementById('reportStatusChart');
      console.log('Status chart canvas found:', !!statusCtx);
      if (statusCtx && stats.statusBreakdown) {
        const statusLabels = Object.keys(stats.statusBreakdown);
        const statusData = Object.values(stats.statusBreakdown);
        const statusTotal = statusData.reduce((a, b) => a + b, 0);
        const statusLabelsWithPct = statusLabels.map((label, index) => {
          const value = statusData[index];
          const pct = statusTotal > 0 ? ((value / statusTotal) * 100).toFixed(1) : '0';
          return `${label || 'Not Set'} (${pct}%)`;
        });
        const statusColors = ['#b4bd9b', '#81bdc3', '#fdba77', '#f6cf98', '#bc455a', '#ccd5c3', '#f9d6d3'];
        
        new Chart(statusCtx, {
          type: 'pie',
          data: {
            labels: statusLabelsWithPct,
            datasets: [{
              data: statusData,
              backgroundColor: statusColors.slice(0, statusLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 1.5,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 8,
                labels: {
                  padding: 8,
                  font: { size: 10 }
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
      
      // Contact Chart
      const contactCtx = document.getElementById('reportContactChart');
      console.log('Contact chart canvas found:', !!contactCtx);
      if (contactCtx && stats.contactedAddresses !== undefined) {
        const contacted = stats.contactedAddresses;
        const uncontacted = stats.uncontactedAddresses;
        const total = contacted + uncontacted;
        const contactedPct = total > 0 ? ((contacted / total) * 100).toFixed(1) : '0';
        const uncontactedPct = total > 0 ? ((uncontacted / total) * 100).toFixed(1) : '0';
        
        new Chart(contactCtx, {
          type: 'pie',
          data: {
            labels: [`Contacted (${contactedPct}%)`, `Uncontacted (${uncontactedPct}%)`],
            datasets: [{
              data: [contacted, uncontacted],
              backgroundColor: ['#b4bd9b', '#bc455a'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10,
                labels: {
                  padding: 12,
                  font: { size: 11 }
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    return context.label + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
      
      // Street Chart (bar chart showing addresses per street)
      const streetCtx = document.getElementById('reportStreetChart');
      console.log('Street chart canvas found:', !!streetCtx);
      if (streetCtx && stats.streetStats) {
        const streetEntries = Object.entries(stats.streetStats)
          .sort((a, b) => b[1].addresses - a[1].addresses)
          .slice(0, 10); // Top 10 streets
        
        const streetLabels = streetEntries.map(([street]) => street || 'Unknown');
        const streetData = streetEntries.map(([, data]) => data.addresses);
        const streetColors = ['#b4bd9b', '#81bdc3', '#fdba77', '#f6cf98', '#bc455a', '#ccd5c3', '#f9d6d3', '#d4a574', '#a8c090', '#e8c4a0'];
        
        new Chart(streetCtx, {
          type: 'bar',
          data: {
            labels: streetLabels,
            datasets: [{
              label: 'Addresses',
              data: streetData,
              backgroundColor: streetColors.slice(0, streetLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    return 'Addresses: ' + context.parsed.y;
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  stepSize: 1
                }
              },
              x: {
                ticks: {
                  maxRotation: 45,
                  minRotation: 45
                }
              }
            }
          }
        });
      }
    }
    
    // Toggle tool module collapse/expand
    function toggleToolModule(moduleId) {
      const module = document.getElementById(moduleId);
      if (!module) return;
      
      // Only allow expansion for specific modules
      const expandableModules = ['contactListCreator', 'zoneReportGenerator'];
      if (!expandableModules.includes(moduleId)) return;
      
      // If clicking the header of an expanded module, collapse it back to compact size
      if (module.classList.contains('expanded')) {
        module.classList.remove('expanded', 'collapsed');
        return;
      }
      
      // Otherwise, expand the module and collapse others
      const allModules = document.querySelectorAll('.tool-module');
      allModules.forEach(m => {
        if (m.id !== moduleId && expandableModules.includes(m.id)) {
          m.classList.remove('expanded', 'collapsed');
        }
      });
      
      // Add expanded class
      module.classList.add('expanded');
      module.classList.remove('collapsed');
      
      // Smoothly scroll to the expanded module after a brief delay to allow layout to update
      requestAnimationFrame(() => {
        setTimeout(() => {
          module.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'start',
            inline: 'nearest'
          });
        }, 50);
      });
    }
    
    // Setup tool module expand functionality
    function setupToolModuleExpansion() {
      // Only these modules should be expandable
      const expandableModules = ['contactListCreator', 'zoneReportGenerator'];
      
      document.querySelectorAll('.tool-module').forEach(module => {
        const moduleId = module.id;
        
        // Skip if not in expandable list or marked as no-expand
        if (!expandableModules.includes(moduleId) || module.dataset.noExpand === 'true') {
          return;
        }
        
        // Skip if already has expand listener
        if (module.dataset.expandSetup === 'true') return;
        module.dataset.expandSetup = 'true';
        
        // Header click handles expand/collapse toggle
        const header = module.querySelector('.tool-module-header');
        if (header) {
          // Remove inline onclick and use event listener instead
          header.removeAttribute('onclick');
          header.addEventListener('click', function(e) {
            e.stopPropagation();
            if (moduleId) {
              toggleToolModule(moduleId);
            }
          });
        }
        
        // Expand on click anywhere else in the module (if not expanded)
        module.addEventListener('click', function(e) {
          // Don't expand if clicking header (handled above), buttons, or interactive elements
          if (e.target.closest('.tool-module-header') || 
              e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || 
              e.target.tagName === 'A' || e.target.closest('button') || e.target.closest('a')) {
            return;
          }
          
          if (!module.classList.contains('expanded')) {
            if (moduleId) {
              toggleToolModule(moduleId);
            }
          }
        });
      });
    }
    
    // Make displayAddressList available globally for back button
    window.displayAddressList = displayAddressList;
    window.toggleToolModule = toggleToolModule;
  </script>
</body>
</html>
